# $MirSecuCron$
# $MirOS: src/etc/rc,v 1.105 2009/09/12 14:32:53 tg Exp $
# $OpenBSD: rc,v 1.277 2006/01/12 21:54:15 deraadt Exp $
#-
# System startup script run by init on autoboot or after single-user.
# Output and error are redirected to console by init, and the console
# is the controlling terminal. This is called with _PATH_BSHELL which
# must be an mksh(1).

export HOME=/ LC_CTYPE=en_US.UTF-8 PATH=/sbin:/bin:/usr/sbin:/usr/bin
umask 022
cd /

# Subroutines (have to come first).

# strip comments (and leading/trailing whitespace if IFS is set) from
# any file(s) given as argument, or stdin if none, and spew to stdout
function stripcom {
	cat "$@" | { set -o noglob; while read _line; do
		_line=${_line%%#*}
		[[ -n $_line ]] && print -r -- $_line
	done; }
}

# Update resource limits when sysctl changes
# Usage: update_limit -X loginconf_name
update_limit() {
	typeset _fl=$1	# ulimit flag
	typeset _lc=$2	# login.conf name
	typeset n s

	for s in "" -cur -max; do
		n=$(getcap -f /etc/login.conf -s $_lc$s daemon 2>/dev/null)
		if [[ -n $n ]]; then
			[[ $n = infinity ]] && n=unlimited
			case $s {
			(-cur)
				ulimit -S $_fl $n
				;;
			(-max)
				ulimit -H $_fl $n
				;;
			(*)
				ulimit $_fl $n
				return
				;;
			}
		fi
	done
}

sysctl_conf() {
	test -s /etc/sysctl.conf || return

	set -- $(stripcom /etc/sysctl.conf)
	while [ $# -ge 1 ]; do
		sysctl $1
		# update limits if needed
		case $1 {
		(kern.maxproc=*)
			update_limit -p maxproc
			;;
		(kern.maxfiles=*)
			update_limit -n openfiles
			;;
		}
		shift
	done
}

mixerctl_conf() {
	test -s /etc/mixerctl.conf || return

	set -- $(stripcom /etc/mixerctl.conf)
	while [ $# -ge 1 ]; do
		mixerctl $1
		shift
	done
}

wsconsctl_conf() {
	typeset dev res save_IFS=$IFS

	test -x /sbin/wsconsctl -a -s /etc/wsconsctl.conf || return
	IFS="
"
	set -- $(stripcom /etc/wsconsctl.conf)
	IFS=$save_IFS
	while [ $# -ge 1 ]; do
		for dev in /dev/wskbd*; do
			res=$(eval wsconsctl -k \$dev -w $1 2>/dev/null)
			[[ -z $res ]] || print -r -- "$dev: $res"
		done
		shift
	done
}

# Sort the "/etc/fstab" arrays:
# -> sorting is done on $_mp[] from 0 to ${#_mp[*]}-1
# -> swapping is done on $_dev[] $_mp[] $_fstype[] $_opt[]
function _fsswap {
	typeset dev mp fstype opt rest

	dev=${_dev[$1]}
	mp=${_mp[$1]}
	fstype=${_fstype[$1]}
	opt=${_opt[$1]}

	_dev[$1]=${_dev[$2]}
	_mp[$1]=${_mp[$2]}
	_fstype[$1]=${_fstype[$2]}
	_opt[$1]=${_opt[$2]}

	_dev[$2]=$dev
	_mp[$2]=$mp
	_fstype[$2]=$fstype
	_opt[$2]=$opt
}

function _fssort {
	typeset -i i=0
	while (( i < (${#_mp[*]} - 1) )); do
		typeset -i j=i k=i+1
		while (( k < ${#_mp[*]} )); do
			[[ ${_mp[k]} < ${_mp[j]} ]] && j=k
			let k++
		done
		(( i != j )) && _fsswap $i $j
		let i++
	done
}

# End subroutines

# Set shell to ignore SIGINT (2), but not children;
# shell catches SIGQUIT (3) and returns to single user after fsck.
trap : 2
trap : 3	# shouldn't be needed

# If we are about to shut down, execute this bunch of code,
# otherwise (startup), skip below
if [[ $1 = shutdown ]]; then
	[[ -x /usr/sbin/wsconfig ]] && /usr/sbin/wsconfig -s 1 2>&-
	echo Received shutdown request.
	(
		dd if=/var/db/host.random of=/dev/urandom
		(dd if=/dev/arandom count=3; dd if=/dev/urandom count=8) | \
		    dd of=/var/db/host.random && \
		    chmod 600 /var/db/host.random
	) >/dev/wrandom 2>&1 && if [[ -f /etc/rc.shutdown ]]; then
		echo /etc/rc.shutdown in progress...
		. /etc/rc.shutdown
		echo /etc/rc.shutdown complete.

		# bring carp interfaces down gracefully
		for hn in /etc/hostname.carp[0-9]*; do
			[[ -e $hn ]] || continue
			if=${hn#/etc/hostname.}
			[[ " $(ifconfig -l) " = *@( $if )* ]] && \
			    ifconfig $if down
		done

		{
			dd if=/dev/urandom of=/dev/arandom bs=4 count=1
			sleep 1
			dd if=/dev/arandom count=1 >>/var/db/host.random
		} >/dev/null 2>&1

		[[ $powerdown = YES ]] && exit 2
	else
		echo single user: not running /etc/rc.shutdown
	fi
	exit 0
fi

# Gather some system-local entropy rather early, if possible (/usr = /)
[[ -x /usr/libexec/cprng ]] && /usr/libexec/cprng -pr16 >/dev/urandom &

# Configure ccd devices.
[[ -f /etc/ccd.conf ]] && ccdconfig -C

# Configure raid devices.
for dev in 0 1 2 3 4 5 6 7; do
	[[ -f /etc/raid${dev}.conf ]] && \
	    raidctl -c /etc/raid${dev}.conf raid$dev
done

# Check parity on raid devices.
raidctl -P all

swapctl -A -t blk

consspeed=$(stty -f /dev/console speed)
print -u2 "console at $consspeed bps"

# pick up configuration options
. /etc/rc.conf

# Read /etc/fstab into arrays and sort by mountpoint
typeset -i i=0
set -A _dev _mp _fstype _opt
stripcom /etc/fstab |&
while read -p _fdev _fmp _ffstype _fopt _frest; do
	_dev[i]=$_fdev
	_mp[i]=$_fmp
	_fstype[i]=$_ffstype
	_opt[i]=${_fopt:-rw}
	let i++
done
_fssort

# Examine the filesystems whether there are IDE drives
if [[ $softdrives_ide = NO ]]; then
	# auto-detect from /etc/fstab
	softdrives_ide=
	i=0
	while (( i < ${#_mp[*]} )); do
		if [[ ${_dev[i]} = /dev/wd+([0-9])[a-p] ]]; then
			_fdev=${_dev[i]#/dev/}
			softdrives_ide="$softdrives_ide ${_fdev%[a-p]}"
		fi
		let i++
	done
fi

# Needed for softdep to work correctly (SCSI drives, too!)
if [[ -n $softdrives_ide ]]; then
	echo -n Disabling HDD hardware write caches...
	x=:
	for drv in $softdrives_ide; do
		[[ $x = *:$drv:* ]] && continue
		echo -n " $drv"
		atactl /dev/r${drv}c secfreeze >/dev/null 2>&1
		atactl /dev/r${drv}c writecachedisable >/dev/null 2>&1 || \
		    echo -n !
		x=$x$drv:
	done
	echo .
fi

# Check filesystems
if [[ -e /fastboot ]]; then
	echo Fast boot: skipping disk checks.
elif [[ $1 = autoboot ]]; then
	echo Automatic boot in progress: starting file system checks.
	fsck -p
	case $? {
	(0)
		;;
	(2)
		exit 1
		;;
	(4)
		echo Rebooting...
		reboot
		echo "Reboot failed; help!"
		exit 1
		;;
	(8)
		echo "Automatic file system check failed; help!"
		exit 1
		;;
	(12)
		echo Boot interrupted.
		exit 1
		;;
	(130)
		# interrupt before catcher installed
		exit 1
		;;
	(*)
		echo "Unknown error; help!"
		exit 1
		;;
	}
fi

trap "echo Boot interrupted.; exit 1" 3

umount -a >/dev/null 2>&1
i=0
while (( i < ${#_mp[*]} )); do
	if [[ ${_mp[i]} = / && ${_opt[i]}, != ro,* ]]; then
		if ! mount -uwo "${_opt[i]}" "${_dev[i]}" / >/dev/null 2>&1; \
		    then
			if [[ ,${_opt[i]}, != *,softdep,* ]]; then
				echo -n 'WARNING: Your root filesystem failed'
				echo -n ' to remount read-write! <forcing...>'
				echo 'The system is probably severely damaged'
			fi
			mount -ufwo "${_opt[i]}" "${_dev[i]}" /
		fi
	elif [[ ,${_opt[i]}, != *,noauto,* && ${_opt[i]}, != @(sw|xx),* ]]; then
		if [[ ${_fstype[i]} = ffs ]]; then
			if ! mount -t ffs -o "${_opt[i]}" "${_dev[i]}" \
				"${_mp[i]}" >/dev/null 2>&1; then
				if [[ ,${_opt[i]}, != *,softdep,* ]]; then
					echo -n "Warning: force-mounting unch"
					echo -n "ecked ffs filesystem nosoft"
					echo "dep: ${_dev[i]} -> ${_mp[i]}"
				fi
				mount -f -t ffs -o "${_opt[i]}" \
				    "${_dev[i]}" "${_mp[i]}"
			fi
		elif [[ ${_fstype[i]} != nfs ]]; then
			# Ignore NFS this early in the boot process
			mount -t "${_fstype[i]}" -o "${_opt[i]}" \
			    "${_dev[i]}" "${_mp[i]}"
		fi
	fi
	let i++
done
mount -a -t nonfs
# root on nfs may require this
mount 2>/dev/null |&
x=
while read -p line; do
	[[ $line = *@( on / )* ]] || continue
	x=$line
	break
done
[[ -z $x || $x = *\(*read-only* ]] && mount -uw /
# root is now writable
rm -f /fastboot

# Gather some system-local entropy rather early if allowed and /usr now mounted
[[ $cprng_flags != NO && -x /usr/libexec/cprng ]] && \
    /usr/libexec/cprng -pr32 >/dev/urandom &

# enable running applications from /usr for now
[[ -x /sbin/ldconfig && -d /var/run/. ]] && /sbin/ldconfig

# set flags on ttys.  (do early, in case they use tty for SLIP in netstart)
echo setting tty flags
ttyflags -a

if [[ $pf != NO ]]; then
	RULES="block all"
	RULES="$RULES\npass on lo0"
	RULES="$RULES\npass in proto tcp from any to any port 22 keep state"
	RULES="$RULES\npass out proto { tcp, udp } from any to any port 53 keep state"
	RULES="$RULES\npass out inet proto icmp all icmp-type echoreq keep state"
	if ifconfig lo0 inet6 >/dev/null 2>&1; then
		RULES="$RULES\npass out inet6 proto icmp6 all icmp6-type neighbrsol"
		RULES="$RULES\npass in inet6 proto icmp6 all icmp6-type neighbradv"
		RULES="$RULES\npass out inet6 proto icmp6 all icmp6-type routersol"
		RULES="$RULES\npass in inet6 proto icmp6 all icmp6-type routeradv"
	fi
	RULES="$RULES\npass proto { pfsync, carp }"
	if [[ "$(sysctl vfs.mounts.nfs 2>/dev/null)" = *[1-9]* ]]; then
		# don't kill NFS
		RULES="scrub in all no-df\n$RULES"
		RULES="$RULES\npass in proto udp from any port { 111, 2049 } to any"
		RULES="$RULES\npass out proto udp from any to any port { 111, 2049 }"
	fi
	echo $RULES | pfctl -f -
	pfctl -e
fi

sysctl_conf

# configure wscons(4) early, in case someone needs to interrupt e.g. dhclient
wsconsctl_conf

# set hostname, turn on network
echo starting network
if [ -f /etc/resolv.conf.save ]; then
	mv /etc/resolv.conf.save /etc/resolv.conf
	touch /etc/resolv.conf
fi
[[ -e /etc/rc.netselect ]] && . /etc/rc.netselect
. /etc/netstart

[[ $pf != NO && -s $pf_rules ]] && pfctl -f "$pf_rules"

# ensure /usr and /var are mounted, even if marked noauto
i=0
while (( i < ${#_mp[*]} )); do
	if [[ ${_mp[i]} = /@(usr|var) ]]; then
		x=$(mount 2>/dev/null | fgrep " on ${_mp[i]} " 2>/dev/null)
		[[ -z $x ]] && mount ${_mp[i]} >/dev/null 2>&1
	fi
	let i++
done

# on sparc, use the nvram to provide some additional entropy
[[ -x /usr/sbin/eeprom ]] && eeprom 2>&1 | cksum -ba sha512 >/dev/wrandom

# load arp tables
if [[ $arptables = YES && -s /etc/arp.conf ]]; then
	echo Setting static ARP table entries
	arp -f /etc/arp.conf
fi

# read old random seed; if there's no /var/db/host.random, make
# one through random(4); else reset seed file anyway so that if
# a shutdown-less reboot occurs the next seed is not a repeat -
# also reset arandom(4)
{
	cat /var/db/host.random >/dev/urandom
	(dd if=/dev/arandom count=3; dd if=/dev/urandom count=5) | \
	    dd of=/var/db/host.random
	chmod 600 /var/db/host.random
	sync

	let RANDOM=$(dd if=/dev/arandom bs=4 count=1 2>&- | hexdump -e '"%u"')
	set -o arc4random
	typeset -i1 a=RANDOM b=RANDOM c=RANDOM d=RANDOM
	print -nr -- "${a#1#}${b#1#}${c#1#}${d#1#}" >/dev/arandom
	unset a b c d

	dd if=/dev/arandom count=3 >>/var/db/host.random
	let RANDOM=$(dd if=/dev/arandom bs=4 count=1 2>&- | hexdump -e '"%u"')
} >/dev/wrandom 2>&1

# clean up left-over files
rm -f /etc/nologin
rm -f /var/spool/lock/LCK.*
rm -f /var/spool/uucp/STST/*
rm -rf /var/{run,authpf}/*
install -c -m 664 -g utmp /dev/null /var/run/utmp

if [[ -f /sbin/ldconfig ]]; then
	echo creating runtime link editor directory cache.
	[[ -d /usr/local/lib ]] && shlib_dirs="/usr/local/lib $shlib_dirs"
	[[ -d /usr/X11R6/lib ]] && shlib_dirs="/usr/X11R6/lib $shlib_dirs"
	[[ -d /usr/mpkg/lib ]] && shlib_dirs="/usr/mpkg/lib $shlib_dirs"
	ldconfig $shlib_dirs
	PATH=/sbin:/bin:/usr/sbin:/usr/bin
fi

# save a copy of the boot messages
dmesg | tee /var/run/dmesg.boot | cksum -ba rmd160 >/dev/wrandom

# Initialise anoncvs chroot /dev directory
i=0
grep ':/var/anoncvs.*:/usr/libexec/anoncvssh$' /etc/master.passwd |&
while IFS=: read -p name pass rest; do
	[[ $pass = '*' ]] || i=1
done
(( i )) && if [[ -d /var/anoncvs/dev/. ]]; then
	mount_mfs -s 128 swap /var/anoncvs/dev
	(cd /dev; pax -rw -pe arandom wrandom null zero /var/anoncvs/dev/)
	syslogd_flags="$syslogd_flags -a /var/anoncvs/dev/log"
fi

echo starting system logger
rm -f /dev/log
if [[ $httpd_flags != NO && " $httpd_flags " != *@( -u )* ]]; then
	rm -f /var/www/dev/log
	mkdir -p -m 0555 /var/www/dev
	syslogd_flags="$syslogd_flags -a /var/www/dev/log"
fi
if [[ $named_flags != NO && -d /var/named/dev/. ]]; then
	rm -f /var/named/dev/log
	syslogd_flags="$syslogd_flags -a /var/named/dev/log"
fi
if [[ -d /var/empty/. ]]; then
	rm -f /var/empty/dev/log
	mkdir -p -m 0555 /var/empty/dev
	syslogd_flags="$syslogd_flags -a /var/empty/dev/log"
fi
syslogd $syslogd_flags

[[ $pf != NO && $pflogd_flags != NO ]] && \
    if ifconfig pflog0 >/dev/null 2>&1; then
	ifconfig pflog0 up
	pflogd $pflogd_flags
fi

# $isakmpd_flags is imported from /etc/rc.conf;
# If $isakmpd_flags == NO, isakmpd isn't run.
if [[ $isakmpd_flags != NO ]]; then
	echo starting isakmpd;		isakmpd $isakmpd_flags
fi

echo -n starting initial daemons:

if [[ $cprng_flags != NO ]]; then
	echo -n ' cprng';		/usr/libexec/cprng $cprng_flags
fi

if [[ $tpmrng_flags != NO && -x /usr/libexec/tpmrng ]]; then
	echo -n ' tpmrng';		/usr/libexec/tpmrng $tpmrng_flags
fi

# $portmap is imported from /etc/rc.conf;
# if $portmap == YES, the portmapper is started.
if [[ $portmap = YES ]]; then
	echo -n ' portmap';		portmap
else
	nfs_server=NO
fi

# $nfs_server is imported from /etc/rc.conf;
# if $nfs_server == YES, the machine is setup for being an nfs server
if [[ $nfs_server = YES && -s /etc/exports && \
    $(stripcom /etc/exports | wc -l) -ne 0 ]]; then
	rm -f /var/db/mountdtab
	echo -n >/var/db/mountdtab
	echo -n ' mountd';		mountd $mountd_flags
	echo -n ' nfsd';		nfsd $nfsd_flags
	if [[ $lockd = YES ]]; then
		echo -n ' rpc.lockd';	rpc.lockd
	fi
fi

# run rdate before timed/ntpd
if [[ $rdate_flags != NO ]]; then
	echo -n ' rdate';		rdate -s $rdate_flags 2>&1 |&
	set -A rdate_flags
	i=0
	while read -p x; do
		rdate_flags[${#rdate_flags[*]}]=$x
	done
fi

# $timed_flags is imported from /etc/rc.conf;
# if $timed_flags == NO, timed isn't run.
if [[ $timed_flags != NO ]]; then
	echo -n ' timed';		timed $timed_flags
fi

if [[ $ntpd_flags != NO ]]; then
	echo -n ' ntpd';		ntpd $ntpd_flags
fi

echo .
[[ $rdate_flags = NO ]] || while (( i < ${#rdate_flags[*]} )); do
	print -r -- "${rdate_flags[i++]}"
done

mount -a -t nfs

swapctl -A -t noblk

# /var/crash should be a directory or a symbolic link
# to the crash directory if core dumps are to be saved.
[[ -d /var/crash ]] && savecore $savecore_flags /var/crash

if [[ $check_quotas = YES ]]; then
	echo -n 'checking quotas: '
	quotacheck -a
	echo done.
	quotaon -a
fi

# build ps databases
echo -n building ps databases:
[[ -e /var/db/kvm_bsd.new ]] && mv -f /var/db/kvm_bsd.new /var/db/kvm_bsd.db
if [[ $kvm_mkdb != NO ]]; then
	echo -n " kvm"
	kvm_mkdb
fi
echo -n " dev"
dev_mkdb
echo .

chmod 666 /dev/tty[pqrstuvwxyzPQRST]*
chown root:wheel /dev/tty[pqrstuvwxyzPQRST]*

# check the password temp/lock file
[[ -f /etc/ptmp ]] && logger -s -p auth.err \
    'password file may be incorrect -- /etc/ptmp exists'

echo clearing /tmp
x=$(mount 2>/dev/null | fgrep " on /tmp" 2>/dev/null)
if [[ -z $x ]]; then
	# clean up as usual on small systems
	rm -rf /tmp
	mkdir /tmp
	chown 0:0 /tmp
	chmod 01777 /tmp
elif [[ $x != *@(type mfs)* ]]; then
	# prune quickly with one rm, then use find to clean up /tmp/[lq]*
	(cd /tmp && rm -rf [a-km-pr-zA-Z]* && \
	    find . ! -name . ! -name lost+found ! -name quota.user \
		! -name quota.group -execdir rm -rf -- {} \; -type d -prune)
fi

# create Unix sockets directories for X if needed and make sure they have
# correct permissions
if [[ -d /usr/X11R6/lib ]]; then
	for d in /tmp/.X11-unix /tmp/.ICE-unix; do
		[[ -e $d ]] || mkdir -p $d
		if [[ -d $d ]]; then
			[[ $(stat -f %u $d) = 0 ]] || chown 0 $d
			[[ $(stat -f %p $d) = 41777 ]] || chmod 1777 $d
		elif [[ -e $d ]]; then
			echo "Error: $d exists and isn't a directory."
		fi
	done
fi

[[ -f /etc/rc.securelevel ]] && . /etc/rc.securelevel
if [[ -n $securelevel ]]; then
	echo -n 'setting kernel security level: '
	sysctl kern.securelevel=$securelevel
fi

# patch /etc/motd
x=$(sysctl -n kern.version | sed 1q)
[[ -s /etc/motd && "$([[ "$(head -1 /etc/motd)" != $x ]] && \
    ed -s /etc/motd 2>&1 <<-EOF
	1,/^\$/d
	0a
		$x

	.
	wq
EOF)" = @(?) ]] && rm -f /etc/motd
if [[ ! -s /etc/motd ]]; then
	install -c -o root -g wheel -m 664 /dev/null /etc/motd
	print "$x\n" >/etc/motd
fi

if [[ -f /var/account/acct ]]; then
	echo turning on accounting;	accton /var/account/acct
fi

if [[ -x /usr/libexec/vi.recover && -d /var/tmp/vi.recover ]]; then
	echo preserving editor files;	/usr/libexec/vi.recover
fi

if [[ -e /etc/rc.once ]]; then
	print rc: running post-install hooks
	mksh /etc/rc.once
fi

# Generate all the RSA keys we might need
if [[ ! -s /etc/ssl/private/default.key && -s /etc/ssh/ssh_host_rsa_key ]]; then
	print "openssl: using old SSH host RSA key"
	rm -f /etc/ssl/{def{ault,lt-ca}.cer,private/default.key}
	cat /etc/ssh/ssh_host_rsa_key >/etc/ssl/private/default.key
	chmod 600 /etc/ssl/private/default.key
fi
if [[ ! -s /etc/ssl/private/default.key ]]; then
	print -n "openssl: generating new host RSA key... "
	rm -f /etc/ssl/{def{ault,lt-ca}.cer,private/default.key}
	# XXX 6000-8000 is recommended... choose less to be nice to old boxen
	if openssl genrsa -out /etc/ssl/private/default.key 4096 \
	    >/dev/wrandom 2>&1; then
		chmod 600 /etc/ssl/private/default.key
		rm -f /etc/ssh/ssh_host_rsa_key
		print done.
	else
		print failed.
	fi
fi
if [[ ! -s /etc/ssl/default.cer || ! -s /etc/ssl/deflt-ca.cer ]]; then
	print -n "openssl: generating new host X.509v3 certificate... "
	rm -f /etc/ssl/def{ault,lt-ca}.cer
	openssl req -batch -new -subj "/CN=$(hostname)/" \
	    -key /etc/ssl/private/default.key \
	    -x509 -out /etc/ssl/default.cer
	chmod 644 /etc/ssl/default.cer
	cp /etc/ssl/default.cer /etc/ssl/deflt-ca.cer
	print done
fi
if [[ ! -s /etc/ssh/ssh_host_rsa_key ]]; then
	print -n "ssh-keygen: installing host RSA key... "
	ln /etc/ssl/private/default.key /etc/ssh/ssh_host_rsa_key || \
	    cp /etc/ssl/private/default.key /etc/ssh/ssh_host_rsa_key
	rm -f /etc/ssh/ssh_host_rsa_key.pub
	print done.
fi
if [[ ! -s /etc/ssh/ssh_host_rsa_key.pub ]]; then
	print -n "ssh-keygen: installing host public key... "
	print -r -- $(ssh-keygen -yf /etc/ssh/ssh_host_rsa_key) \
	    $(hostname) host key >/etc/ssh/ssh_host_rsa_key.pub
	chmod 600 /etc/ssh/ssh_host_rsa_key
	chmod 644 /etc/ssh/ssh_host_rsa_key.pub
	print done.
fi

echo -n starting network daemons:

# $routed_flags are imported from /etc/rc.conf.
# If $routed_flags == NO, routed isn't run.
# Same for the other dæmons.

if [[ $routed_flags != NO ]]; then
	echo -n ' routed';		routed $routed_flags
fi

if [[ $mrouted_flags != NO ]]; then
	echo -n ' mrouted';		mrouted $mrouted_flags
fi

if [[ $ospfd_flags != NO && -x /usr/sbin/ospfd ]]; then
	echo -n ' ospfd';		/usr/sbin/ospfd $ospfd_flags
fi

if [[ $bgpd_flags != NO && -x /usr/sbin/bgpd ]]; then
	echo -n ' bgpd';		/usr/sbin/bgpd $bgpd_flags
fi

if [[ $dhcpd_flags != NO && -f /etc/dhcpd.conf ]]; then
	touch /var/db/dhcpd.leases
	[[ -f /etc/dhcpd.interfaces ]] && \
	    dhcpd_ifs=$(stripcom /etc/dhcpd.interfaces)
	echo -n ' dhcpd';		/usr/sbin/dhcpd $dhcpd_flags $dhcpd_ifs
fi

if ifconfig lo0 inet6 >/dev/null 2>&1; then
	fw=$(sysctl -n net.inet6.ip6.forwarding)
	if [[ $fw = 0 ]]; then
		if [[ $rtsold_flags != NO ]]; then
			echo -n ' rtsold'
			/usr/sbin/rtsold $rtsold_flags
		fi
	else
		if [[ $route6d_flags != NO ]]; then
			echo -n ' route6d'
			/usr/sbin/route6d $route6d_flags
		fi
		if [[ $rtadvd_flags != NO ]]; then
			echo -n ' rtadvd'
			/usr/sbin/rtadvd $rtadvd_flags
		fi
	fi
fi

# if $rwhod == YES, rwhod is run.
if [[ $rwhod = YES ]]; then
	echo -n ' rwhod';		rwhod
fi

if [[ $lpd_flags != NO ]]; then
	echo -n ' lpd';			lpd $lpd_flags
fi

# $sendmail_flags is imported from /etc/rc.conf;
# If $sendmail_flags == NO or /etc/mailer.conf doesn't exist, then
# sendmail isn't run.  We call sendmail with a full path so that
# SIGHUP works.  Note that /usr/sbin/sendmail may actually call a
# mailer other than sendmail, depending on /etc/mailer.conf.
if [[ $sendmail_flags != NO && -s /etc/mailer.conf ]]; then
	echo -n ' sendmail'
	( /usr/sbin/sendmail $sendmail_flags <>/dev/null >&0 2>&0 & )
fi

if [[ $httpd_flags != NO ]]; then
	# Clean up left-over httpd locks
	rm -f /var/www/logs/{ssl_mutex,httpd.lock,accept.lock}.*
	echo -n ' httpd';		/usr/sbin/httpd $httpd_flags
fi

if [[ $ftpd_flags != NO ]]; then
	echo -n ' ftpd';		/usr/libexec/ftpd $ftpd_flags
fi

if [[ $ftpproxy_flags != NO ]]; then
	echo -n ' ftp-proxy';		/usr/sbin/ftp-proxy $ftpproxy_flags
fi

if [[ $identd_flags != NO ]]; then
	echo -n ' identd';		/usr/libexec/identd $identd_flags
fi

if [[ $inetd = YES && -s /etc/inetd.conf ]]; then
	echo -n ' inetd';		inetd
fi

if [[ $sshd_flags != NO ]]; then
	echo -n ' sshd';		/usr/sbin/sshd $sshd_flags
fi

if [[ $spamd_flags != NO ]]; then
	[[ $spamd_black != NO ]] && spamd_flags="$spamd_flags -b"
	echo -n ' spamd';		eval /usr/libexec/spamd $spamd_flags
	/usr/libexec/spamd-setup
	if [[ $spamd_black = NO ]]; then
		echo -n ' spamlogd'
		/usr/libexec/spamlogd
	fi
fi

# If $rarpd_flags == NO or /etc/ethers doesn't exist, then
# rarpd isn't run.
if [[ $rarpd_flags != NO && -s /etc/ethers ]]; then
	echo -n ' rarpd';		rarpd $rarpd_flags
fi

# If $bootparamd_flags == NO or /etc/bootparams doesn't exist, then
# bootparamd isn't run.
if [[ $bootparamd_flags != NO && -s /etc/bootparams ]]; then
	echo -n ' rpc.bootparamd';	rpc.bootparamd $bootparamd_flags
fi

# If $rbootd_flags == NO or /etc/rbootd.conf doesn't exist, then
# rbootd isn't run.
if [[ $rbootd_flags != NO && -s /etc/rbootd.conf ]]; then
	echo -n ' rbootd';		rbootd $rbootd_flags
fi

if [[ $isdnd_flags != NO ]]; then
	echo -n ' isdnd';		/usr/sbin/isdnd $isdnd_flags
fi

echo .

mixerctl_conf

# if /etc/ttys does not include a console entry, remove it (borken)
grep -q '^console' /etc/ttys >/dev/null 2>&1 || rm -f /etc/ttys
# if /etc/ttys does not exist (or was broken), install a fresh copy
[[ -e /etc/ttys ]] || install -c -o 0 -g 0 -m 644 /etc/ttys.dist /etc/ttys
# if /etc/ttys indicates auto-setup of console speed, do that
grep -q '^console.*acs\.[0-9s]' /etc/ttys >/dev/null 2>&1 && \
    ed -s /etc/ttys >/dev/null 2>&1 <<-EOF
	/^console/s/acs\.[0-9]*/acs.${consspeed}/
	wq
EOF

[[ -f /etc/rc.local ]] && . /etc/rc.local

# Only if it exists and is an unused ram disc array.
# Compare approximately like the kernel does, except
# we checksum the first 2 pages instead of a memcmp.
x=$(dd if=/dev/rrd0c count=16 2>/dev/wrandom | cksum -a adler32)
[[ $x = 1B32098C ]] && swapctl -ap0 /dev/rd0c

if [[ $sshagent_autostart != NO ]]; then
	echo Setting up ssh-agent directories...
	mkdir -m 0755 /var/run/ssh-agent
	chown root:daemon /var/run/ssh-agent
	for luser in $sshagent_autostart; do
		mkdir -m 0700 /var/run/ssh-agent/$luser
		chown $luser /var/run/ssh-agent/$luser
		rm -f /var/run/ssh-agent/$luser/agent
	done
fi

echo -n standard daemons:
# don't run daemon if $food_flags == NO or /usr/sbin/food doesn't exist

if [[ $apmd_flags != NO && -x /usr/sbin/apmd ]]; then
	echo -n ' apmd';	/usr/sbin/apmd $apmd_flags
fi

if [[ $acpid_flags != NO && -x /usr/sbin/acpid ]]; then
	echo -n ' acpid';	/usr/sbin/acpid $acpid_flags
fi

if [[ $sensorsd_flags != NO && -x /usr/sbin/sensorsd ]]; then
	echo -n ' sensorsd';	/usr/sbin/sensorsd $sensorsd_flags
fi

if [[ $hotplugd_flags != NO && -x /usr/sbin/hotplugd ]]; then
	echo -n ' hotplugd';	/usr/sbin/hotplugd $hotplugd_flags
fi

if [[ $watchdogd_flags != NO && -x /usr/sbin/watchdogd ]]; then
	echo -n ' watchdogd';	/usr/sbin/watchdogd $watchdogd_flags
fi

echo -n ' cron';		cron

if [[ $wsmoused_flags != NO && -x /usr/sbin/wsmoused ]]; then
	echo -n ' wsmoused';	/usr/sbin/wsmoused $wsmoused_flags
fi

echo .

date

# Alternatively, on some architectures, xdm may be started in /etc/ttys.
if [[ $xdm_flags != NO && -x /usr/X11R6/bin/xdm ]]; then
	echo starting xdm...;		/usr/X11R6/bin/xdm $xdm_flags
fi

exit 0
