.\" $MirOS: src/lib/libc/time/taitime.3,v 1.6 2007/02/07 20:43:24 tg Exp $
.\"-
.\" Copyright (c) 2004, 2005, 2007
.\"	Thorsten Glaser <tg@mirbsd.de>
.\"
.\" Provided that these terms and disclaimer and all copyright notices
.\" are retained or reproduced in an accompanying document, permission
.\" is granted to deal in this work without restriction, including un-
.\" limited rights to use, publicly perform, distribute, sell, modify,
.\" merge, give away, or sublicence.
.\"
.\" Advertising materials mentioning features or use of this work must
.\" display the following acknowledgement:
.\"	This product includes material provided by Thorsten Glaser.
.\"
.\" This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
.\" the utmost extent permitted by applicable law, neither express nor
.\" implied; without malicious intent or gross negligence. In no event
.\" may a licensor, author or contributor be held liable for indirect,
.\" direct, other damage, loss, or other issues arising in any way out
.\" of dealing in the work, even if advised of the possibility of such
.\" damage or existence of a defect, except proven that it results out
.\" of said person's immediate fault when using the work as intended.
.\"-
.Dd February 7, 2007
.Dt TAITIME 3
.Os
.Sh NAME
.Nm tai_leaps ,
.Nm tai_isleap ,
.Nm timet2tai ,
.Nm tai2timet ,
.Nm utc2tai ,
.Nm tai2utc ,
.Nm mjd2tai ,
.Nm tai2mjd ,
.Nm mjd2tm ,
.Nm tm2mjd ,
.Nm tai_time ,
.Nm taina_time ,
.Nm exporttai ,
.Nm importtai
.Nd year-2038-safe leap second compliant 64 bit time functions
.Sh SYNOPSIS
.Fd #include <sys/types.h>
.Fd #include <sys/taitime.h>
.Pp
.Ft "tai64_t"
.Fn tai_time "tai64_t *t"
.Ft "void"
.Fn taina_time "tai64na_t *t"
.Ft "tai64_t *"
.Fn tai_leaps "void"
.Ft "int"
.Fn tai_isleap "tai64_t t"
.Ft "tai64_t"
.Fn timet2tai "time_t tv"
.Ft "time_t"
.Fn tai2timet "tai64_t t"
.Ft "tai64_t"
.Fn utc2tai "int64_t t"
.Ft "int64_t"
.Fn tai2utc "tai64_t t"
.Ft "tai64_t"
.Fn mjd2tai "mjd_t mjd"
.Ft "mjd_t"
.Fn tai2mjd "tai64_t t"
.Ft "struct tm"
.Fn mjd2tm "mjd_t mjd"
.Ft "mjd_t"
.Fn tm2mjd "struct tm tm"
.Ft "void"
.Fn exporttai "u_int8_t *dst" "tai64na_t *src"
.Ft "void"
.Fn importtai "u_int8_t *src" "tai64na_t *dst"
.Sh DESCRIPTION
The
.Fn tai_time
and
.Fn taina_time
functions return the current time in the TAI64 format into the
tai64_t or tai64na_t variable pointed to by the
.Fa t
argument, if the argument is not
.Dv NULL .
Additionally,
.Fn tai_time
returns the value.
.Pp
The
.Vt tai64_t
and
.Vt tai64na_t
data types are specified further below.
.Pp
The
.Fn tai_leaps
function returns a pointer, which is guaranteed to be not
.Dv NULL ,
to a zero-terminated array of
.Vt tai64_t
values, each denoting a positive leap second.
DJB says, negative leap seconds are not likely to happen;
if they should, a new interface will be published.
This function uses a table which should be initialised with
.Fn tzset
beforehand if mechanisms such as
.Xr chroot 2
are employed.
.Pp
The
.Fn tai_isleap
function returns 1 if
.Fa t
is known to be a (positive) leap second, 0 if otherwise.
.Pp
The
.Fn timet2tai
and
.Fn tai2timet
routines convert their argument between the TAI64 format and the
.Vt time_t
data type which is generally used in time keeping, for example by the
.Xr gettimeofday 2
system call.
Generally speaking, a
.Vt time_t
counts the number of real seconds that have happened since January 1,
1970, 00:00:00 UTC (coordinated universal time).
.Pp
The
.Fn utc2tai
and
.Fn tai2utc
functions convert between the TAI64 format and an UTC value expressed as
.Vt int64_t .
The UTC value equals the
.Vt time_t
value as shown above, with the difference that not real seconds are
counted, but seconds that would have happened if every full day had
exactly 86400 seconds.
Because there are leap seconds, in reality some days have 86401 and
some 86399 seconds, that's why this format cannot be used for reliable
time keeping (it \fBis\fR being used by the NTP protocol), but it's
useful for conversion between calendar dates and second-counting dates.
.St -p1003.1
compliant systems, unlike
.Mx ,
force their
.Vt time_t
type and internal kernel time to be in this format, completely ignoring
the existence of leap seconds.
.Pp
The
.Fn mjd2tai
and
.Fn tai2mjd
functions convert between the TAI64 type and the MJD structure described
further below, which keeps time in a calendar format.
.Pp
The
.Fn mjd2tm
and
.Fn tm2mjd
functions convert between the MJD structure and the more common
.Vt struct tm
as used by
.Xr mktime 3 .
.Fn tm2mjd
converts the fields
.Ic tm_sec , tm_min , tm_hour , tm_mday ,
.Ic tm_mon , tm_year , tm_gmtoff
of
.Vt struct tm ;
.Fn mjd2tm
fills the fields
.Ic tm_sec , tm_min , tm_hour , tm_mday ,
.Ic tm_mon , tm_year , tm_wday , tm_yday
with sensible values and
.Ic tm_isdst , tm_gmtoff , tm_zone
with null values.
.Pp
The
.Fn exporttai
and
.Fn importtai
functions convert between internal TAI64NA format and DJB-compatible
on-the-wire TAI64NA/TAICLOCK format.
See below for further documentation.
.Pp
The functions and data types described above are defined in the
.Aq Pa time.h
header file.
The data type
.Li tai64_t
is aliased to
.Li int64_t .
The data type
.Li tai64na_t
includes the following fields:
.Bd -literal -offset indent
	tai64_t secs;		/* seconds (see below) */
	uint32_t nano;		/* nanoseconds */
	uint32_t atto;		/* attoseconds */
.Ed
.Pp
The data type
.Li mjd_t
includes the following fields:
.Bd -literal -offset indent
	time_t mjd;		/* day of modified julian calendar */
	int32_t sec;		/* second within the day */
.Ed
.Sh FILES
.Bl -tag -width "/usr/share/zoneinfo/posixrules" -compact
.It Pa /usr/share/zoneinfo
time zone information directory
.It Pa /usr/share/zoneinfo/UTC
default source of leap second information
.It Pa /usr/share/zoneinfo/posixrules
alternative source of leap second information, if
.Pa UTC
is absent.
.El
.Sh SEE ALSO
.Xr chroot 2 ,
.Xr gettimeofday 2 ,
.Xr mktime 3 ,
.Xr ntpd 8 ,
.Xr tzset 3
.Sh STANDARDS
This set of functions expects your operating system to not conform to
.St -p1003.1
for correct
.Vt time_t
handling.
.Pp
The exported TAI64NA datatype and the TAI64 second offset
have been standardised by Dan J. Bernstein, see
.Pa http://cr.yp.to/proto/utctai.html
for a general overview of UTC, TAI and the NTP/POSIX problems,
.Pa http://cr.yp.to/libtai/tai64.html
for the various data types and
.Pa http://cr.yp.to/proto/taiclock.txt
for the specification of the on-wire TAICLOCK format,
which contains the result of the
.Fn exporttai
function in bytes 4 to 19.
.Sh HISTORY
The TAI function suite appeared in
.Mx 8 .
.Sh AUTHORS
The original author of the TAI64 data types and the libtai library
for TAI64 manipulation, which was placed into public domain, is
.An Dan J. Bernstein Aq djb@cr.yp.to .
.Pp
The libc implementation of TAI64 functions are authored by
.An Thorsten Do mirabilos Dc Glaser Aq tg@mirbsd.org .
.Sh CAVEATS
The libc TAI functions have different function names and data
types (except the exported TAI64NA on-the-wire format) than
the DJB libtai ones.
This allows one to use both libraries at the same time.
The functions are exchangable, it is feasible to patch djb
libtai to use this set of functions provided by libc internally.
.Pp
A
.Vt tai64_t
value is, in contrast to
.Vt time_t ,
not zero-based, but has a bias of
.Dv __TAI64_BIAS ,
which is implementation-defined to 0x4000000000000000ULL for the
.Mx
operating system.
You will have to be extra carefully when adding values of type
.Vt tai64_t
or storing time values versus time distances in variables.
.Sh BUGS
The leap second table is read from the timezone information file.
This has implications on the location of the file and its up-to-dateness.
.Pp
There is no method to select POSIX-conformant behaviour.
It's probably better this way, though.
.Pp
Few sanitising of values is done, but the functions are considered safe.
