.\" $MirOS: src/lib/libc/locale/optu8to16.3,v 1.8 2017/04/24 12:52:51 tg Exp $
.\"-
.\" Copyright (c) 2008, 2010
.\"	Thorsten Glaser <tg@mirbsd.org>
.\"
.\" Provided that these terms and disclaimer and all copyright notices
.\" are retained or reproduced in an accompanying document, permission
.\" is granted to deal in this work without restriction, including un-
.\" limited rights to use, publicly perform, distribute, sell, modify,
.\" merge, give away, or sublicence.
.\"
.\" This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
.\" the utmost extent permitted by applicable law, neither express nor
.\" implied; without malicious intent or gross negligence. In no event
.\" may a licensor, author or contributor be held liable for indirect,
.\" direct, other damage, loss, or other issues arising in any way out
.\" of dealing in the work, even if advised of the possibility of such
.\" damage or existence of a defect, except proven that it results out
.\" of said person's immediate fault when using the work as intended.
.\"
.\" The author reserves the right to steward the OPTU encoding forms.
.\"-
.Dd $Mdocdate: April 24 2017 $
.Dt OPTU8TO16 3
.Os MirOS
.Sh NAME
.Nm optu8to16 ,
.Nm optu8to16vis
.Nd converts multibyte characters to wide characters preserving octets
.Sh SYNOPSIS
.Fd #include <wchar.h>
.Ft size_t
.Fn optu8to16 "wchar_t *pwc" "const char *s" "size_t n" "mbstate_t *ps"
.Ft size_t
.Fn optu8to16vis "wchar_t *pwc" "const char *s" "size_t n" "mbstate_t *ps"
/* deprecated */
.Sh DESCRIPTION
The
.Fn optu8to16
function usually converts the multibyte character pointed to by
.Fa s
to a wide character, and stores the wide character
in the wchar_t object pointed to by
.Fa pwc
if
.Fa pwc
is non-null and
.Fa s
points to a valid character in the CESU\-8 multibyte encoding, similar to
.Fn mbrtowc
in a UTF\-8 locale.
If
.Fa s
does not point to a valid character, the first octet is transliterated to
either an ISO_646.irv:1991 (ASCII) mapping into UCS\-2 (U+0000 .. U+007F),
or to the OPTU\-16 raw octet range (U+EF80 .. U+EFFF).
The
.Fn optu8to16vis
function behaves the same, except raw octets are mapped into the normal
UCS range as if they had been encoded in the legacy 8-bit codepage.
The conversion happens in accordance with the conversion state
described in the mbstate_t object pointed to by
.Fa ps ;
it should be noted that raw octet conversion is stateful.
This function may examine at most
.Fa n
bytes of the array beginning from
.Fa s .
If
.Fa n
is set to 0, the function behaves as if end of input (not a null character)
has been read and ignores
.Fa s .
.Pp
If
.Fa s
points to a valid character and the character corresponds to a null wide
character, then the function places the mbstate_t object pointed to by
.Fa ps
to an initial conversion state.
.Pp
These are the special cases:
.Bl -tag -width 0123456789012
.It "pwc == NULL"
The conversion from a multibyte character to a wide character has
taken place and the conversion state may be affected, but the resultant
wide character is discarded.
.It "s == NULL"
.Fn optu8to16
sets the conversion state object pointed to by
.Fa ps
to an initial state and always returns 0.
In this case,
.Fn optu8to16
ignores
.Fa pwc
.\" why does mdoc(7) not have something for strong boldness?
\fBbut not\fR
.Fa n ,
and is equivalent to the following call:
.Bd -literal -offset indent
optu8to16(NULL, "", 1, ps);
.Ed
.It "n == 0"
Read end of input (not a null character, but an epsilon as known from computer
science automaton modelling) and ignore
.Fa s .
.Fn optu8to16
will still emit up to two wide characters and return 0, if the conversion
state contains information about these, and (size_t)\-2 otherwise.
Application note:
If the end of input has been reached, call
.Fn optu8to16
with n == 0 until it returns (size_t)\-2, and process the remaining wide
characters emitted.
This ensures no raw octets in the OPTU\-8 encoded source are lost.
.It "ps == NULL"
.Fn optu8to16
uses its own internal state object to keep the conversion state, instead of
.Fa ps
mentioned in this manual page.
.Pp
Calling any other functions in
.Em libc
never change the internal state of
.Fn optu8to16 ,
which is initialised at programme startup time.
.El
.Sh RETURN VALUES
.Bl -tag -width 0123456789012
.It "0 or positive"
Number of bytes read from
.Fa s .
If 0, the state contained enough information to emit a wide character; if
positive, the bytes form a valid multibyte character in the OPTU\-8 encoding.
.It (size_t)\-2
.Fa s
points to the byte sequence which possibly contains part of a valid
multibyte character, but which is incomplete.
All
.Fa n
bytes of the input have been processed and stored in
.Fa ps .
.It (size_t)\-1
Generic error condition; should not happen in the current implementation.
.Va errno
is set to indicate the error.
.El
.Sh ERRORS
The
.Fn optu8to16
function is designed to be as robust as possible and can, in contrast to
.Fn mbrtowc ,
not throw
.Er EILSEQ .
While
.Er EINVAL
to indicate an invalid or uninitialised mbstate_t object is theoretically
possible, neither this nor other processing errors should ever happen with
the current implementaton.
.Sh SEE ALSO
.Xr iswoctet 3 ,
.Xr mbrtowc 3 ,
.Xr optu16to8 3
.Sh STANDARDS
At present,
.Mx
is limited to the UCS BMP (Basic Multilingual Plane), thus
OPTU\-8 is limited to the common subset of CESU\-8 and UTF\-8.
.Pp
The
.Fn optu16to8
and
.Fn optu8to16
functions are standardised by
.Mx
and have been designed to behave as close to their
.\".St -isoC99
ISO/IEC 9899:1999
.Pq Dq ISO C99
equivalents
.Fn wcrtombs
and
.Fn mbrtowcs
as possible, with the following intentional exceptions:
.Pp
If
.Fa n
is 0,
.Fa s
is ignored, even if it is
.Dv NULL ,
not the other way round.
The return value 0 does not indicate that a null character was processed, use
.Fa pwc
for that.
It indicates that no byte of the input has been read.
.Pp
The
.Fn optu8to16vis
function assumes codepage 1252 and maps holes into distinguishable codepoints.
.Pp
All these extended functions declare macros with the same name that can be
used to check for their presence.
.Sh HISTORY
The
.Nm
function first appeared in
.Mx 11 .
.Pp
Later attempts to tackle similar or related problems are PEP 383 (2009)
.Pa https://www.python.org/dev/peps/pep\-0383/
and the Wobbly Transformation Format (2014)
.Pa https://simonsapin.github.io/wtf\-8/
which all differ in which encoding is used for nonstandard codes.
.Pp
The range used in the OPTU encoding is registered with CSUR:
.Pa http://www.evertype.com/standards/csur/conscript\-table.html
.Sh AUTHORS
.An Thorsten Glaser Aq tg@mirbsd.de
wrote the entire internationalisation implementation in
.Mx .
He is also the steward for the OPTU encoding.
.Sh CAVEATS
On a system whose wide character type is only 16 bits wide, as opposed
to 31 bits of ISO 10646, the OPTU encoder and decoder are permitted to
not de- and recompose any surrogates encountered and pass them through
as if they were regular wide characters with no special function.
Since
.Mx
is such a system, the reference implementation does not care about
UTF\-16 surrogates posing as OPTU\-16 characters at all; a planes-aware
Universal Coded Character Set-using application is required to handle
surrogates by itself.
For compatibility purposes,
.Nm
should always be assumed to not treat surrogates specially; applications
.Em must
ensure to not produce invalid surrogates unless limited to the BMP.
