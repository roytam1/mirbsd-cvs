


TERMINFO(5)		   File Formats		      TERMINFO(5)



NNAAMMEE
     terminfo - terminal capability data base

SSYYNNOOPPSSIISS
     /usr/share/misc/terminfo.db
     /usr/share/terminfo/?/*

DDEESSCCRRIIPPTTIIOONN
     _T_e_r_m_i_n_f_o is a data base describing terminals, used by
     screen-oriented programs such as vvii(1), rroogguuee(1) and
     libraries such as ccuurrsseess(3).  _T_e_r_m_i_n_f_o describes terminals
     by giving a set of capabilities which they have, by specify-
     ing how to perform screen operations, and by specifying pad-
     ding requirements and initialization sequences.

     Entries in _t_e_r_m_i_n_f_o consist of a sequence of `,' separated
     fields (embedded commas may be escaped with a  backslash or
     notated as \072).	White space after the `,' separator is
     ignored.  The first entry for each terminal gives the names
     which are known for the terminal, separated by `|' charac-
     ters.  The first name given is the most common abbreviation
     for the terminal, the last name given should be a long name
     fully identifying the terminal, and all others are under-
     stood as synonyms for the terminal name.  All names but the
     last should be in lower case and contain no blanks; the last
     name may well contain upper case and blanks for readability.

     Terminal names (except for the last, verbose entry) should
     be chosen using the following conventions.	 The particular
     piece of hardware making up the terminal should have a root
     name, thus ``hp2621''.  This name should not contain
     hyphens.  Modes that the hardware can be in, or user prefer-
     ences, should be indicated by appending a hyphen and a mode
     suffix.  Thus, a vt100 in 132 column mode would be vt100-w.
     The following suffixes should be used where possible:

     SSuuffffiixx		     MMeeaanniinngg		       EExxaammppllee
     -_n_n      Number of lines on the screen	       aaa-60
     -_np      Number of pages of memory		       c100-4p
     -am      With automargins (usually the default)   vt100-am
     -m	      Mono mode; suppress color		       ansi-m
     -mc      Magic cookie; spaces when highlighting   wy30-mc
     -na      No arrow keys (leave them in local)      c100-na
     -nam     Without automatic margins		       vt100-nam
     -nl      No status line			       att4415-nl
     -ns      No status line			       hp2626-ns
     -rv      Reverse video			       c100-rv
     -s	      Enable status line		       vt100-s
     -vb      Use visible bell instead of beep	       wy370-vb
     -w	      Wide mode (> 80 columns, usually 132)    vt100-w





MirOS BSD #9-current	Printed 1.10.2006			1






TERMINFO(5)		   File Formats		      TERMINFO(5)



     For more on terminal naming conventions, see the tteerrmm((77))
     manual page.

     CCaappaabbiilliittiieess
     The following is a complete table of the capabilities
     included in a terminfo description block and available to
     terminfo-using code.  In each line of the table,

     The vvaarriiaabbllee is the name by which the programmer (at the
     terminfo level) accesses the capability.

     The ccaappnnaammee is the short name used in the text of the data-
     base, and is used by a person updating the database.  When-
     ever possible, capnames are chosen to be the same as or sim-
     ilar to the ANSI X3.64-1979 standard (now superseded by
     ECMA-48, which uses identical or very similar names).
     Semantics are also intended to match those of the specifica-
     tion.

     The termcap code is the old tteerrmmccaapp capability name (some
     capabilities are new, and have names which termcap did not
     originate).

     Capability names have no hard length limit, but an informal
     limit of 5 characters has been adopted to keep them short
     and to allow the tabs in the source file CCaappss to line up
     nicely.

     Finally, the description field attempts to convey the seman-
     tics of the capability.  You may find some codes in the
     description field:

     (P)  indicates that padding may be specified

     #[1-9]
	  in the description field indicates that the string is
	  passed through tparm with parms as given (#_i).

     (P*) indicates that padding may vary in proportion to the
	  number of lines affected

     (#_i) indicates the _ith parameter.


     These are the boolean capabilities:

	     VVaarriiaabbllee	       CCaapp--   TTCCaapp	 DDeessccrriippttiioonn
	     BBoooolleeaannss	       nnaammee   CCooddee
     auto_left_margin	       bw     bw     cub1 wraps from col-
					     umn 0 to last column





MirOS BSD #9-current	Printed 1.10.2006			2






TERMINFO(5)		   File Formats		      TERMINFO(5)



     auto_right_margin	       am     am     terminal has auto-
					     matic margins
     back_color_erase	       bce    ut     screen erased with
					     background color
     can_change		       ccc    cc     terminal can re-
					     define existing col-
					     ors
     ceol_standout_glitch      xhp    xs     standout not erased
					     by overwriting (hp)
     col_addr_glitch	       xhpa   YA     only positive motion
					     for hpa/mhpa caps
     cpi_changes_res	       cpix   YF     changing character
					     pitch changes reso-
					     lution
     cr_cancels_micro_mode     crxm   YB     using cr turns off
					     micro mode
     dest_tabs_magic_smso      xt     xt     tabs destructive,
					     magic so char
					     (t1061)
     eat_newline_glitch	       xenl   xn     newline ignored
					     after 80 cols (con-
					     cept)
     erase_overstrike	       eo     eo     can erase over-
					     strikes with a blank
     generic_type	       gn     gn     generic line type
     hard_copy		       hc     hc     hardcopy terminal
     hard_cursor	       chts   HC     cursor is hard to
					     see
     has_meta_key	       km     km     Has a meta key
					     (shift, sets parity
					     bit)
     has_print_wheel	       daisy  YC     printer needs opera-
					     tor to change char-
					     acter set
     has_status_line	       hs     hs     has extra status
					     line
     hue_lightness_saturation  hls    hl     terminal uses only
					     HLS color notation
					     (Tektronix)
     insert_null_glitch	       in     in     insert mode distin-
					     guishes nulls
     lpi_changes_res	       lpix   YG     changing line pitch
					     changes resolution
     memory_above	       da     da     display may be
					     retained above the
					     screen
     memory_below	       db     db     display may be
					     retained below the
					     screen
     move_insert_mode	       mir    mi     safe to move while
					     in insert mode




MirOS BSD #9-current	Printed 1.10.2006			3






TERMINFO(5)		   File Formats		      TERMINFO(5)



     move_standout_mode	       msgr   ms     safe to move while
					     in standout mode
     needs_xon_xoff	       nxon   nx     padding won't work,
					     xon/xoff required
     no_esc_ctlc	       xsb    xb     beehive (f1=escape,
					     f2=ctrl C)
     no_pad_char	       npc    NP     pad character does
					     not exist
     non_dest_scroll_region    ndscr  ND     scrolling region is
					     non-destructive
     non_rev_rmcup	       nrrmc  NR     smcup does not
					     reverse rmcup
     over_strike	       os     os     terminal can over-
					     strike
     prtr_silent	       mc5i   5i     printer won't echo
					     on screen
     row_addr_glitch	       xvpa   YD     only positive motion
					     for vpa/mvpa caps
     semi_auto_right_margin    sam    YE     printing in last
					     column causes cr
     status_line_esc_ok	       eslok  es     escape can be used
					     on the status line
     tilde_glitch	       hz     hz     can't print ~'s
					     (hazeltine)
     transparent_underline     ul     ul     underline character
					     overstrikes
     xon_xoff		       xon    xo     terminal uses
					     xon/xoff handshaking

     These are the numeric capabilities:

	  VVaarriiaabbllee	    CCaapp--     TTCCaapp	 DDeessccrriippttiioonn
	   NNuummeerriicc	    nnaammee     CCooddee
     columns		    cols     co	     number of columns in
					     a line
     init_tabs		    it	     it	     tabs initially every
					     # spaces
     label_height	    lh	     lh	     rows in each label
     label_width	    lw	     lw	     columns in each
					     label
     lines		    lines    li	     number of lines on
					     screen or page
     lines_of_memory	    lm	     lm	     lines of memory if >
					     line. 0 means varies
     magic_cookie_glitch    xmc	     sg	     number of blank
					     characters left by
					     smso or rmso
     max_attributes	    ma	     ma	     maximum combined
					     attributes terminal
					     can handle





MirOS BSD #9-current	Printed 1.10.2006			4






TERMINFO(5)		   File Formats		      TERMINFO(5)



     max_colors		    colors   Co	     maximum number of
					     colors on screen
     max_pairs		    pairs    pa	     maximum number of
					     color-pairs on the
					     screen
     maximum_windows	    wnum     MW	     maximum number of
					     defineable windows
     no_color_video	    ncv	     NC	     video attributes
					     that can't be used
					     with colors
     num_labels		    nlab     Nl	     number of labels on
					     screen
     padding_baud_rate	    pb	     pb	     lowest baud rate
					     where padding needed
     virtual_terminal	    vt	     vt	     virtual terminal
					     number (CB/unix)
     width_status_line	    wsl	     ws	     number of columns in
					     status line

     The following numeric capabilities are present in the SVr4.0
     term structure, but are not yet documented in the man  page.
     They came in with SVr4's printer support.

	   VVaarriiaabbllee	    CCaapp--     TTCCaapp	 DDeessccrriippttiioonn
	   NNuummeerriicc	    nnaammee     CCooddee
     bit_image_entwining    bitwin   Yo	     number of passes for
					     each bit-image row
     bit_image_type	    bitype   Yp	     type of bit-image
					     device
     buffer_capacity	    bufsz    Ya	     numbers of bytes
					     buffered before
					     printing
     buttons		    btns     BT	     number of buttons on
					     mouse
     dot_horz_spacing	    spinh    Yc	     spacing of dots hor-
					     izontally in dots
					     per inch
     dot_vert_spacing	    spinv    Yb	     spacing of pins ver-
					     tically in pins per
					     inch
     max_micro_address	    maddr    Yd	     maximum value in
					     micro_..._address
     max_micro_jump	    mjump    Ye	     maximum value in
					     parm_..._micro
     micro_col_size	    mcs	     Yf	     character step size
					     when in micro mode
     micro_line_size	    mls	     Yg	     line step size when
					     in micro mode
     number_of_pins	    npins    Yh	     numbers of pins in
					     print-head





MirOS BSD #9-current	Printed 1.10.2006			5






TERMINFO(5)		   File Formats		      TERMINFO(5)



     output_res_char	    orc	     Yi	     horizontal resolu-
					     tion in units per
					     line
     output_res_horz_inch   orhi     Yk	     horizontal resolu-
					     tion in units per
					     inch
     output_res_line	    orl	     Yj	     vertical resolution
					     in units per line
     output_res_vert_inch   orvi     Yl	     vertical resolution
					     in units per inch
     print_rate		    cps	     Ym	     print rate in char-
					     acters per second
     wide_char_size	    widcs    Yn	     character step size
					     when in double wide
					     mode

     These are the string capabilities:

	     VVaarriiaabbllee		CCaapp--   TTCCaapp	 DDeessccrriippttiioonn
	      SSttrriinngg		nnaammee   CCooddee
     acs_chars			acsc   ac    graphics charset
					     pairs, based on
					     vt100
     back_tab			cbt    bt    back tab (P)
     bell			bel    bl    audible signal
					     (bell) (P)
     carriage_return		cr     cr    carriage return (P*)
					     (P*)
     change_char_pitch		cpi    ZA    Change number of
					     characters per inch
     change_line_pitch		lpi    ZB    Change number of
					     lines per inch
     change_res_horz		chr    ZC    Change horizontal
					     resolution
     change_res_vert		cvr    ZD    Change vertical res-
					     olution
     change_scroll_region	csr    cs    change region to
					     line #1 to line #2
					     (P)
     char_padding		rmp    rP    like ip but when in
					     insert mode
     clear_all_tabs		tbc    ct    clear all tab stops
					     (P)
     clear_margins		mgc    MC    clear right and left
					     soft margins
     clear_screen		clear  cl    clear screen and
					     home cursor (P*)
     clr_bol			el1    cb    Clear to beginning
					     of line
     clr_eol			el     ce    clear to end of line
					     (P)




MirOS BSD #9-current	Printed 1.10.2006			6






TERMINFO(5)		   File Formats		      TERMINFO(5)



     clr_eos			ed     cd    clear to end of
					     screen (P*)
     column_address		hpa    ch    horizontal position
					     #1, absolute (P)
     command_character		cmdch  CC    terminal settable
					     cmd character in
					     prototype !?
     create_window		cwin   CW    define a window #1
					     from #2,#3 to #4,#5
     cursor_address		cup    cm    move to row #1 col-
					     umns #2
     cursor_down		cud1   do    down one line
     cursor_home		home   ho    home cursor (if no
					     cup)
     cursor_invisible		civis  vi    make cursor invisi-
					     ble
     cursor_left		cub1   le    move left one space
     cursor_mem_address		mrcup  CM    memory relative cur-
					     sor addressing
     cursor_normal		cnorm  ve    make cursor appear
					     normal (undo
					     civis/cvvis)
     cursor_right		cuf1   nd    non-destructive
					     space (move right
					     one space)
     cursor_to_ll		ll     ll    last line, first
					     column (if no cup)
     cursor_up			cuu1   up    up one line
     cursor_visible		cvvis  vs    make cursor very
					     visible
     define_char		defc   ZE    Define a character
     delete_character		dch1   dc    delete character
					     (P*)
     delete_line		dl1    dl    delete line (P*)
     dial_phone			dial   DI    dial number #1
     dis_status_line		dsl    ds    disable status line
     display_clock		dclk   DK    display clock at
					     (#1,#2)
     down_half_line		hd     hd    half a line down
     ena_acs			enacs  eA    enable alternate
					     char set
     enter_alt_charset_mode	smacs  as    start alternate
					     character set (P)
     enter_am_mode		smam   SA    turn on automatic
					     margins
     enter_blink_mode		blink  mb    turn on blinking
     enter_bold_mode		bold   md    turn on bold (extra
					     bright) mode
     enter_ca_mode		smcup  ti    string to start pro-
					     grams using cup
     enter_delete_mode		smdc   dm    enter delete mode




MirOS BSD #9-current	Printed 1.10.2006			7






TERMINFO(5)		   File Formats		      TERMINFO(5)



     enter_dim_mode		dim    mh    turn on half-bright
					     mode
     enter_doublewide_mode	swidm  ZF    Enter double-wide
					     mode
     enter_draft_quality	sdrfq  ZG    Enter draft-quality
					     mode
     enter_insert_mode		smir   im    enter insert mode
     enter_italics_mode		sitm   ZH    Enter italic mode
     enter_leftward_mode	slm    ZI    Start leftward car-
					     riage motion
     enter_micro_mode		smicm  ZJ    Start micro-motion
					     mode
     enter_near_letter_quality	snlq   ZK    Enter NLQ mode
     enter_normal_quality	snrmq  ZL    Enter normal-quality
					     mode
     enter_protected_mode	prot   mp    turn on protected
					     mode
     enter_reverse_mode		rev    mr    turn on reverse
					     video mode
     enter_secure_mode		invis  mk    turn on blank mode
					     (characters invisi-
					     ble)
     enter_shadow_mode		sshm   ZM    Enter shadow-print
					     mode
     enter_standout_mode	smso   so    begin standout mode
     enter_subscript_mode	ssubm  ZN    Enter subscript mode
     enter_superscript_mode	ssupm  ZO    Enter superscript
					     mode
     enter_underline_mode	smul   us    begin underline mode
     enter_upward_mode		sum    ZP    Start upward car-
					     riage motion
     enter_xon_mode		smxon  SX    turn on xon/xoff
					     handshaking
     erase_chars		ech    ec    erase #1 characters
					     (P)
     exit_alt_charset_mode	rmacs  ae    end alternate char-
					     acter set (P)
     exit_am_mode		rmam   RA    turn off automatic
					     margins
     exit_attribute_mode	sgr0   me    turn off all
					     attributes
     exit_ca_mode		rmcup  te    strings to end pro-
					     grams using cup
     exit_delete_mode		rmdc   ed    end delete mode
     exit_doublewide_mode	rwidm  ZQ    End double-wide mode
     exit_insert_mode		rmir   ei    exit insert mode
     exit_italics_mode		ritm   ZR    End italic mode
     exit_leftward_mode		rlm    ZS    End left-motion mode
     exit_micro_mode		rmicm  ZT    End micro-motion
					     mode





MirOS BSD #9-current	Printed 1.10.2006			8






TERMINFO(5)		   File Formats		      TERMINFO(5)



     exit_shadow_mode		rshm   ZU    End shadow-print
					     mode
     exit_standout_mode		rmso   se    exit standout mode
     exit_subscript_mode	rsubm  ZV    End subscript mode
     exit_superscript_mode	rsupm  ZW    End superscript mode
     exit_underline_mode	rmul   ue    exit underline mode
     exit_upward_mode		rum    ZX    End reverse charac-
					     ter motion
     exit_xon_mode		rmxon  RX    turn off xon/xoff
					     handshaking
     fixed_pause		pause  PA    pause for 2-3 sec-
					     onds
     flash_hook			hook   fh    flash switch hook
     flash_screen		flash  vb    visible bell (may
					     not move cursor)
     form_feed			ff     ff    hardcopy terminal
					     page eject (P*)
     from_status_line		fsl    fs    return from status
					     line
     goto_window		wingo  WG    go to window #1
     hangup			hup    HU    hang-up phone
     init_1string		is1    i1    initialization
					     string
     init_2string		is2    is    initialization
					     string
     init_3string		is3    i3    initialization
					     string
     init_file			if     if    name of initializa-
					     tion file
     init_prog			iprog  iP    path name of program
					     for initialization
     initialize_color		initc  Ic    initialize color #1
					     to (#2,#3,#4)
     initialize_pair		initp  Ip    Initialize color
					     pair #1 to
					     fg=(#2,#3,#4),
					     bg=(#5,#6,#7)
     insert_character		ich1   ic    insert character (P)
     insert_line		il1    al    insert line (P*)
     insert_padding		ip     ip    insert padding after
					     inserted character
     key_a1			ka1    K1    upper left of keypad
     key_a3			ka3    K3    upper right of key-
					     pad
     key_b2			kb2    K2    center of keypad
     key_backspace		kbs    kb    backspace key
     key_beg			kbeg   @1    begin key
     key_btab			kcbt   kB    back-tab key
     key_c1			kc1    K4    lower left of keypad
     key_c3			kc3    K5    lower right of key-
					     pad




MirOS BSD #9-current	Printed 1.10.2006			9






TERMINFO(5)		   File Formats		      TERMINFO(5)



     key_cancel			kcan   @2    cancel key
     key_catab			ktbc   ka    clear-all-tabs key
     key_clear			kclr   kC    clear-screen or
					     erase key
     key_close			kclo   @3    close key
     key_command		kcmd   @4    command key
     key_copy			kcpy   @5    copy key
     key_create			kcrt   @6    create key
     key_ctab			kctab  kt    clear-tab key
     key_dc			kdch1  kD    delete-character key
     key_dl			kdl1   kL    delete-line key
     key_down			kcud1  kd    down-arrow key
     key_eic			krmir  kM    sent by rmir or smir
					     in insert mode
     key_end			kend   @7    end key
     key_enter			kent   @8    enter/send key
     key_eol			kel    kE    clear-to-end-of-line
					     key
     key_eos			ked    kS    clear-to-end-of-
					     screen key
     key_exit			kext   @9    exit key
     key_f0			kf0    k0    F0 function key
     key_f1			kf1    k1    F1 function key
     key_f10			kf10   k;    F10 function key
     key_f11			kf11   F1    F11 function key
     key_f12			kf12   F2    F12 function key
     key_f13			kf13   F3    F13 function key
     key_f14			kf14   F4    F14 function key
     key_f15			kf15   F5    F15 function key
     key_f16			kf16   F6    F16 function key
     key_f17			kf17   F7    F17 function key
     key_f18			kf18   F8    F18 function key
     key_f19			kf19   F9    F19 function key
     key_f2			kf2    k2    F2 function key
     key_f20			kf20   FA    F20 function key
     key_f21			kf21   FB    F21 function key
     key_f22			kf22   FC    F22 function key
     key_f23			kf23   FD    F23 function key
     key_f24			kf24   FE    F24 function key
     key_f25			kf25   FF    F25 function key
     key_f26			kf26   FG    F26 function key
     key_f27			kf27   FH    F27 function key
     key_f28			kf28   FI    F28 function key
     key_f29			kf29   FJ    F29 function key
     key_f3			kf3    k3    F3 function key
     key_f30			kf30   FK    F30 function key
     key_f31			kf31   FL    F31 function key
     key_f32			kf32   FM    F32 function key
     key_f33			kf33   FN    F33 function key
     key_f34			kf34   FO    F34 function key
     key_f35			kf35   FP    F35 function key




MirOS BSD #9-current	Printed 1.10.2006		       10






TERMINFO(5)		   File Formats		      TERMINFO(5)



     key_f36			kf36   FQ    F36 function key
     key_f37			kf37   FR    F37 function key
     key_f38			kf38   FS    F38 function key
     key_f39			kf39   FT    F39 function key
     key_f4			kf4    k4    F4 function key
     key_f40			kf40   FU    F40 function key
     key_f41			kf41   FV    F41 function key
     key_f42			kf42   FW    F42 function key
     key_f43			kf43   FX    F43 function key
     key_f44			kf44   FY    F44 function key
     key_f45			kf45   FZ    F45 function key
     key_f46			kf46   Fa    F46 function key
     key_f47			kf47   Fb    F47 function key
     key_f48			kf48   Fc    F48 function key
     key_f49			kf49   Fd    F49 function key
     key_f5			kf5    k5    F5 function key
     key_f50			kf50   Fe    F50 function key
     key_f51			kf51   Ff    F51 function key
     key_f52			kf52   Fg    F52 function key
     key_f53			kf53   Fh    F53 function key
     key_f54			kf54   Fi    F54 function key
     key_f55			kf55   Fj    F55 function key
     key_f56			kf56   Fk    F56 function key
     key_f57			kf57   Fl    F57 function key
     key_f58			kf58   Fm    F58 function key
     key_f59			kf59   Fn    F59 function key
     key_f6			kf6    k6    F6 function key
     key_f60			kf60   Fo    F60 function key
     key_f61			kf61   Fp    F61 function key
     key_f62			kf62   Fq    F62 function key
     key_f63			kf63   Fr    F63 function key
     key_f7			kf7    k7    F7 function key
     key_f8			kf8    k8    F8 function key
     key_f9			kf9    k9    F9 function key
     key_find			kfnd   @0    find key
     key_help			khlp   %1    help key
     key_home			khome  kh    home key
     key_ic			kich1  kI    insert-character key
     key_il			kil1   kA    insert-line key
     key_left			kcub1  kl    left-arrow key
     key_ll			kll    kH    lower-left key (home
					     down)
     key_mark			kmrk   %2    mark key
     key_message		kmsg   %3    message key
     key_move			kmov   %4    move key
     key_next			knxt   %5    next key
     key_npage			knp    kN    next-page key
     key_open			kopn   %6    open key
     key_options		kopt   %7    options key
     key_ppage			kpp    kP    previous-page key
     key_previous		kprv   %8    previous key




MirOS BSD #9-current	Printed 1.10.2006		       11






TERMINFO(5)		   File Formats		      TERMINFO(5)



     key_print			kprt   %9    print key
     key_redo			krdo   %0    redo key
     key_reference		kref   &1    reference key
     key_refresh		krfr   &2    refresh key
     key_replace		krpl   &3    replace key
     key_restart		krst   &4    restart key
     key_resume			kres   &5    resume key
     key_right			kcuf1  kr    right-arrow key
     key_save			ksav   &6    save key
     key_sbeg			kBEG   &9    shifted begin key
     key_scancel		kCAN   &0    shifted cancel key
     key_scommand		kCMD   *1    shifted command key
     key_scopy			kCPY   *2    shifted copy key
     key_screate		kCRT   *3    shifted create key
     key_sdc			kDC    *4    shifted delete-char-
					     acter key
     key_sdl			kDL    *5    shifted delete-line
					     key
     key_select			kslt   *6    select key
     key_send			kEND   *7    shifted end key
     key_seol			kEOL   *8    shifted clear-to-
					     end-of-line key
     key_sexit			kEXT   *9    shifted exit key
     key_sf			kind   kF    scroll-forward key
     key_sfind			kFND   *0    shifted find key
     key_shelp			kHLP   #1    shifted help key
     key_shome			kHOM   #2    shifted home key
     key_sic			kIC    #3    shifted insert-char-
					     acter key
     key_sleft			kLFT   #4    shifted left-arrow
					     key
     key_smessage		kMSG   %a    shifted message key
     key_smove			kMOV   %b    shifted move key
     key_snext			kNXT   %c    shifted next key
     key_soptions		kOPT   %d    shifted options key
     key_sprevious		kPRV   %e    shifted previous key
     key_sprint			kPRT   %f    shifted print key
     key_sr			kri    kR    scroll-backward key
     key_sredo			kRDO   %g    shifted redo key
     key_sreplace		kRPL   %h    shifted replace key
     key_sright			kRIT   %i    shifted right-arrow
					     key
     key_srsume			kRES   %j    shifted resume key
     key_ssave			kSAV   !1    shifted save key
     key_ssuspend		kSPD   !2    shifted suspend key
     key_stab			khts   kT    set-tab key
     key_sundo			kUND   !3    shifted undo key
     key_suspend		kspd   &7    suspend key
     key_undo			kund   &8    undo key
     key_up			kcuu1  ku    up-arrow key





MirOS BSD #9-current	Printed 1.10.2006		       12






TERMINFO(5)		   File Formats		      TERMINFO(5)



     keypad_local		rmkx   ke    leave 'key-
					     board_transmit' mode
     keypad_xmit		smkx   ks    enter 'key-
					     board_transmit' mode
     lab_f0			lf0    l0    label on function
					     key f0 if not f0
     lab_f1			lf1    l1    label on function
					     key f1 if not f1
     lab_f10			lf10   la    label on function
					     key f10 if not f10
     lab_f2			lf2    l2    label on function
					     key f2 if not f2
     lab_f3			lf3    l3    label on function
					     key f3 if not f3
     lab_f4			lf4    l4    label on function
					     key f4 if not f4
     lab_f5			lf5    l5    label on function
					     key f5 if not f5
     lab_f6			lf6    l6    label on function
					     key f6 if not f6
     lab_f7			lf7    l7    label on function
					     key f7 if not f7
     lab_f8			lf8    l8    label on function
					     key f8 if not f8
     lab_f9			lf9    l9    label on function
					     key f9 if not f9
     label_format		fln    Lf    label format
     label_off			rmln   LF    turn off soft labels
     label_on			smln   LO    turn on soft labels
     meta_off			rmm    mo    turn off meta mode
     meta_on			smm    mm    turn on meta mode
					     (8th-bit on)
     micro_column_address	mhpa   ZY    Like column_address
					     in micro mode
     micro_down			mcud1  ZZ    Like cursor_down in
					     micro mode
     micro_left			mcub1  Za    Like cursor_left in
					     micro mode
     micro_right		mcuf1  Zb    Like cursor_right in
					     micro mode
     micro_row_address		mvpa   Zc    Like row_address in
					     micro mode
     micro_up			mcuu1  Zd    Like cursor_up in
					     micro mode
     newline			nel    nw    newline (behave like
					     cr followed by lf)
     order_of_pins		porder Ze    Match software bits
					     to print-head pins
     orig_colors		oc     oc    Set all color pairs
					     to the original ones





MirOS BSD #9-current	Printed 1.10.2006		       13






TERMINFO(5)		   File Formats		      TERMINFO(5)



     orig_pair			op     op    Set default pair to
					     its original value
     pad_char			pad    pc    padding char
					     (instead of null)
     parm_dch			dch    DC    delete #1 characters
					     (P*)
     parm_delete_line		dl     DL    delete #1 lines (P*)
     parm_down_cursor		cud    DO    down #1 lines (P*)
     parm_down_micro		mcud   Zf    Like parm_down_cur-
					     sor in micro mode
     parm_ich			ich    IC    insert #1 characters
					     (P*)
     parm_index			indn   SF    scroll forward #1
					     lines (P)
     parm_insert_line		il     AL    insert #1 lines (P*)
     parm_left_cursor		cub    LE    move #1 characters
					     to the left (P)
     parm_left_micro		mcub   Zg    Like parm_left_cur-
					     sor in micro mode
     parm_right_cursor		cuf    RI    move #1 characters
					     to the right (P*)
     parm_right_micro		mcuf   Zh    Like parm_right_cur-
					     sor in micro mode
     parm_rindex		rin    SR    scroll back #1 lines
					     (P)
     parm_up_cursor		cuu    UP    up #1 lines (P*)
     parm_up_micro		mcuu   Zi    Like parm_up_cursor
					     in micro mode
     pkey_key			pfkey  pk    program function key
					     #1 to type string #2
     pkey_local			pfloc  pl    program function key
					     #1 to execute string
					     #2
     pkey_xmit			pfx    px    program function key
					     #1 to transmit
					     string #2
     plab_norm			pln    pn    program label #1 to
					     show string #2
     print_screen		mc0    ps    print contents of
					     screen
     prtr_non			mc5p   pO    turn on printer for
					     #1 bytes
     prtr_off			mc4    pf    turn off printer
     prtr_on			mc5    po    turn on printer
     pulse			pulse  PU    select pulse dialing
     quick_dial			qdial  QD    dial number #1 with-
					     out checking
     remove_clock		rmclk  RC    remove clock
     repeat_char		rep    rp    repeat char #1 #2
					     times (P*)





MirOS BSD #9-current	Printed 1.10.2006		       14






TERMINFO(5)		   File Formats		      TERMINFO(5)



     req_for_input		rfi    RF    send next input char
					     (for ptys)
     reset_1string		rs1    r1    reset string
     reset_2string		rs2    r2    reset string
     reset_3string		rs3    r3    reset string
     reset_file			rf     rf    name of reset file
     restore_cursor		rc     rc    restore cursor to
					     position of last
					     save_cursor
     row_address		vpa    cv    vertical position #1
					     absolute (P)
     save_cursor		sc     sc    save current cursor
					     position (P)
     scroll_forward		ind    sf    scroll text up (P)
     scroll_reverse		ri     sr    scroll text down (P)
     select_char_set		scs    Zj    Select character set
     set_attributes		sgr    sa    define video
					     attributes #1-#9
					     (PG9)
     set_background		setb   Sb    Set background color
					     #1
     set_bottom_margin		smgb   Zk    Set bottom margin at
					     current line
     set_bottom_margin_parm	smgbp  Zl    Set bottom margin at
					     line #1 or #2 lines
					     from bottom
     set_clock			sclk   SC    set clock, #1 hrs #2
					     mins #3 secs
     set_color_pair		scp    sp    Set current color
					     pair to #1
     set_foreground		setf   Sf    Set foreground color
					     #1
     set_left_margin		smgl   ML    set left soft margin
					     at current column
     set_left_margin_parm	smglp  Zm    Set left (right)
					     margin at column #1
					     (#2)
     set_right_margin		smgr   MR    set right soft mar-
					     gin at current col-
					     umn
     set_right_margin_parm	smgrp  Zn    Set right margin at
					     column #1
     set_tab			hts    st    set a tab in every
					     row, current columns
     set_top_margin		smgt   Zo    Set top margin at
					     current line
     set_top_margin_parm	smgtp  Zp    Set top (bottom)
					     margin at row #1
					     (#2)






MirOS BSD #9-current	Printed 1.10.2006		       15






TERMINFO(5)		   File Formats		      TERMINFO(5)



     set_window			wind   wi    current window is
					     lines #1-#2 cols
					     #3-#4
     start_bit_image		sbim   Zq    Start printing bit
					     image graphics
     start_char_set_def		scsd   Zr    Start character set
					     definition
     stop_bit_image		rbim   Zs    Stop printing bit
					     image graphics
     stop_char_set_def		rcsd   Zt    End definition of
					     character set
     subscript_characters	subcs  Zu    List of subscript-
					     able characters
     superscript_characters	supcs  Zv    List of superscript-
					     able characters
     tab			ht     ta    tab to next 8-space
					     hardware tab stop
     these_cause_cr		docr   Zw    Printing any of
					     these characters
					     causes CR
     to_status_line		tsl    ts    move to status line
     tone			tone   TO    select touch tone
					     dialing
     underline_char		uc     uc    underline char and
					     move past it
     up_half_line		hu     hu    half a line up
     user0			u0     u0    User string #0
     user1			u1     u1    User string #1
     user2			u2     u2    User string #2
     user3			u3     u3    User string #3
     user4			u4     u4    User string #4
     user5			u5     u5    User string #5
     user6			u6     u6    User string #6
     user7			u7     u7    User string #7
     user8			u8     u8    User string #8
     user9			u9     u9    User string #9
     wait_tone			wait   WA    wait for dial-tone
     xoff_character		xoffc  XF    XOFF character
     xon_character		xonc   XN    XON character
     zero_motion		zerom  Zx    No motion for subse-
					     quent character

     The  following string capabilities are present in the SVr4.0
     term structure, but were originally not  documented  in  the
     man page.

	     VVaarriiaabbllee		CCaapp--	 TTCCaapp	  DDeessccrriippttiioonn
	      SSttrriinngg		nnaammee	 CCooddee
     alt_scancode_esc		scesa	 S8    Alternate escape
					       for scancode emu-
					       lation




MirOS BSD #9-current	Printed 1.10.2006		       16






TERMINFO(5)		   File Formats		      TERMINFO(5)



     bit_image_carriage_return	bicr	 Yv    Move to beginning
					       of same row
     bit_image_newline		binel	 Zz    Move to next row
					       of the bit image
     bit_image_repeat		birep	 Xy    Repeat bit image
					       cell #1 #2 times
     char_set_names		csnm	 Zy    List of character
					       set names
     code_set_init		csin	 ci    Init sequence for
					       multiple codesets
     color_names		colornm	 Yw    Give name for
					       color #1
     define_bit_image_region	defbi	 Yx    Define rectan-
					       gualar bit image
					       region
     device_type		devt	 dv    Indicate lan-
					       guage/codeset sup-
					       port
     display_pc_char		dispc	 S1    Display PC charac-
					       ter
     end_bit_image_region	endbi	 Yy    End a bit-image
					       region
     enter_pc_charset_mode	smpch	 S2    Enter PC character
					       display mode
     enter_scancode_mode	smsc	 S4    Enter PC scancode
					       mode
     exit_pc_charset_mode	rmpch	 S3    Exit PC character
					       display mode
     exit_scancode_mode		rmsc	 S5    Exit PC scancode
					       mode
     get_mouse			getm	 Gm    Curses should get
					       button events
     key_mouse			kmous	 Km    Mouse event has
					       occurred
     mouse_info			minfo	 Mi    Mouse status
					       information
     pc_term_options		pctrm	 S6    PC terminal
					       options
     pkey_plab			pfxl	 xl    Program function
					       key #1 to type
					       string #2 and show
					       string #3
     req_mouse_pos		reqmp	 RQ    Request mouse
					       position
     scancode_escape		scesc	 S7    Escape for scan-
					       code emulation
     set0_des_seq		s0ds	 s0    Shift to code set
					       0 (EUC set 0,
					       ASCII)
     set1_des_seq		s1ds	 s1    Shift to code set
					       1




MirOS BSD #9-current	Printed 1.10.2006		       17






TERMINFO(5)		   File Formats		      TERMINFO(5)



     set2_des_seq		s2ds	 s2    Shift to code set
					       2
     set3_des_seq		s3ds	 s3    Shift to code set
					       3
     set_a_background		setab	 AB    Set background
					       color using ANSI
					       escape
     set_a_foreground		setaf	 AF    Set foreground
					       color using ANSI
					       escape
     set_color_band		setcolor Yz    Change to ribbon
					       color #1
     set_lr_margin		smglr	 ML    Set both left and
					       right margins to
					       #1, #2
     set_page_length		slines	 YZ    Set page length to
					       #1 lines
     set_tb_margin		smgtb	 MT    Sets both top and
					       bottom margins to
					       #1, #2

	The  XSI  Curses  standard  added  these.   They are some
	post-4.1 versions of System V curses, e.g.,  Solaris  2.5
	and  IRIX  6.x.	  The  nnccuurrsseess termcap names for them are
	invented; according to the XSI Curses standard, they have
	no  termcap names.  If your compiled terminfo entries use
	these, they may not be binary-compatible  with	System	V
	terminfo entries after SVr4.1; beware!

		VVaarriiaabbllee	 CCaapp--	TTCCaapp	 DDeessccrriippttiioonn
		 SSttrriinngg		 nnaammee	CCooddee
	enter_horizontal_hl_mode ehhlm	Xh   Enter horizontal
					     highlight mode
	enter_left_hl_mode	 elhlm	Xl   Enter left highlight
					     mode
	enter_low_hl_mode	 elohlm Xo   Enter low highlight
					     mode
	enter_right_hl_mode	 erhlm	Xr   Enter right high-
					     light mode
	enter_top_hl_mode	 ethlm	Xt   Enter top highlight
					     mode
	enter_vertical_hl_mode	 evhlm	Xv   Enter vertical high-
					     light mode
	set_a_attributes	 sgr1	sA   Define second set of
					     video attributes
					     #1-#6
	set_pglen_inch		 slengthsL   YI Set page length
					     to #1 hundredth of
					     an inch

     AA SSaammppllee EEnnttrryy




MirOS BSD #9-current	Printed 1.10.2006		       18






TERMINFO(5)		   File Formats		      TERMINFO(5)



     The  following  entry, describing an ANSI-standard terminal,
     is representative of what a tteerrmmiinnffoo entry for a modern ter-
     minal typically looks like.

   ansi|ansi/pc-term compatible with color,
	   mc5i,
	   colors#8, ncv#3, pairs#64,
	   cub=\E[%p1%dD, cud=\E[%p1%dB, cuf=\E[%p1%dC,
	   cuu=\E[%p1%dA, dch=\E[%p1%dP, dl=\E[%p1%dM,
	   ech=\E[%p1%dX, el1=\E[1K, hpa=\E[%p1%dG, ht=\E[I,
	   ich=\E[%p1%d@, il=\E[%p1%dL, indn=\E[%p1%dS, .indn=\E[%p1%dT,
	   kbs=^H, kcbt=\E[Z, kcub1=\E[D, kcud1=\E[B,
	   kcuf1=\E[C, kcuu1=\E[A, kf1=\E[M, kf10=\E[V,
	   kf11=\E[W, kf12=\E[X, kf2=\E[N, kf3=\E[O, kf4=\E[P,
	   kf5=\E[Q, kf6=\E[R, kf7=\E[S, kf8=\E[T, kf9=\E[U,
	   kich1=\E[L, mc4=\E[4i, mc5=\E[5i, nel=\r\E[S,
	   op=\E[37;40m, rep=%p1%c\E[%p2%{1}%-%db,
	   rin=\E[%p1%dT, s0ds=\E(B, s1ds=\E)B, s2ds=\E*B,
	   s3ds=\E+B, setab=\E[4%p1%dm, setaf=\E[3%p1%dm,
	   setb=\E[4%?%p1%{1}%=%t4%e%p1%{3}%=%t6%e%p1%{4}%=%t1%e%p1%{6}%=%t3%e%p1%d%;m,
	   setf=\E[3%?%p1%{1}%=%t4%e%p1%{3}%=%t6%e%p1%{4}%=%t1%e%p1%{6}%=%t3%e%p1%d%;m,
	   sgr=\E[0;10%?%p1%t;7%;%?%p2%t;4%;%?%p3%t;7%;%?%p4%t;5%;%?%p6%t;1%;%?%p7%t;8%;%?%p8%t;11%;%?%p9%t;12%;m,
	   sgr0=\E[0;10m, tbc=\E[2g, u6=\E[%d;%dR, u7=\E[6n,
	   u8=\E[?%[;0123456789]c, u9=\E[c, vpa=\E[%p1%dd,

     Entries  may  continue  onto multiple lines by placing white
     space at the beginning of each line except the first.   Com-
     ments  may be included on lines beginning with ``#''.  Capa-
     bilities in _t_e_r_m_i_n_f_o are of three types:  Boolean	capabili-
     ties  which  indicate  that the terminal has some particular
     feature, numeric capabilities giving the size of the  termi-
     nal  or  the size of particular delays, and string capabili-
     ties, which give a sequence which can  be	used  to  perform
     particular terminal operations.

     TTyyppeess ooff CCaappaabbiilliittiieess

     All  capabilities	have  names.  For instance, the fact that
     ANSI-standard terminals have  _a_u_t_o_m_a_t_i_c  _m_a_r_g_i_n_s  (i.e.,  an
     automatic	return	and  line-feed	when the end of a line is
     reached) is indicated  by	the  capability	 aamm.   Hence  the
     description  of  ansi includes aamm.	 Numeric capabilities are
     followed by the character `#' and	then  a	 positive  value.
     Thus  ccoollss, which indicates the number of columns the termi-
     nal has, gives the value `80' for ansi.  Values for  numeric
     capabilities may be specified in decimal, octal or hexadeci-
     mal, using the C  programming  language  conventions  (e.g.,
     255, 0377 and 0xff or 0xFF).

     Finally,  string  valued  capabilities, such as eell (clear to
     end of line sequence) are given by the  two-character  code,
     an	 `=', and then a string ending at the next following `,'.



MirOS BSD #9-current	Printed 1.10.2006		       19






TERMINFO(5)		   File Formats		      TERMINFO(5)



     A number of escape sequences are provided in the string val-
     ued  capabilities	for  easy  encoding  of characters there.
     Both \\EE and \\ee map to an ESCAPE character, ^^xx maps to a con-
     trol-x  for any appropriate x, and the sequences \\nn \\ll \\rr \\tt
     \\bb \\ff \\ss give a newline, line-feed, return, tab,  backspace,
     form-feed,	 and  space.   Other escapes include \\^^ for ^^, \\\\
     for \\, \\, for comma, \\:: for ::, and \\00 for	null.	(\\00  will
     produce  \200, which does not terminate a string but behaves
     as a null character on  most  terminals,  providing  CS7  is
     specified.	  See stty(1).)	 Finally, characters may be given
     as three octal digits after a \\.

     A delay in milliseconds may  appear  anywhere  in	a  string
     capability,  enclosed  in	$<..> brackets, as in eell=\EK$<5>,
     and padding characters are supplied by _t_p_u_t_s to provide this
     delay.   The delay must be a number with at most one decimal
     place of precision; it may be followed by	suffixes  `*'  or
     '/'  or  both.  A `*' indicates that the padding required is
     proportional to the number of lines affected by  the  opera-
     tion,  and the amount given is the per-affected-unit padding
     required.	(In the case of insert character, the  factor  is
     still  the	 number of _l_i_n_e_s affected.)  Normally, padding is
     advisory if the device has the xxoonn capability;  it	 is  used
     for  cost	computation  but  does not trigger delays.  A `/'
     suffix indicates that the padding is mandatory and forces	a
     delay  of	the  given number of milliseconds even on devices
     for which xxoonn is present to indicate flow control.

     Sometimes individual capabilities must be commented out.  To
     do this, put a period before the capability name.	For exam-
     ple, see the second iinndd in the example above.

     FFeettcchhiinngg CCoommppiilleedd DDeessccrriippttiioonnss

     If the environment variable TERMINFO is set,  it  is  inter-
     preted  as	 the  pathname of a directory containing the com-
     piled description you are working on.  Only  that	directory
     is searched.

     If	 TERMINFO is not set, the nnccuurrsseess version of the terminfo
     reader code will instead look in the  directory  $$HHOOMMEE//..tteerr--
     mmiinnffoo  for	 a compiled description.  If it fails to find one
     there, and the environment variable TERMINFO_DIRS is set, it
     will  interpret  the  contents of that variable as a list of
     colon- separated directories to be searched (an empty  entry
     is	 interpreted  as a command to search _/_u_s_r_/_s_h_a_r_e_/_m_i_s_c_/_t_e_r_-
     _m_i_n_f_o).  If no description is  found  in  any  of	the  TER-
     MINFO_DIRS directories, the fetch fails.

     If neither TERMINFO nor TERMINFO_DIRS is set, the last place
     tried   will   be	  the	 system	   terminfo    directory,
     _/_u_s_r_/_s_h_a_r_e_/_m_i_s_c_/_t_e_r_m_i_n_f_o.



MirOS BSD #9-current	Printed 1.10.2006		       20






TERMINFO(5)		   File Formats		      TERMINFO(5)



     (Neither	the  $$HHOOMMEE//..tteerrmmiinnffoo  lookups  nor  TERMINFO_DIRS
     extensions	 are  supported	 under	stock	System	 V   ter-
     minfo/curses.)

     PPrreeppaarriinngg DDeessccrriippttiioonnss

     We	 now  outline  how  to prepare descriptions of terminals.
     The most effective way to prepare a terminal description  is
     by	 imitating  the description of a similar terminal in _t_e_r_-
     _m_i_n_f_o and to build up a description gradually, using partial
     descriptions  with	 _v_i or some other screen-oriented program
     to check that they	 are  correct.	 Be  aware  that  a  very
     unusual  terminal	may expose deficiencies in the ability of
     the _t_e_r_m_i_n_f_o file to describe it or bugs in the  screen-han-
     dling code of the test program.

     To	 get  the  padding for insert line right (if the terminal
     manufacturer did not document it) a severe test is to edit a
     large file at 9600 baud, delete 16 or so lines from the mid-
     dle of the screen,	 then  hit  the	 `u'  key  several  times
     quickly.  If the terminal messes up, more padding is usually
     needed.  A similar test can be used for insert character.

     BBaassiicc CCaappaabbiilliittiieess

     The number of columns on each line for the terminal is given
     by	 the  ccoollss numeric capability.	If the terminal is a CRT,
     then the number of lines on the screen is given by the lliinneess
     capability.   If  the terminal wraps around to the beginning
     of the next line when it reaches the right margin,	 then  it
     should  have  the	aamm capability.	If the terminal can clear
     its screen, leaving the cursor in the  home  position,  then
     this is given by the cclleeaarr string capability.  If the termi-
     nal overstrikes (rather than  clearing  a	position  when	a
     character	is  struck over) then it should have the ooss capa-
     bility.  If the terminal is a  printing  terminal,	 with  no
     soft  copy	 unit,	give  it  both hhcc and ooss.  (ooss applies to
     storage scope terminals, such as TEKTRONIX 4010  series,  as
     well as hard copy and APL terminals.)  If there is a code to
     move the cursor to the left edge of the  current  row,  give
     this as ccrr.  (Normally this will be carriage return, control
     M.)  If there is a code to produce an audible signal  (bell,
     beep, etc) give this as bbeell.

     If	 there	is  a code to move the cursor one position to the
     left (such as backspace) that capability should be given  as
     ccuubb11.   Similarly,	 codes to move to the right, up, and down
     should be given as ccuuff11, ccuuuu11, and ccuudd11.  These local cursor
     motions  should not alter the text they pass over, for exam-
     ple, you would not normally use `ccuuff11= ' because  the  space
     would erase the character moved over.




MirOS BSD #9-current	Printed 1.10.2006		       21






TERMINFO(5)		   File Formats		      TERMINFO(5)



     A very important point here is that the local cursor motions
     encoded in _t_e_r_m_i_n_f_o are undefined at the left and top  edges
     of	 a  CRT	 terminal.   Programs  should  never  attempt  to
     backspace around the left edge,  unless  bbww  is  given,  and
     never  attempt  to	 go  up locally off the top.  In order to
     scroll text up, a program will go to the bottom left  corner
     of the screen and send the iinndd (index) string.

     To	 scroll	 text down, a program goes to the top left corner
     of the screen and sends the rrii (reverse index) string.   The
     strings  iinndd  and rrii are undefined when not on their respec-
     tive corners of the screen.

     Parameterized versions of the scrolling sequences	are  iinnddnn
     and  rriinn  which have the same semantics as iinndd and rrii except
     that they take one parameter, and scroll  that  many  lines.
     They  are	also  undefined except at the appropriate edge of
     the screen.

     The aamm capability tells whether the  cursor  sticks  at  the
     right  edge of the screen when text is output, but this does
     not necessarily apply to a ccuuff11 from the last  column.   The
     only  local motion which is defined from the left edge is if
     bbww is given, then a ccuubb11 from the left edge will move to the
     right  edge  of  the  previous row.  If bbww is not given, the
     effect is undefined.  This	 is  useful  for  drawing  a  box
     around the edge of the screen, for example.  If the terminal
     has switch selectable automatic margins, the  _t_e_r_m_i_n_f_o  file
     usually  assumes that this is on; i.e., aamm.  If the terminal
     has a command which moves to the first column  of	the  next
     line,  that  command can be given as nneell (newline).  It does
     not matter if the command clears the remainder of	the  cur-
     rent  line, so if the terminal has no ccrr and llff it may still
     be possible to craft a working nneell out of	one  or	 both  of
     them.

     These capabilities suffice to describe hard-copy and "glass-
     tty" terminals.  Thus the model 33 teletype is described as

     33|tty33|tty|model 33 teletype,
     bel=^G, cols#72, cr=^M, cud1=^J, hc, ind=^J, os,

     while the Lear Siegler ADM-3 is described as

     adm3|3|lsi adm3,
     am, bel=^G, clear=^Z, cols#80, cr=^M, cub1=^H, cud1=^J,
     ind=^J, lines#24,

     PPaarraammeetteerriizzeedd SSttrriinnggss

     Cursor addressing and other strings requiring parameters  in
     the   terminal  are  described  by	 a  parameterized  string



MirOS BSD #9-current	Printed 1.10.2006		       22






TERMINFO(5)		   File Formats		      TERMINFO(5)



     capability, with _p_r_i_n_t_f(3 like escapes %%xx in it.  For  exam-
     ple,  to  address	the  cursor, the ccuupp capability is given,
     using two parameters: the row  and	 column	 to  address  to.
     (Rows  and	 columns  are numbered from zero and refer to the
     physical screen visible to the user, not to any unseen  mem-
     ory.)   If	 the terminal has memory relative cursor address-
     ing, that can be indicated by mmrrccuupp.

     The parameter mechanism uses a stack and special %% codes  to
     manipulate	 it.   Typically  a sequence will push one of the
     parameters onto the stack and then print it in some  format.
     Often more complex operations are necessary.

     The %% encodings have the following meanings:

	  %%	    outputs `%'
	  %_[_[:_]_f_l_a_g_s_]_[_w_i_d_t_h_[_._p_r_e_c_i_s_i_o_n_]_]_[doxXs_]
		    as in pprriinnttff, flags are [-+#] and space
	  %c	    print pop() like %c in printf()
	  %s	    print pop() like %s in printf()

	  %p[1-9]   push _i'th parm
	  %P[a-z]   set dynamic variable [a-z] to pop()
	  %g[a-z]   get dynamic variable [a-z] and push it
	  %P[A-Z]   set static variable [a-z] to pop()
	  %g[A-Z]   get static variable [a-z] and push it
	  %'_c'	    char constant _c
	  %{_n_n}	    integer constant _n_n
	  %l	    push strlen(pop)

	  %+ %- %* %/ %m
		    arithmetic (%m is mod): push(pop() op pop())
	  %& %| %^  bit operations: push(pop() op pop())
	  %= %> %<  logical operations: push(pop() op pop())
	  %A, %O    logical and & or operations (for conditionals)
	  %! %~	    unary operations push(op pop())
	  %i	    add 1 to first two parameters (for ANSI terminals)

	  %? expr %t thenpart %e elsepart %;
		    if-then-else, %e elsepart is optional.
		    else-if's are possible a la Algol 68:
		    %? c1 %t b1 %e c2 %t b2 %e c3 %t b3 %e c4 %t b4 %e %;
		    ci are conditions, bi are bodies.

     Binary  operations	 are in postfix form with the operands in
     the usual	order.	 That  is,  to	get  x-5  one  would  use
     "%gx%{5}%-".   %P	and  %g	 variables  are persistent across
     escape-string evaluations.

     Consider the HP2645, which, to get to row 3 and  column  12,
     needs to be sent \E&a12c03Y padded for 6 milliseconds.  Note
     that the order of the rows and columns is inverted here, and



MirOS BSD #9-current	Printed 1.10.2006		       23






TERMINFO(5)		   File Formats		      TERMINFO(5)



     that the row and column are printed as two digits.	 Thus its
     ccuupp capability is "cup=6\E&%p2%2dc%p1%2dY".

     The Microterm ACT-IV needs the current row and  column  sent
     preceded  by a ^^TT, with the row and column simply encoded in
     binary, "cup=^T%p1%c%p2%c".  Terminals which use  "%c"  need
     to	 be  able to backspace the cursor (ccuubb11), and to move the
     cursor up one line on the screen (ccuuuu11).  This is	necessary
     because  it  is not always safe to transmit \\nn ^^DD and \\rr, as
     the system may change or discard them.   (The  library  rou-
     tines  dealing  with terminfo set tty modes so that tabs are
     never expanded, so \t is safe to send.  This turns out to be
     essential for the Ann Arbor 4080.)

     A final example is the LSI ADM-3a, which uses row and column
     offset by a blank character, thus	"cup=\E=%p1%'  '%+%c%p2%'
     '%+%c".   After sending `\E=', this pushes the first parame-
     ter, pushes the ASCII value for  a	 space	(32),  adds  them
     (pushing  the  sum on the stack in place of the two previous
     values) and outputs that value as	a  character.	Then  the
     same  is done for the second parameter.  More complex arith-
     metic is possible using the stack.

     CCuurrssoorr MMoottiioonnss

     If the terminal has a fast way to home the cursor	(to  very
     upper left corner of screen) then this can be given as hhoommee;
     similarly a fast way of getting to the lower left-hand  cor-
     ner  can be given as llll; this may involve going up with ccuuuu11
     from the home position, but a program should never	 do  this
     itself  (unless  llll  does) because it can make no assumption
     about the effect of moving up from the home position.   Note
     that  the	home position is the same as addressing to (0,0):
     to the top left corner of the screen, not of memory.  (Thus,
     the \EH sequence on HP terminals cannot be used for hhoommee.)

     If	 the  terminal has row or column absolute cursor address-
     ing, these can be given as single parameter capabilities hhppaa
     (horizontal  position  absolute)  and vvppaa (vertical position
     absolute).	 Sometimes these are shorter than the  more  gen-
     eral  two parameter sequence (as with the hp2645) and can be
     used in preference to ccuupp.	 If there are parameterized local
     motions  (e.g.,  move  _n  spaces  to the right) these can be
     given as ccuudd, ccuubb, ccuuff, and  ccuuuu  with  a	single	parameter
     indicating	 how  many  spaces  to move.  These are primarily
     useful if the terminal does not have ccuupp, such as	the  TEK-
     TRONIX 4025.

     If the terminal needs to be in a special mode when running a
     program that uses these capabilities, the codes to enter and
     exit  this	 mode  can  be	given  as  ssmmccuupp and rrmmccuupp.  This
     arises, for example, from terminals like  the  Concept  with



MirOS BSD #9-current	Printed 1.10.2006		       24






TERMINFO(5)		   File Formats		      TERMINFO(5)



     more than one page of memory.  If the terminal has only mem-
     ory relative cursor addressing and not screen relative  cur-
     sor addressing, a one screen-sized window must be fixed into
     the terminal for cursor addressing to work	 properly.   This
     is	 also  used  for the TEKTRONIX 4025, where ssmmccuupp sets the
     command character to be the one used by  terminfo.	  If  the
     ssmmccuupp  sequence  will  not restore the screen after an rrmmccuupp
     sequence is output (to the state prior to outputting rrmmccuupp),
     specify nnrrrrmmcc.

     AArreeaa CClleeaarrss

     If	 the  terminal can clear from the current position to the
     end of the line, leaving the cursor where it is, this should
     be	 given	as eell.	If the terminal can clear from the begin-
     ning of the line to the current position inclusive,  leaving
     the cursor where it is, this should be given as eell11.  If the
     terminal can clear from the current position to the  end  of
     the  display,  then  this should be given as eedd.  EEdd is only
     defined from the first column of a line.  (Thus, it  can  be
     simulated by a request to delete a large number of lines, if
     a true eedd is not available.)

     IInnsseerrtt//ddeelleettee lliinnee aanndd vveerrttiiccaall mmoottiioonnss

     If the terminal can open a new blank line	before	the  line
     where  the	 cursor	 is, this should be given as iill11; this is
     done only from the first position of  a  line.   The  cursor
     must  then	 appear on the newly blank line.  If the terminal
     can delete the line which the cursor is on, then this should
     be	 given	as ddll11; this is done only from the first position
     on the line to be deleted.	 Versions of iill11  and  ddll11  which
     take a single parameter and insert or delete that many lines
     can be given as iill and ddll.

     If the terminal has a settable scrolling  region  (like  the
     vt100) the command to set this can be described with the ccssrr
     capability, which takes two parameters: the top  and  bottom
     lines  of	the  scrolling	region.	  The cursor position is,
     alas, undefined after using this command.

     It is possible to get the effect of insert	 or  delete  line
     using  ccssrr	 on a properly chosen region; the sscc and rrcc (save
     and restore cursor) commands may be useful for ensuring that
     your synthesized insert/delete string does not move the cur-
     sor.  (Note that the nnccuurrsseess(3) library does this	synthesis
     automatically, so you need not compose insert/delete strings
     for an entry with ccssrr).

     Yet another way to construct insert and delete might  be  to
     use  a  combination  of  index  with the memory-lock feature
     found on some terminals (like the	HP-700/90  series,  which



MirOS BSD #9-current	Printed 1.10.2006		       25






TERMINFO(5)		   File Formats		      TERMINFO(5)



     however also has insert/delete).

     Inserting	lines at the top or bottom of the screen can also
     be done using rrii or iinndd on many  terminals	 without  a  true
     insert/delete  line,  and	is often faster even on terminals
     with those features.

     The boolean nnoonn__ddeesstt__ssccrroollll__rreeggiioonn should	be  set	 if  each
     scrolling	window	is  effectively	 a view port on a screen-
     sized  canvas.   To  test	for  this  capability,	create	a
     scrolling	region	in  the middle of the screen, write some-
     thing to the bottom line, move the cursor to the top of  the
     region,  and  do  rrii  followed  by	 ddll11 or iinndd.  If the data
     scrolled off the bottom of the region by the rrii  re-appears,
     then  scrolling is non-destructive.  System V and XSI Curses
     expect that iinndd, rrii, iinnddnn, and rriinn will simulate destructive
     scrolling;	 their	documentation  cautions you not to define
     ccssrr unless this is true.  This ccuurrsseess implementation is more
     liberal and will do explicit erases after scrolling if nnddssttrr
     is defined.

     If the terminal has the ability to define a window	 as  part
     of	 memory, which all commands affect, it should be given as
     the parameterized string wwiinndd.  The four parameters are  the
     starting  and  ending  lines  in memory and the starting and
     ending columns in memory, in that order.

     If the terminal can retain display memory above, then the ddaa
     capability	 should	 be  given;  if	 display  memory  can  be
     retained below, then ddbb should  be	 given.	  These	 indicate
     that  deleting a line or scrolling may bring non-blank lines
     up from below or that scrolling back with rrii may bring  down
     non-blank lines.

     IInnsseerrtt//DDeelleettee CChhaarraacctteerr

     There  are	 two  basic  kinds  of intelligent terminals with
     respect to insert/delete character which  can  be	described
     using  _t_e_r_m_i_n_f_o_.	The  most  common insert/delete character
     operations affect only the characters on  the  current  line
     and shift characters off the end of the line rigidly.  Other
     terminals, such as the Concept 100 and the Perkin Elmer Owl,
     make  a  distinction between typed and untyped blanks on the
     screen, shifting upon an insert or delete only to an untyped
     blank  on the screen which is either eliminated, or expanded
     to two untyped blanks.  You can determine the kind of termi-
     nal  you  have  by	 clearing the screen and then typing text
     separated by cursor motions.  Type "abc	def" using  local
     cursor motions (not spaces) between the "abc" and the "def".
     Then position the cursor before the "abc" and put the termi-
     nal in insert mode.  If typing characters causes the rest of
     the line to shift rigidly and characters  to  fall	 off  the



MirOS BSD #9-current	Printed 1.10.2006		       26






TERMINFO(5)		   File Formats		      TERMINFO(5)



     end,  then your terminal does not distinguish between blanks
     and untyped positions.  If the  "abc"  shifts  over  to  the
     "def" which then move together around the end of the current
     line and onto the next as you insert, you	have  the  second
     type  of  terminal, and should give the capability iinn, which
     stands for "insert null".	While  these  are  two	logically
     separate  attributes  (one	 line vs. multi-line insert mode,
     and special treatment of untyped spaces)  we  have	 seen  no
     terminals	whose  insert  mode  cannot be described with the
     single attribute.

     Terminfo can describe both terminals which	 have  an  insert
     mode,  and	 terminals which send a simple sequence to open a
     blank position on	the  current  line.   Give  as	ssmmiirr  the
     sequence to get into insert mode.	Give as rrmmiirr the sequence
     to leave insert mode.  Now give as iicchh11 any sequence  needed
     to be sent just before sending the character to be inserted.
     Most terminals with a true insert mode will not  give  iicchh11;
     terminals	which  send  a sequence to open a screen position
     should give it here.

     If your terminal has both, insert mode is usually preferable
     to	 iicchh11.	 Technically, you should not give both unless the
     terminal actually requires both to be used	 in  combination.
     Accordingly,  some	 non-curses  applications get confused if
     both are present; the symptom is doubled  characters  in  an
     update using insert.  This requirement is now rare; most iicchh
     sequences do not require previous smir, and most smir insert
     modes do not require iicchh11 before each character.  Therefore,
     the new ccuurrsseess actually assumes this is the  case	and  uses
     either  rrmmiirr/ssmmiirr or iicchh/iicchh11 as appropriate (but not both).
     If you have to write an entry to be used  under  new  curses
     for  a  terminal  old  enough  to	need  both,  include  the
     rrmmiirr/ssmmiirr sequences in iicchh11.

     If post insert padding is needed, give this as a  number  of
     milliseconds  in  iipp  (a string option).  Any other sequence
     which may need to be sent after an insert of a single  char-
     acter  may also be given in iipp.  If your terminal needs both
     to be placed into an `insert mode' and  a	special	 code  to
     precede  each  inserted  character,  then both ssmmiirr/rrmmiirr and
     iicchh11 can be given, and both will be used.	The iicchh	 capabil-
     ity,  with one parameter, _n, will repeat the effects of iicchh11
     _n times.

     If padding is necessary between characters typed  while  not
     in	 insert	 mode, give this as a number of milliseconds pad-
     ding in rrmmpp.

     It is occasionally necessary to move around while in  insert
     mode  to  delete characters on the same line (e.g., if there
     is a tab after the insertion position).   If  your	 terminal



MirOS BSD #9-current	Printed 1.10.2006		       27






TERMINFO(5)		   File Formats		      TERMINFO(5)



     allows motion while in insert mode you can give the capabil-
     ity mmiirr to speed up inserting in this  case.   Omitting  mmiirr
     will  affect  only	 speed.	  Some terminals (notably Datame-
     dia's) must not have mmiirr because of  the  way  their  insert
     mode works.

     Finally,  you can specify ddcchh11 to delete a single character,
     ddcchh with one parameter,  _n,  to  delete  _n	 _c_h_a_r_a_c_t_e_r_s_,  and
     delete mode by giving ssmmddcc and rrmmddcc to enter and exit delete
     mode (any mode the terminal needs to be placed in	for  ddcchh11
     to work).

     A	command to erase _n characters (equivalent to outputting _n
     blanks without moving the cursor) can be given as	eecchh  with
     one parameter.

     HHiigghhlliigghhttiinngg,, UUnnddeerrlliinniinngg,, aanndd VViissiibbllee BBeellllss

     If	  your	 terminal  has	one  or	 more  kinds  of  display
     attributes, these can be represented in a number of  differ-
     ent  ways.	  You  should choose one display form as _s_t_a_n_d_o_u_t
     _m_o_d_e, representing a good, high contrast,	easy-on-the-eyes,
     format  for  highlighting error messages and other attention
     getters.  (If you have a choice, reverse  video  plus  half-
     bright  is	 good, or reverse video alone.)	 The sequences to
     enter and exit standout mode are given  as	 ssmmssoo  and  rrmmssoo,
     respectively.  If the code to change into or out of standout
     mode leaves one or even two blank spaces on the  screen,  as
     the TVI 912 and Teleray 1061 do, then xxmmcc should be given to
     tell how many spaces are left.

     Codes to begin underlining and end underlining can be  given
     as	 ssmmuull  and rrmmuull respectively.  If the terminal has a code
     to underline the current character and move the  cursor  one
     space  to the right, such as the Microterm Mime, this can be
     given as uucc.

     Other  capabilities  to  enter  various  highlighting  modes
     include  bblliinnkk  (blinking)	 bboolldd  (bold or extra bright) ddiimm
     (dim or half-bright) iinnvviiss (blanking or invisible text) pprroott
     (protected) rreevv (reverse video) ssggrr00 (turn off _a_l_l attribute
     modes) ssmmaaccss (enter alternate character set mode) and  rrmmaaccss
     (exit  alternate  character  set  mode).	Turning on any of
     these modes singly may or may not turn off other modes.

     If there is a sequence  to	 set  arbitrary	 combinations  of
     modes,  this should be given as ssggrr (set attributes), taking
     9 parameters.  Each parameter is either 0 or nonzero, as the
     corresponding attribute is on or off.  The 9 parameters are,
     in order: standout, underline, reverse,  blink,  dim,  bold,
     blank, protect, alternate character set.  Not all modes need
     be supported by ssggrr,  only	 those	for  which  corresponding



MirOS BSD #9-current	Printed 1.10.2006		       28






TERMINFO(5)		   File Formats		      TERMINFO(5)



     separate attribute commands exist.

     For example, the DEC vt220 supports most of the modes:

	  ttppaarrmm ppaarraammeetteerr   aattttrriibbuuttee	 eessccaappee sseeqquueennccee

	  none		    none	 \E[0m
	  p1		    standout	 \E[0;1;7m
	  p2		    underline	 \E[0;4m
	  p3		    reverse	 \E[0;7m
	  p4		    blink	 \E[0;5m
	  p5		    dim		 not available
	  p6		    bold	 \E[0;1m
	  p7		    invis	 \E[0;8m
	  p8		    protect	 not used
	  p9		    altcharset	 ^O (off) ^N (on)

     We	 begin	each  escape sequence by turning off any existing
     modes, since there is no quick way to determine whether they
     are  active.   Standout  is  set up to be the combination of
     reverse and bold.	The vt220 terminal has	a  protect  mode,
     though  it	 is  not commonly used in sgr because it protects
     characters on the screen  from  the  host's  erasures.   The
     altcharset mode also is different in that it is either ^O or
     ^N, depending on whether it is off or on.	If all modes  are
     turned on, the resulting sequence is \E[0;1;4;5;7;8m^N.

     Some  sequences are common to different modes.  For example,
     ;7 is output when either p1 or  p3	 is  true,  that  is,  if
     either standout or reverse modes are turned on.

     Writing  out the above sequences, along with their dependen-
     cies yields

	sseeqquueennccee    wwhheenn ttoo oouuttppuutt     tteerrmmiinnffoo ttrraannssllaattiioonn

	\E[0	   always	       \E[0
	;1	   if p1 or p6	       %?%p1%p6%|%t;1%;
	;4	   if p2	       %?%p2%|%t;4%;
	;5	   if p4	       %?%p4%|%t;5%;
	;7	   if p1 or p3	       %?%p1%p3%|%t;7%;
	;8	   if p7	       %?%p7%|%t;8%;
	m	   always	       m
	^N or ^O   if p9 ^N, else ^O   %?%p9%t^N%e^O%;

     Putting this all together into the sgr sequence gives:

	 sgr=\E[0%?%p1%p6%|%t;1%;%?%p2%t;4%;%?%p1%p3%|%t;7%;
	     %?%p4%t;5%;%?%p7%t;8%;m%?%p9%t\016%e\017%;,

     Remember that if you specify  sgr,	 you  must  also  specify
     sgr0.



MirOS BSD #9-current	Printed 1.10.2006		       29






TERMINFO(5)		   File Formats		      TERMINFO(5)



     Terminals	with  the  ``magic  cookie'' glitch (xxmmcc) deposit
     special   ``cookies''   when   they   receive   mode-setting
     sequences,	 which	affect	the display algorithm rather than
     having extra bits for each character.  Some terminals,  such
     as	 the HP 2621, automatically leave standout mode when they
     move to a new line or the	cursor	is  addressed.	 Programs
     using  standout mode should exit standout mode before moving
     the cursor or sending a newline, unless the mmssggrr capability,
     asserting	that  it  is  safe  to	move in standout mode, is
     present.

     If the terminal has a way of flashing the screen to indicate
     an error quietly (a bell replacement) then this can be given
     as ffllaasshh; it must not move the cursor.

     If the cursor needs to be made more visible than normal when
     it	 is  not on the bottom line (to make, for example, a non-
     blinking underline into an easier to find block or	 blinking
     underline)	 give  this sequence as ccvvvviiss.	If there is a way
     to make the cursor completely invisible, give that as cciivviiss.
     The  capability  ccnnoorrmm  should  be	 given	which  undoes the
     effects of both of these modes.

     If your terminal correctly generates  underlined  characters
     (with no special codes needed) even though it does not over-
     strike, then you should give the capability uull.  If a  char-
     acter  overstriking  another  leaves  both characters on the
     screen, specify  the  capability  ooss.   If	 overstrikes  are
     erasable with a blank, then this should be indicated by giv-
     ing eeoo.

     KKeeyyppaadd aanndd FFuunnccttiioonn KKeeyyss

     If the terminal has a keypad that transmits codes	when  the
     keys  are	pressed, this information can be given. Note that
     it is not possible to handle terminals where the keypad only
     works  in local (this applies, for example, to the unshifted
     HP 2621 keys).  If the keypad can be set to transmit or  not
     transmit,	give these codes as ssmmkkxx and rrmmkkxx.  Otherwise the
     keypad is assumed to always transmit.  The codes sent by the
     left arrow, right arrow, up arrow, down arrow, and home keys
     can be given  as  kkccuubb11,,  kkccuuff11,,  kkccuuuu11,,  kkccuudd11,,  and  kkhhoommee
     respectively.   If	 there	are function keys such as f0, f1,
     ..., f10, the codes they send can be given as kkff00,, kkff11,, ......,,
     kkff1100.   If	 these keys have labels other than the default f0
     through f10, the labels can be given as llff00,, llff11,, ......,, llff1100.
     The  codes	 transmitted by certain other special keys can be
     given: kkllll (home down), kkbbss  (backspace),	kkttbbcc  (clear  all
     tabs),  kkccttaabb  (clear  the	 tab  stop  in this column), kkccllrr
     (clear screen or erase key), kkddcchh11 (delete character),  kkddll11
     (delete  line),  kkrrmmiirr (exit insert mode), kkeell (clear to end
     of line), kkeedd  (clear  to	end  of	 screen),  kkiicchh11  (insert



MirOS BSD #9-current	Printed 1.10.2006		       30






TERMINFO(5)		   File Formats		      TERMINFO(5)



     character	or  enter  insert  mode), kkiill11 (insert line), kknnpp
     (next  page),  kkpppp	 (previous  page),  kkiinndd   (scroll   for-
     ward/down),  kkrrii  (scroll backward/up), kkhhttss (set a tab stop
     in this column).  In addition, if the keypad has a	 3  by	3
     array  of keys including the four arrow keys, the other five
     keys can be given as kkaa11, kkaa33, kkbb22,  kkcc11,	and  kkcc33.   These
     keys are useful when the effects of a 3 by 3 directional pad
     are needed.

     Strings to program function keys  can  be	given  as  ppffkkeeyy,
     ppfflloocc, and ppffxx.  A string to program screen labels should be
     specified as ppllnn.	Each of these strings takes  two  parame-
     ters:  the function key number to program (from 0 to 10) and
     the string to program it with.  Function key numbers out  of
     this  range  may program undefined keys in a terminal depen-
     dent manner.  The difference  between  the	 capabilities  is
     that  ppffkkeeyy  causes pressing the given key to be the same as
     the user typing the given string; ppfflloocc causes the string to
     be	 executed  by  the  terminal in local; and ppffxx causes the
     string to be transmitted to the computer.

     The capabilities nnllaabb, llww and llhh define the number	 of  pro-
     grammable	screen	labels	and  their  width and height.  If
     there are commands to turn the labels on and off, give  them
     in ssmmllnn and rrmmllnn.	ssmmllnn is normally output after one or more
     pln sequences to make sure that the change becomes	 visible.

     TTaabbss aanndd IInniittiiaalliizzaattiioonn

     If the terminal has hardware tabs, the command to advance to
     the next tab stop can be given as hhtt (usually control I).	A
     ``back-tab''  command  which moves leftward to the preceding
     tab stop can be given as ccbbtt.  By convention, if  the  tele-
     type modes indicate that tabs are being expanded by the com-
     puter rather than	being  sent  to	 the  terminal,	 programs
     should not use hhtt or ccbbtt even if they are present, since the
     user may not have the tab stops properly set.  If the termi-
     nal has hardware tabs which are initially set every _n spaces
     when the terminal is powered up, the numeric parameter iitt is
     given,  showing  the  number  of spaces the tabs are set to.
     This is normally used  by	the  _t_s_e_t  command  to	determine
     whether  to  set  the  mode  for hardware tab expansion, and
     whether to set the tab stops.  If the terminal has tab stops
     that  can	be  saved  in  non-volatile  memory, the terminfo
     description can assume that they are properly set.

     Other capabilities include iiss11, iiss22, and iiss33, initialization
     strings  for the terminal, iipprroogg, the path name of a program
     to be run to initialize the terminal, and iiff, the name of	a
     file  containing long initialization strings.  These strings
     are expected to set the terminal into modes consistent  with
     the  rest	of  the	 terminfo description.	They are normally



MirOS BSD #9-current	Printed 1.10.2006		       31






TERMINFO(5)		   File Formats		      TERMINFO(5)



     sent to the terminal, by the _i_n_i_t option of  the  _t_p_u_t  pro-
     gram,  each  time the user logs in.  They will be printed in
     the following order: run the program iipprroogg; output iiss11; iiss22;
     set the margins using mmggcc, ssmmggll and ssmmggrr; set tabs using ttbbcc
     and hhttss; print the file iiff; and finally output iiss33.

     Most initialization is  done  with	 iiss22.	Special	 terminal
     modes  can	 be set up without duplicating strings by putting
     the common sequences in iiss22 and special  cases  in	 iiss11  and
     iiss33.   A  pair  of sequences that does a harder reset from a
     totally unknown state can be analogously given as rrss11,  rrss22,
     rrff,  and  rrss33,  analogous	to iiss22 and iiff.	These strings are
     output by the _r_e_s_e_t program, which is used when the terminal
     gets  into	 a wedged state.  Commands are normally placed in
     rrss11, rrss22 rrss33 and rrff only if they produce annoying effects on
     the screen and are not necessary when logging in.	For exam-
     ple, the command to set the vt100 into 80-column mode  would
     normally be part of iiss22, but it causes an annoying glitch of
     the screen and is not normally needed since the terminal  is
     usually already in 80 column mode.

     If	 there	are commands to set and clear tab stops, they can
     be given as ttbbcc (clear all tab stops) and	hhttss  (set  a  tab
     stop in the current column of every row).	If a more complex
     sequence is needed to set the tabs than can be described  by
     this, the sequence can be placed in iiss22 or iiff.

     DDeellaayyss aanndd PPaaddddiinngg

     Many   older  and	slower	terminals  don't  support  either
     XON/XOFF or DTR handshaking, including hard  copy	terminals
     and  some	very  archaic  CRTs  (including, for example, DEC
     VT100s).  These may require padding characters after certain
     cursor motions and screen changes.

     If	 the  terminal uses xon/xoff handshaking for flow control
     (that is, it automatically emits ^S back to  the  host  when
     its  input	 buffers are close to full), set xxoonn.  This capa-
     bility suppresses the emission of padding.	 You can also set
     it	 for memory-mapped console devices effectively that don't
     have a speed limit.  Padding  information	should	still  be
     included  so  that	 routines can make better decisions about
     relative costs, but actual pad characters will not be trans-
     mitted.

     If ppbb (padding baud rate) is given, padding is suppressed at
     baud rates below the value of ppbb.	If the entry has no  pad-
     ding  baud	 rate,	then whether padding is emitted or not is
     completely controlled by xxoonn.

     If the terminal requires other than a null (zero)	character
     as	 a  pad,  then	this can be given as ppaadd.  Only the first



MirOS BSD #9-current	Printed 1.10.2006		       32






TERMINFO(5)		   File Formats		      TERMINFO(5)



     character of the ppaadd string is used.

     SSttaattuuss LLiinneess
     Some terminals have an extra `status line' which is not nor-
     mally  used  by software (and thus not counted in the termi-
     nal's lliinneess capability).

     The simplest case is a status line which is  cursor-address-
     able  but	not  part  of  the  main  scrolling region on the
     screen; the Heathkit H19 has a status line of this kind,  as
     would a 24-line VT100 with a 23-line scrolling region set up
     on initialization.	 This situation is indicated  by  the  hhss
     capability.

     Some  terminals  with status lines need special sequences to
     access the status line.  These may be expressed as a  string
     with  single parameter ttssll which takes the cursor to a given
     zero-origin column on the status line.  The  capability  ffssll
     must  return  to the main-screen cursor positions before the
     last ttssll.	You may need to embed the  string  values  of  sscc
     (save  cursor)  and  rrcc  (restore	cursor) in ttssll and ffssll to
     accomplish this.

     The status line is normally assumed to be the same width  as
     the width of the terminal.	 If this is untrue, you can spec-
     ify it with the numeric capability wwssll.

     A command to erase or blank the status line may be specified
     as ddssll.

     The   boolean   capability	  eessllookk	  specifies  that  escape
     sequences, tabs, etc. work ordinarily in the status line.

     The nnccuurrsseess implementation does not yet  use  any	of  these
     capabilities.   They  are	documented here in case they ever
     become important.

     LLiinnee GGrraapphhiiccss

     Many terminals have  alternate  character	sets  useful  for
     forms-drawing.  Terminfo and ccuurrsseess build in support for the
     drawing characters supported by the VT100, with some charac-
     ters  from	 the AT&T 4410v1 added.	 This alternate character
     set may be specified by the aaccsscc capability.

	      GGllyypphh		 AACCSS		 AAsscciiii	    VVTT110000
	       NNaammee		 NNaammee		 DDeeffaauulltt    NNaammee
     UK pound sign		 ACS_STERLING	 f	    }
     arrow pointing down	 ACS_DARROW	 v	    .
     arrow pointing left	 ACS_LARROW	 <	    ,
     arrow pointing right	 ACS_RARROW	 >	    +




MirOS BSD #9-current	Printed 1.10.2006		       33






TERMINFO(5)		   File Formats		      TERMINFO(5)



     arrow pointing up		 ACS_UARROW	 ^	    -
     board of squares		 ACS_BOARD	 #	    h
     bullet			 ACS_BULLET	 o	    ~
     checker board (stipple)	 ACS_CKBOARD	 :	    a
     degree symbol		 ACS_DEGREE	 \	    f
     diamond			 ACS_DIAMOND	 +	    `
     greater-than-or-equal-to	 ACS_GEQUAL	 >	    z
     greek pi			 ACS_PI		 *	    {
     horizontal line		 ACS_HLINE	 -	    q
     lantern symbol		 ACS_LANTERN	 #	    i
     large plus or crossover	 ACS_PLUS	 +	    n
     less-than-or-equal-to	 ACS_LEQUAL	 <	    y
     lower left corner		 ACS_LLCORNER	 +	    m
     lower right corner		 ACS_LRCORNER	 +	    j
     not-equal			 ACS_NEQUAL	 !	    |
     plus/minus			 ACS_PLMINUS	 #	    g
     scan line 1		 ACS_S1		 ~	    o
     scan line 3		 ACS_S3		 -	    p
     scan line 7		 ACS_S7		 -	    r
     scan line 9		 ACS_S9		 _	    s
     solid square block		 ACS_BLOCK	 #	    0
     tee pointing down		 ACS_TTEE	 +	    w
     tee pointing left		 ACS_RTEE	 +	    u
     tee pointing right		 ACS_LTEE	 +	    t
     tee pointing up		 ACS_BTEE	 +	    v
     upper left corner		 ACS_ULCORNER	 +	    l
     upper right corner		 ACS_URCORNER	 +	    k
     vertical line		 ACS_VLINE	 |	    x

     The best way to define a new device's graphics set is to add
     a	column	to a copy of this table for your terminal, giving
     the  character  which  (when  emitted  between   ssmmaaccss/rrmmaaccss
     switches)	will  be  rendered  as the corresponding graphic.
     Then read off the VT100/your terminal character pairs  right
     to left in sequence; these become the ACSC string.

     CCoolloorr HHaannddlliinngg

     Most  color  terminals  are  either `Tektronix-like' or `HP-
     like'.  Tektronix-like terminals have a predefined set of	N
     colors (where N usually 8), and can set character-cell fore-
     ground and background characters independently, mixing  them
     into  N * N color-pairs.  On HP-like terminals, the use must
     set each color pair up separately (foreground and background
     are not independently settable).  Up to M color-pairs may be
     set up from 2*M different colors.	ANSI-compatible terminals
     are Tektronix-like.

     Some  basic  color capabilities are independent of the color
     method.  The numeric capabilities ccoolloorrss and  ppaaiirrss  specify
     the  maximum  numbers  of colors and color-pairs that can be
     displayed simultaneously.	The  oopp	 (original  pair)  string



MirOS BSD #9-current	Printed 1.10.2006		       34






TERMINFO(5)		   File Formats		      TERMINFO(5)



     resets  foreground	 and  background  colors to their default
     values for the terminal.  The oocc string resets all colors or
     color-pairs  to their default values for the terminal.  Some
     terminals	(including  many  PC  terminal	emulators)  erase
     screen  areas  with the current background color rather than
     the power-up  default  background;	 these	should	have  the
     boolean capability bbccee.

     To	 change	 the  current foreground or background color on a
     Tektronix-type terminal, use sseettaaff (set ANSI foreground) and
     sseettaabb  (set  ANSI	background)  or sseettff (set foreground) and
     sseettbb (set background).  These take one parameter, the  color
     number.   The SVr4 documentation describes only sseettaaff/sseettaabb;
     the XPG4 draft says that  "If  the	 terminal  supports  ANSI
     escape  sequences	to  set	 background  and foreground, they
     should be coded as sseettaaff and sseettaabb,  respectively.	  If  the
     terminal  supports	 other escape sequences to set background
     and foreground, they should  be  coded  as	 sseettff  and  sseettbb,
     respectively.   The _v_i_d_p_u_t_s_(_) function and the refresh func-
     tions use sseettaaff and sseettaabb if they are defined."

     The sseettaaff/sseettaabb and sseettff/sseettbb  capabilities  take	a  single
     numeric  argument	each.	Argument  values 0-7 are portably
     defined as	 follows  (the	middle	column	is  the	 symbolic
     #define  available	 in  the header for the ccuurrsseess or nnccuurrsseess
     libraries).  The terminal hardware is free to map	these  as
     it	 likes,	 but  the RGB values indicate normal locations in
     color space.

	    CCoolloorr	##ddeeffiinnee	      VVaalluuee	  RRGGBB
	    black     CCOOLLOORR__BBLLAACCKK	0     0, 0, 0
	    red	      CCOOLLOORR__RREEDD		1     max,0,0
	    green     CCOOLLOORR__GGRREEEENN	2     0,max,0
	    yellow    CCOOLLOORR__YYEELLLLOOWW	3     max,max,0
	    blue      CCOOLLOORR__BBLLUUEE	4     0,0,max
	    magenta   CCOOLLOORR__MMAAGGEENNTTAA	5     max,0,max
	    cyan      CCOOLLOORR__CCYYAANN	6     0,max,max
	    white     CCOOLLOORR__WWHHIITTEE	7     max,max,max

     On an HP-like terminal, use ssccpp  with  a  color-pair  number
     parameter to set which color pair is current.

     On	 a  Tektronix-like  terminal,  the  capability cccccc may be
     present to indicate that colors can be modified.  If so, the
     iinniittcc  capability	will  take  a color number (0 to ccoolloorrss -
     1)and three more parameters which describe the color.  These
     three  parameters	default to being interpreted as RGB (Red,
     Green, Blue) values.   If	the  boolean  capability  hhllss  is
     present,  they  are  instead as HLS (Hue, Lightness, Satura-
     tion) indices.  The ranges are terminal-dependent.





MirOS BSD #9-current	Printed 1.10.2006		       35






TERMINFO(5)		   File Formats		      TERMINFO(5)



     On an HP-like terminal, iinniittpp  may	 give  a  capability  for
     changing a color-pair value.  It will take seven parameters;
     a color-pair number (0 to mmaaxx__ppaaiirrss - 1),	and  two  triples
     describing	 first	background  and	 then  foreground colors.
     These parameters must be (Red, Green, Blue) or (Hue,  Light-
     ness, Saturation) depending on hhllss.

     On	 some  color  terminals,  colors collide with highlights.
     You can register these collisions with the	 nnccvv  capability.
     This  is a bit-mask of attributes not to be used when colors
     are enabled.  The correspondence with the attributes  under-
     stood by ccuurrsseess is as follows:

		     AAttttrriibbuuttee	    BBiitt	  DDeecciimmaall
		     A_STANDOUT	    0	  1
		     A_UNDERLINE    1	  2
		     A_REVERSE	    2	  4
		     A_BLINK	    3	  8
		     A_DIM	    4	  16
		     A_BOLD	    5	  32
		     A_INVIS	    6	  64
		     A_PROTECT	    7	  128
		     A_ALTCHARSET   8	  256

     For   example,  on	 many  IBM  PC	consoles,  the	underline
     attribute collides with the foreground color blue and is not
     available	in color mode.	These should have an nnccvv capabil-
     ity of 2.

     SVr4 curses does nothing with nnccvv, ncurses recognizes it and
     optimizes the output in favor of colors.

     MMiisscceellllaanneeoouuss
     If	 the terminal requires other than a null (zero) character
     as a pad, then this can be given as  pad.	 Only  the  first
     character	of  the pad string is used.  If the terminal does
     not have a pad character, specify npc.   Note  that  ncurses
     implements	 the  termcap-compatible  PPCC variable; though the
     application may set this value to	something  other  than	a
     null,  ncurses will test nnppcc first and use napms if the ter-
     minal has no pad character.

     If the terminal can move up or down half a line, this can be
     indicated	with  hhuu  (half-line up) and hhdd (half-line down).
     This is primarily useful for superscripts and subscripts  on
     hard-copy	terminals.   If a hard-copy terminal can eject to
     the next page (form feed), give this as ffff (usually  control
     L).

     If	 there	is  a command to repeat a given character a given
     number of times (to save time transmitting a large number of
     identical	 characters)  this  can	 be  indicated	with  the



MirOS BSD #9-current	Printed 1.10.2006		       36






TERMINFO(5)		   File Formats		      TERMINFO(5)



     parameterized string rreepp.	The first parameter is the  char-
     acter  to	be repeated and the second is the number of times
     to repeat it.  Thus, tparm(repeat_char, 'x', 10) is the same
     as `xxxxxxxxxx'.

     If	 the  terminal	has a settable command character, such as
     the TEKTRONIX 4025, this can be  indicated	 with  ccmmddcchh.	A
     prototype	command	 character is chosen which is used in all
     capabilities.  This character is given in the ccmmddcchh capabil-
     ity  to  identify it.  The following convention is supported
     on some UNIX systems: The environment is to be searched  for
     a	CCCC  variable, and if found, all occurrences of the proto-
     type character are replaced with the character in the  envi-
     ronment variable.

     Terminal  descriptions that do not represent a specific kind
     of known terminal, such as _s_w_i_t_c_h, _d_i_a_l_u_p, _p_a_t_c_h,	and  _n_e_t_-
     _w_o_r_k,  should  include  the  ggnn (generic) capability so that
     programs can complain that they do not know how to	 talk  to
     the  terminal.   (This  capability does not apply to _v_i_r_t_u_a_l
     terminal descriptions for which  the  escape  sequences  are
     known.)

     If	 the  terminal	has  a ``meta key'' which acts as a shift
     key, setting the 8th bit of any character transmitted,  this
     fact  can	be  indicated  with kkmm.	 Otherwise, software will
     assume that the 8th bit is parity and  it	will  usually  be
     cleared.  If strings exist to turn this ``meta mode'' on and
     off, they can be given as ssmmmm and rrmmmm.

     If the terminal has more lines of memory than  will  fit  on
     the  screen  at  once,  the number of lines of memory can be
     indicated with llmm.	 A value of llmm#0 indicates that the  num-
     ber of lines is not fixed, but that there is still more mem-
     ory than fits on the screen.

     If the terminal is one of those supported by the  UNIX  vir-
     tual  terminal protocol, the terminal number can be given as
     vvtt.

     Media copy strings which control an auxiliary  printer  con-
     nected  to	 the terminal can be given as mmcc00: print the con-
     tents of the screen, mmcc44: turn off	 the  printer,	and  mmcc55:
     turn  on the printer.  When the printer is on, all text sent
     to the terminal will be sent to the printer.   It	is  unde-
     fined  whether  the  text	is also displayed on the terminal
     screen when the printer is on.  A variation mmcc55pp  takes  one
     parameter,	 and leaves the printer on for as many characters
     as the value of the parameter, then turns the  printer  off.
     The  parameter  should  not exceed 255.  All text, including
     mmcc44, is transparently passed to the printer while an mmcc55pp is
     in effect.



MirOS BSD #9-current	Printed 1.10.2006		       37






TERMINFO(5)		   File Formats		      TERMINFO(5)



     GGlliittcchheess aanndd BBrraaiinnddaammaaggee

     Hazeltine terminals, which do not allow `~' characters to be
     displayed should indicate hhzz.

     Terminals which ignore a line-feed immediately after  an  aamm
     wrap, such as the Concept and vt100, should indicate xxeennll.

     If	 eell is required to get rid of standout (instead of merely
     writing normal text on top of it), xxhhpp should be given.

     Teleray terminals, where tabs turn all characters moved over
     to blanks, should indicate xxtt (destructive tabs).	Note: the
     variable indicating this is now  `dest_tabs_magic_smso';  in
     older  versions, it was teleray_glitch.  This glitch is also
     taken to mean that it is not possible to position the cursor
     on top of a ``magic cookie'', that to erase standout mode it
     is instead necessary to use delete	 and  insert  line.   The
     ncurses implementation ignores this glitch.

     The  Beehive Superbee, which is unable to correctly transmit
     the escape or control C characters, has xxssbb, indicating that
     the  f1  key is used for escape and f2 for control C.  (Only
     certain Superbees have this problem, depending on the  ROM.)
     Note  that	 in  older terminfo versions, this capability was
     called `beehive_glitch'; it is now `no_esc_ctl_c'.

     Other specific terminal problems may be corrected by  adding
     more capabilities of the form xx_x.

     SSiimmiillaarr TTeerrmmiinnaallss

     If	 there	are two very similar terminals, one (the variant)
     can be defined as being just like the other (the base)  with
     certain  exceptions.   In the definition of the variant, the
     string capability uussee can be given with the name of the base
     terminal.	 The capabilities given before uussee override those
     in the base type named by uussee.  If there  are  multiple  uussee
     capabilities,  they  are  merged in reverse order.	 That is,
     the rightmost uussee reference is processed first, then the one
     to its left, and so forth.	 Capabilities given explicitly in
     the entry override those brought in by uussee references.

     A capability can be canceled by placing xxxx@@ to the	 left  of
     the  use reference that imports it, where _x_x is the capabil-
     ity.  For example, the entry

		 2621-nl, smkx@, rmkx@, use=2621,

     defines a 2621-nl that does not have the ssmmkkxx or rrmmkkxx  capa-
     bilities, and hence does not turn on the function key labels
     when in visual mode.  This is useful for different modes for



MirOS BSD #9-current	Printed 1.10.2006		       38






TERMINFO(5)		   File Formats		      TERMINFO(5)



     a terminal, or for different user preferences.

     PPiittffaallllss ooff LLoonngg EEnnttrriieess

     Long terminfo entries are unlikely to be a problem; to date,
     no entry has even approached terminfo's 4K string-table max-
     imum.  Unfortunately, the termcap translations are much more
     strictly limited (to 1K), thus termcap translations of  long
     terminfo entries can cause problems.

     The  man  pages  for  4.3BSD and older versions of tgetent()
     instruct the user to allocate a 1K buffer	for  the  termcap
     entry.   The  entry  gets	null-terminated	 by  the  termcap
     library, so that makes the maximum safe length for a termcap
     entry  1k-1 (1023) bytes.	Depending on what the application
     and the termcap library being used does, and  where  in  the
     termcap  file  the terminal type that tgetent() is searching
     for is, several bad things can happen.

     Some termcap libraries print a warning message  or	 exit  if
     they  find	 an  entry  that's longer than 1023 bytes; others
     don't; others truncate the	 entries  to  1023  bytes.   Some
     application  programs  allocate more than the recommended 1K
     for the termcap entry; others don't.

     Each termcap entry has two important sizes	 associated  with
     it:  before  "tc" expansion, and after "tc" expansion.  "tc"
     is the capability that tacks on another termcap entry to the
     end  of  the  current one, to add on its capabilities.  If a
     termcap entry doesn't  use	 the  "tc"  capability,	 then  of
     course the two lengths are the same.

     The  "before tc expansion" length is the most important one,
     because it affects more than just users of	 that  particular
     terminal.	 This  is the length of the entry as it exists in
     /etc/termcap, minus the backslash-newline pairs, which  tge-
     tent()  strips out while reading it.  Some termcap libraries
     strip off the final newline, too  (GNU  termcap  does  not).
     Now suppose:

     *	  a  termcap  entry  before  expansion	is more than 1023
	  bytes long,

     *	  and the application has only allocated a 1k buffer,

     *	  and the termcap library (like the one in BSD/OS 1.1 and
	  GNU)	reads  the whole entry into the buffer, no matter
	  what its length, to see if it's the entry it wants,

     *	  and tgetent() is searching for  a  terminal  type  that
	  either  is  the long entry, appears in the termcap file
	  after the long entry, or doesn't appear in the file  at



MirOS BSD #9-current	Printed 1.10.2006		       39






TERMINFO(5)		   File Formats		      TERMINFO(5)



	  all  (so that tgetent() has to search the whole termcap
	  file).

     Then tgetent() will overwrite memory, perhaps its stack, and
     probably  core  dump  the program.	 Programs like telnet are
     particularly vulnerable; modern telnets  pass  along  values
     like  the	terminal  type	automatically.	 The  results are
     almost as undesirable with a  termcap  library,  like  SunOS
     4.1.3  and	 Ultrix 4.4, that prints warning messages when it
     reads an overly long termcap entry.  If  a	 termcap  library
     truncates	long  entries,	like  OSF/1  3.0, it is immune to
     dying here but will return incorrect data for the	terminal.

     The  "after  tc expansion" length will have a similar effect
     to the above, but only for people who actually set	 TERM  to
     that terminal type, since tgetent() only does "tc" expansion
     once it's found the terminal type it was  looking	for,  not
     while searching.

     In	 summary,  a termcap entry that is longer than 1023 bytes
     can cause, on various combinations of termcap libraries  and
     applications, a core dump, warnings, or incorrect operation.
     If it's too long even before "tc" expansion,  it  will  have
     this  effect even for users of some other terminal types and
     users whose TERM variable does not have a termcap entry.

     When in -C (translate to termcap) mode, the  nnccuurrsseess  imple-
     mentation	of ttiicc(1) issues warning messages when the pre-tc
     length of a termcap translation is too long.  The -c (check)
     option also checks resolved (after tc expansion) lengths.

     BBiinnaarryy CCoommppaattiibbiilliittyy
     It	 is  not  wise to count on portability of binary terminfo
     entries between commercial UNIX versions.	 The  problem  is
     that  there are at least two versions of terminfo (under HP-
     UX and AIX) which diverged	 from  System  V  terminfo  after
     SVr1,  and	 have  added extension capabilities to the string
     table that (in the binary format) collide with System V  and
     XSI Curses extensions.

EEXXTTEENNSSIIOONNSS
     Some  SVr4 ccuurrsseess implementations, and all previous to SVr4,
     don't  interpret  the  %A	and  %O	 operators  in	parameter
     strings.

     SVr4/XPG4	do  not	 specify  whether  mmssggrr licenses movement
     while in an alternate-character-set mode  (such  modes  may,
     among  other  things, map CR and NL to characters that don't
     trigger local motions).  The nnccuurrsseess implementation  ignores
     mmssggrr  in  AALLTTCCHHAARRSSEETT mode.	 This raises the possibility that
     an XPG4 implementation making  the	 opposite  interpretation
     may  need	terminfo  entries  made	 for nnccuurrsseess to have mmssggrr



MirOS BSD #9-current	Printed 1.10.2006		       40






TERMINFO(5)		   File Formats		      TERMINFO(5)



     turned off.

     The nnccuurrsseess library  handles  insert-character  and  insert-
     character	modes  in a slightly non-standard way in order to
     get better update efficiency.  See the IInnsseerrtt//DDeelleettee CChhaarraacc--
     tteerr subsection above.

     The  parameter substitutions for sseett__cclloocckk and ddiissppllaayy__cclloocckk
     are not documented in SVr4 or the XSI Curses standard.  They
     are  deduced  from the documentation for the AT&T 505 termi-
     nal.

     Be careful assigning  the	kkmmoouuss  capability.   The  nnccuurrsseess
     wants to interpret it as KKEEYY__MMOOUUSSEE, for use by terminals and
     emulators like xterm that can return mouse-tracking informa-
     tion in the keyboard-input stream.

     Different	commercial  ports  of terminfo and curses support
     different subsets of the XSI Curses standard  and	(in  some
     cases)  different	extension sets.	 Here is a summary, accu-
     rate as of October 1995:

     SSVVRR44,, SSoollaarriiss,, nnccuurrsseess -- These support all  SVr4	capabili-
     ties.

     SSGGII -- Supports the SVr4 set, adds one undocumented extended
     string capability (sseett__ppgglleenn).

     SSVVrr11,, UUllttrriixx -- These support a restricted	 subset	 of  ter-
     minfo  capabilities.   The	 booleans  end with xxoonn__xxooffff; the
     numerics  with  wwiiddtthh__ssttaattuuss__lliinnee;	 and  the  strings   with
     pprrttrr__nnoonn.

     HHPP//UUXX  -- Supports the SVr1 subset, plus the SVr[234] numer-
     ics nnuumm__llaabbeellss,  llaabbeell__hheeiigghhtt,  llaabbeell__wwiiddtthh,  plus	 function
     keys 11 through 63, plus ppllaabb__nnoorrmm, llaabbeell__oonn, and llaabbeell__ooffff,
     plus some incompatible extensions in the string table.

     AAIIXX -- Supports the  SVr1	subset,	 plus  function	 keys  11
     through  63,  plus	 a  number  of	incompatible string table
     extensions.

     OOSSFF -- Supports both the SVr4 set and the AIX extensions.

FFIILLEESS
     /usr/share/misc/terminfo.db
			      file containing  terminal	 descrip-
			      tions on OpenBSD

     /usr/share/terminfo/?/*  files  containing terminal descrip-
			      tions on other systems




MirOS BSD #9-current	Printed 1.10.2006		       41






TERMINFO(5)		   File Formats		      TERMINFO(5)



SSEEEE AALLSSOO
     ccaapp__mmkkddbb((11)), ttiicc(1M), ccuurrsseess(3), pprriinnttff(3), tteerrmm(5).

AAUUTTHHOORRSS
     Zeyd M. Ben-Halim, Eric S. Raymond, Thomas E. Dickey.  Based
     on pcurses by Pavel Curtis.

















































MirOS BSD #9-current	Printed 1.10.2006		       42



