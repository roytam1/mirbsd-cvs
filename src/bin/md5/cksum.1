.\"	$MirOS: src/bin/md5/cksum.1,v 1.33 2018/10/07 01:10:10 tg Exp $
.\"	$OpenBSD: cksum.1,v 1.5 2005/03/07 23:41:53 jmc Exp $
.\"
.\" Copyright (c) 2006, 2007, 2008, 2009, 2011, 2014, 2016, 2018
.\"	mirabilos <m@mirbsd.org>
.\" Copyright (c) 1991, 1993
.\"	The Regents of the University of California.  All rights reserved.
.\"
.\" This code is derived from software contributed to Berkeley by
.\" the Institute of Electrical and Electronics Engineers, Inc.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. Neither the name of the University nor the names of its contributors
.\"    may be used to endorse or promote products derived from this software
.\"    without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.\"	@(#)cksum.1	8.2 (Berkeley) 4/28/95
.\"
.\"-
.\" Try to make GNU groff and AT&T nroff more compatible
.\" * ` generates ‘ in gnroff, so use \`
.\" * ' generates ’ in gnroff, \' generates ´, so use \*(aq
.\" * - generates ‐ in gnroff, \- generates −, so .tr it to -
.\"   thus use - for hyphens and \- for minus signs and option dashes
.\" * ~ is size-reduced and placed atop in groff, so use \*(TI
.\" * ^ is size-reduced and placed atop in groff, so use \*(ha
.\" * \(en does not work in nroff, so use \*(en
.\" * <>| are problematic, so redefine and use \*(Lt\*(Gt\*(Ba
.\" Also make sure to use \& *before* a punctuation char that is to not
.\" be interpreted as punctuation, and especially with two-letter words
.\" but also (after) a period that does not end a sentence (“e.g.\&”).
.\" The section after the "doc" macropackage has been loaded contains
.\" additional code to convene between the UCB mdoc macropackage (and
.\" its variant as BSD mdoc in groff) and the GNU mdoc macropackage.
.\"
.ie \n(.g \{\
.	if \*[.T]ascii .tr \-\N'45'
.	if \*[.T]latin1 .tr \-\N'45'
.	if \*[.T]utf8 .tr \-\N'45'
.	ds <= \[<=]
.	ds >= \[>=]
.	ds Rq \[rq]
.	ds Lq \[lq]
.	ds sL \(aq
.	ds sR \(aq
.	if \*[.T]utf8 .ds sL `
.	if \*[.T]ps .ds sL `
.	if \*[.T]utf8 .ds sR '
.	if \*[.T]ps .ds sR '
.	ds aq \(aq
.	ds TI \(ti
.	ds ha \(ha
.	ds en \(en
.\}
.el \{\
.	ds aq '
.	ds TI ~
.	ds ha ^
.	ds en \(em
.\}
.\"
.\" Implement .Dd with the Mdocdate RCS keyword
.\"
.rn Dd xD
.de Dd
.ie \\$1$Mdocdate: \{\
.	xD \\$2 \\$3, \\$4
.\}
.el .xD \\$1 \\$2 \\$3 \\$4 \\$5 \\$6 \\$7 \\$8
..
.\"
.\" .Dd must come before definition of .Mx, because when called
.\" with -mandoc, it might implement .Mx itself, but we want to
.\" use our own definition. And .Dd must come *first*, always.
.\"
.Dd $Mdocdate: December 25 2018 $
.\"
.\" Check which macro package we use, and do other -mdoc setup.
.\"
.ie \n(.g \{\
.	if \*[.T]utf8 .tr \[la]\*(Lt
.	if \*[.T]utf8 .tr \[ra]\*(Gt
.	ie d volume-ds-1 .ds tT gnu
.	el .ie d doc-volume-ds-1 .ds tT gnp
.	el .ds tT bsd
.\}
.el .ds tT ucb
.\"
.\" Implement .Mx (MirBSD)
.\"
.ie "\*(tT"gnu" \{\
.	eo
.	de Mx
.	nr curr-font \n[.f]
.	nr curr-size \n[.ps]
.	ds str-Mx \f[\n[curr-font]]\s[\n[curr-size]u]
.	ds str-Mx1 \*[Tn-font-size]\%MirBSD\*[str-Mx]
.	if !\n[arg-limit] \
.	if \n[.$] \{\
.	ds macro-name Mx
.	parse-args \$@
.	\}
.	if (\n[arg-limit] > \n[arg-ptr]) \{\
.	nr arg-ptr +1
.	ie (\n[type\n[arg-ptr]] == 2) \
.	as str-Mx1 \~\*[arg\n[arg-ptr]]
.	el \
.	nr arg-ptr -1
.	\}
.	ds arg\n[arg-ptr] "\*[str-Mx1]
.	nr type\n[arg-ptr] 2
.	ds space\n[arg-ptr] "\*[space]
.	nr num-args (\n[arg-limit] - \n[arg-ptr])
.	nr arg-limit \n[arg-ptr]
.	if \n[num-args] \
.	parse-space-vector
.	print-recursive
..
.	ec
.	ds sP \s0
.	ds tN \*[Tn-font-size]
.\}
.el .ie "\*(tT"gnp" \{\
.	eo
.	de Mx
.	nr doc-curr-font \n[.f]
.	nr doc-curr-size \n[.ps]
.	ds doc-str-Mx \f[\n[doc-curr-font]]\s[\n[doc-curr-size]u]
.	ds doc-str-Mx1 \*[doc-Tn-font-size]\%MirBSD\*[doc-str-Mx]
.	if !\n[doc-arg-limit] \
.	if \n[.$] \{\
.	ds doc-macro-name Mx
.	doc-parse-args \$@
.	\}
.	if (\n[doc-arg-limit] > \n[doc-arg-ptr]) \{\
.	nr doc-arg-ptr +1
.	ie (\n[doc-type\n[doc-arg-ptr]] == 2) \
.	as doc-str-Mx1 \~\*[doc-arg\n[doc-arg-ptr]]
.	el \
.	nr doc-arg-ptr -1
.	\}
.	ds doc-arg\n[doc-arg-ptr] "\*[doc-str-Mx1]
.	nr doc-type\n[doc-arg-ptr] 2
.	ds doc-space\n[doc-arg-ptr] "\*[doc-space]
.	nr doc-num-args (\n[doc-arg-limit] - \n[doc-arg-ptr])
.	nr doc-arg-limit \n[doc-arg-ptr]
.	if \n[doc-num-args] \
.	doc-parse-space-vector
.	doc-print-recursive
..
.	ec
.	ds sP \s0
.	ds tN \*[doc-Tn-font-size]
.\}
.el \{\
.	de Mx
.	nr cF \\n(.f
.	nr cZ \\n(.s
.	ds aa \&\f\\n(cF\s\\n(cZ
.	if \\n(aC==0 \{\
.		ie \\n(.$==0 \&MirBSD\\*(aa
.		el .aV \\$1 \\$2 \\$3 \\$4 \\$5 \\$6 \\$7 \\$8 \\$9
.	\}
.	if \\n(aC>\\n(aP \{\
.		nr aP \\n(aP+1
.		ie \\n(C\\n(aP==2 \{\
.			as b1 \&MirBSD\ #\&\\*(A\\n(aP\\*(aa
.			ie \\n(aC>\\n(aP \{\
.				nr aP \\n(aP+1
.				nR
.			\}
.			el .aZ
.		\}
.		el \{\
.			as b1 \&MirBSD\\*(aa
.			nR
.		\}
.	\}
..
.\}
.\"-
.Dt CKSUM 1
.Os
.Sh NAME
.Nm cksum ,
.Nm sum
.Nd display file checksums and block counts
.Sh SYNOPSIS
.Nm cksum
.Bk -words
.Op Fl a Ar algorithms
.Op Fl o Ar 1 | 2
.Op Fl b
.Oo
.Fl p | s Ar string |
.Ar file ...
.Oc
.Ek
.Nm cksum
.Bk -words
.Op Fl a Ar algorithms
.Op Fl o Ar 1 | 2
.Fl G
.Op Ar file ...
.Ek
.Nm cksum
.Bk -words
.Op Fl a Ar algorithms
.Op Fl o Ar 1 | 2
.Fl t | x |
.Fl c Op Ar checklist ...
.Ek
.Nm sum
.Op Ar file ...
.Sh DESCRIPTION
The
.Nm cksum
utility writes to the standard output a single line for each input file.
The format of this line varies with the algorithm being used as follows:
.Bl -tag -width allXothers
.It Ar cksum
The output line consists of three whitespace separated fields: a
.Tn CRC
checksum, the number of octets in the input,
and name of the file or string.
Binary output consists of two 64-bit parts,
corresponding to the checksum and length, respectively.
If no file name is specified, the standard input is used and no file name
is written.
.It Ar sum
The output line consists of three whitespace separated fields: a
.Tn CRC
checksum, the number of kilobytes in the input,
and name of the file or string.
Binary output consists of two 64-bit parts,
corresponding to the checksum and length, respectively.
If no file name is specified, the standard input is used and no file name
is written.
.It Ar sysvsum
The output line consists of three whitespace separated fields: a
.Tn CRC
checksum, the number of 512-byte blocks in the input,
and name of the file or string.
Binary output consists of two 64-bit parts,
corresponding to the checksum and length, respectively.
If no file name is specified, the standard input is used and no file name
is written.
.It Ar sfv
The output line consists of the file name followed by a space,
unless the data to be processed is read from standard input,
followed by a
.Xr cksfv 1
compatible
.Tn CRC
expressed as eight sedecimal numbers.
The algorithm is often vulgarly called CRC32 or even CRC,
for instance for verifying the integrity of downloads from
a certain Redmond software house or by Anime fansub groups.
.Pp
You might want to add a comment generated by the following commands
before the block of SFV hashes:
.Bd -literal
$ stat \-L \-f \*(aq; %12z  %Sm %N\*(aq \-t \*(aq%H:%M.%S %F\*(aq file ...
.Ed
.It Ar all others
The output line consists of four whitespace separated fields:
the name of the algorithm used, the name of the file or string in
parentheses, an equals sign, and the cryptographic hash of the input.
Binary output consists of simply the sedecimal hash value, read from left
to right (big endian), converted into bytes; the length is not encoded.
If no file name is specified, the standard input is used and only
the cryptographic hash is output.
In the
.Ar cdb
case, the output is the DJB
.Pq CDB
hash of the input string.
In the
.Ar oaat
case, the output is Jenkins' one-at-a-time hash of the input string.
The
.Ar oaat1
and
.Ar oaat1s
hashes use 0x100 instead of 0 as initial hash value, and
.Ar oaat1s
also uses RFC1321-style length padding on the input string.
In the
.Ar bafh ,
.Ar nzaat
or
.Ar nzat
case, this is a
.Mx
invented hash based on
.Ar oaat .
.Ar bafh
is also partially based on AES.
In the
.Ar suma
case, the output is a 33-bit
.Tn CRC
over the file, expressed as eight sedecimal numbers.
Both input processing and binary output are in little-endian convention.
In the
.Ar size
case, the output is a decimal unsigned 64-bit quantity denominating the
size of the data read; binary representation is big-endian.
.El
.Pp
The
.Nm sum
utility is identical to the
.Nm cksum
utility, except that it defaults to using historic algorithm 1, as
described below.
It is provided for compatibility only.
.Pp
The options are as follows:
.Bl -tag -width Ds
.It Fl a Ar algorithms
Use the specified algorithm(s) instead of the default (cksum).
Supported algorithms include
.Ar adler32 ,
.Ar bafh ,
.Ar cdb ,
.Ar cksum ,
.Ar md4 ,
.Ar md5 ,
.Ar nzat ,
.Ar nzaat ,
.Ar oaat ,
.Ar oaat1 ,
.Ar oaat1s ,
.Ar rmd160 ,
.Ar sfv ,
.Ar sha1 ,
.Ar sha256 ,
.Ar sha384 ,
.Ar sha512 ,
.Ar size ,
.Ar sum ,
.Ar suma ,
.Ar sysvsum ,
.Ar tiger ,
and
.Ar whirlpool .
Multiple algorithms may be specified, separated by a comma or whitespace.
Additionally, multiple
.Fl a
options may be specified on the command line.
If an algorithm is repeated, only the first instance is used.
Case is ignored when matching algorithms.
.It Fl b
Print the checksum as binary to stdout.
.It Fl c Op Ar checklist ...
Compares all checksums contained in the file
.Ar checklist
with newly computed checksums for the corresponding files.
Output consists of the digest used, the file name,
and an OK or FAILED for the result of the comparison.
This will validate any of the supported checksums.
If no file is given, stdin is used.
The
.Fl c
option may not be used in conjunction with more than a single
.Fl a
option.
.Pp
The
.Ar checklist
must either be in normal
.Nm
format or in GNU
.Nm md5sum
compatible format.
Verifying
.Nm cksfv Ns -style
input is not supported.
.It Fl G
Be somewhat compatible to the GNU
.Nm md5sum
tool in our output.
This will also be invoked if this program is called as
.Nm md5sum ,
.Nm sha1sum , ...
Note that only the
.Fl b
and
.Fl t
options are somewhat recognised (and ignored), the
.Fl c
and
.Fl w
options and any GNU long options are rejected, and this
output mode does not make any sense for many algorithms, such as
.Ar adler32 ,
.Ar bafh ,
.Ar cdb ,
.Ar cksum ,
.Ar nzat ,
.Ar nzaat ,
.Ar oaat ,
.Ar oaat1 ,
.Ar oaat1s ,
.Ar sfv ,
.Ar size ,
.Ar sum ,
.Ar suma ,
and
.Ar sysvsum .
.It Fl o Ar 1 | 2
Use historic algorithms instead of the (superior) default one
(see below).
.It Fl p
Echoes stdin to stdout and appends the
checksum to stdout.
.It Fl s Ar string
Prints a checksum of the given
.Ar string .
.It Fl t
Runs a built-in time trial.
.It Fl x
Runs a built-in test script.
The output conforms to the NESSIE test vector format, Set 1.
.El
.Pp
Algorithm 1 (aka
.Ar sum )
is the algorithm used by historic
.Bx
systems as the
.Nm sum
algorithm and by historic
.At V
systems as the
.Nm sum
algorithm when using the
.Fl r
option.
This is a 16-bit checksum, with a right rotation before each addition;
overflow is discarded.
.Pp
Algorithm 2 (aka
.Ar sysvsum )
is the algorithm used by historic
.At V
systems as the
default
.Nm sum
algorithm.
This is a 32-bit checksum, and is defined as follows:
.Bd -unfilled -offset indent
s = sum of all bytes;
r = s % 2\*(ha16 + (s % 2\*(ha32) / 2\*(ha16;
cksum = (r % 2\*(ha16) + r / 2\*(ha16;
.Ed
.Pp
Both algorithm 1 and 2 write to the standard output the same fields as
the default algorithm, except that the size of the file in bytes is
replaced with the size of the file in blocks.
For historic reasons, the block size is 1024 for algorithm 1 and 512
for algorithm 2.
Partial blocks are rounded up.
.Pp
The default
.Tn CRC
used is based on the polynomial used for
.Tn CRC
error checking
in the networking standard
.St -iso8802-3 .
The
.Tn CRC
checksum encoding is defined by the generating polynomial:
.Bd -unfilled -offset indent
G(x) = x\*(ha32 + x\*(ha26 + x\*(ha23 + x\*(ha22 + x\*(ha16 + x\*(ha12 +
     x\*(ha11 + x\*(ha10 + x\*(ha8 + x\*(ha7 + x\*(ha5 + x\*(ha4 + x\*(ha2 + x + 1
.Ed
.Pp
Mathematically, the
.Tn CRC
value corresponding to a given file is defined by
the following procedure:
.Bd -filled -offset indent
The
.Ar n
bits to be evaluated are considered to be the coefficients of a mod 2
polynomial M(x) of degree
.Ar n Ns \-1 .
These
.Ar n
bits are the bits from the file, with the most significant bit being the most
significant bit of the first octet of the file and the last bit being the least
significant bit of the last octet, padded with zero bits (if necessary) to
achieve an integral number of octets, followed by one or more octets
representing the length of the file as a binary value, least significant octet
first.
The smallest number of octets capable of representing this integer are used.
.Pp
M(x) is multiplied by x\*(ha32 (i.e., shifted left 32 bits) and divided by
G(x) using mod 2 division, producing a remainder R(x) of degree \*(Lt= 31.
.Pp
The coefficients of R(x) are considered to be a 32-bit sequence.
.Pp
The bit sequence is complemented and the result is the CRC.
.Ed
.Pp
The
.Ar sfv
.Tn CRC
is undocumented, cf.\&
.Pa http://www.fodder.org/cksfv/
.br
It seems to be widely known, though, and appears to use the same
polynomial and conventions as the (non-ADLER32) crc32 function of
.Xr gzip 1 .
.Pp
The
.Ar suma
.Tn CRC
uses little endian 32-bit block reading conventions,
initialisation of the CRC with an all-ones word and a
different 33-bit polynomial.
.Pp
The other available algorithms are described in their respective
man pages in section 3 of the manual.
.Sh DIAGNOSTICS
The
.Nm cksum
and
.Nm sum
utilities exit 0 on success or \*(Gt0 if an error occurred.
.Sh SEE ALSO
.Xr md5 1 ,
.Xr rmd160 1 ,
.Xr sha1 1 ,
.Xr stat 1 ,
.Xr adler32 3 ,
.Xr md4 3 ,
.Xr md5 3 ,
.Xr rmd160 3 ,
.Xr sfv 3 ,
.Xr sha1 3 ,
.Xr sha2 3 ,
.Xr suma 3 ,
.Xr tiger 3 ,
.Xr whirlpool 3
.Pp
The default calculation is identical to that given in pseudo-code
in the following
.Tn ACM
article:
.Rs
.%T "Computation of Cyclic Redundancy Checks Via Table Lookup"
.%A Dilip V. Sarwate
.%J "Communications of the \\*(tNACM\\*(sP"
.%D "August 1988"
.Re
.Pp
.Pa http://www.cryptonessie.org/
.Sh STANDARDS
The
.Nm cksum
utility is compliant with the
.St -p1003.2-92
specification.
.Pp
The
.Ar sfv
format and the comment format given above are compatible with
the output generated by Bryan Call's
.Nm cksfv .
.Sh HISTORY
A
.Nm sum
command appeared in
.At v2 .
The
.Nm cksum
utility appeared in
.Bx 4.4
and has been enhanced by new algorithms in
.Ox
and several times in
.Mx .
.Sh CAVEATS
Do not use the
.Ar adler32 ,
.Ar bafh ,
.Ar cdb ,
.Ar cksum ,
.Ar md4 ,
.Ar md5 ,
.Ar nzat ,
.Ar nzaat ,
.Ar oaat ,
.Ar oaat1 ,
.Ar oaat1s ,
.Ar sfv ,
.Ar sha1 ,
.Ar size ,
.Ar sum ,
.Ar suma ,
.Ar sysvsum ,
or
.Ar tiger
algorithms to detect hostile binary modifications.
For most of the algorithms listed above, an attacker can trivially produce
backdoored daemons which have the same checksum as the standard versions.
Even
.Ar md4
has been long broken, collisions for
.Ar md5
are published and picked up by script kiddies, and the attack used for
.Ar md5
has already been successfully mounted on a reduced form of
.Ar sha1 .
Use a cryptographically strong checksum (such as RIPEMD\-160) instead,
or combine two algorithms from different families, for example,
.Xr rmd160 ,
.Xr whirlpool ,
and, optionally, one of the CRCs.
