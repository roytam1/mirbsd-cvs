# $MirOS: src/share/misc/bsdstats,v 1.36 2007/05/16 20:40:34 tg Exp $
# $FreeBSD: ports/sysutils/bsdstats/files/300.statistics,v 1.38 2006/12/05 13:49:45 scrappy Exp $
#-
# Copyright (c) 2007
#	Thorsten Glaser <tg@mirbsd.de>
# Loosely based upon the original bsdstats script and API by
#	Marc G. Fournier <scrappy@freebsd.org>
#
# Provided that these terms and disclaimer and all copyright notices
# are retained or reproduced in an accompanying document, permission
# is granted to deal in this work without restriction, including un-
# limited rights to use, publicly perform, distribute, sell, modify,
# merge, give away, or sublicence.
#
# This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
# the utmost extent permitted by applicable law, neither express nor
# implied; without malicious intent or gross negligence. In no event
# may a licensor, author or contributor be held liable for indirect,
# direct, other damage, loss, or other issues arising in any way out
# of dealing in the work, even if advised of the possibility of such
# damage or existence of a defect, except proven that it results out
# of said person's immediate fault when using the work as intended.

#-- Configuration

# server to report to
rpt='http://rpt.bsdstats.org/scripts/'

# report only known BSDs?
do_bsdonly=1

#-- Do not change below

export TZ=UTC PATH=/bin:/usr/bin:/sbin:/usr/sbin
for dir in /usr/mpkg /usr/pkg /usr/local /sw; do
	for subdir in bin sbin; do
		[[ -e $dir/$subdir ]] && PATH=$PATH:$dir/$subdir
	done
done

stats_token=
integer stats_token_time=0
integer stats_report_time=0

if [[ -e /etc/rc.conf && -O /etc/rc.conf ]]; then
	bsdstats_flags=$(. /etc/rc.conf; echo "$bsdstats_flags")
else
	bsdstats_flags=YES
fi
[[ -s /var/db/bsdstats && -O /var/db/bsdstats ]] && . /var/db/bsdstats

if [[ $(uname -M 2>&1) = *MirBSD* ]]; then
	opsys=MirBSD
	ops_m=1
else
	opsys=$(uname -s)
	ops_m=0
fi
if [[ $do_bsdonly != 0 && $opsys != @(*BSD|DragonFly) ]]; then
	print -u2 Error: $opsys is not a BSD!
	return 1
fi

if [[ -x /usr/bin/ftp ]]; then
	fetch='/usr/bin/ftp -Vo -'
elif whence -p wget >&- 2>&-; then
	fetch="$(whence -p wget) -qO -"
elif whence -p ftp >&- 2>&-; then
	fetch="$(whence -p ftp) -Vo -"
else
	print -u2 Error: select a HTTP fetch programme!
	return 1
fi

if date --help >/dev/null 2>&1; then
	function timet2date {
		date -d @$*
	}
else
	function timet2date {
		date -r $*
	}
	datetype=bsd
fi

if whence -p logger >&- 2>&-; then
	function logit {
		print -nr -- "$@" | logger -t bsdstats
	}
else
	function logit {
		print -r bsdstats: "$@"
	}
fi

# RFC 2396
function uri_escape {
	print -nr -- "$*" | sed -e '
	    s.%.%25.g
	    s.;.%3B.g
	    s./.%2F.g
	    s.?.%3F.g
	    s.:.%3A.g
	    s.@.%40.g
	    s.&.%26.g
	    s.=.%3D.g
	    s.+.%2B.g
	    s.\$.%24.g
	    s.,.%2C.g
	    s.	.%09.g
	    s. .%20.g
	    s.<.%3C.g
	    s.>.%3E.g
	    s.#.%23.g
	    s.".%22.g
	    s.{.%7B.g
	    s.}.%7D.g
	    s.|.%7C.g
	    s.\\.%5C.g
	    s.\^.%5E.g
	    s.\[.%5B.g
	    s.\].%5D.g
	    s.`.%60.g
	'
}

# weird POST reporting of ports in $qs
function report_ports {
	if ! whence -p nc; then
		print 'warning: nc (netcat) not found, not reporting packages'
		return 0
	fi
	#XXX honour http_proxy host/port
	host=${rpt#http://}
	host=${host%%/*}
	path=${rpt#*$host}report_ports.php
	integer port=0
	if [[ $host = *:+([0-9]) ]]; then
		port=${host##*:}
		host=${host%:*}
	fi
	if [[ $host = \[*] ]]; then
		host=${host#\[}
		host=${host%]}
	fi
	(( (port < 1) || (port > 65535) )) && port=80
	qs="token=$stats_key&key=$stats_token$qs"
	qs="POST $path HTTP/1.0
Host: $host
User-Agent: bsdstats \$MirOS: src/share/misc/bsdstats,v 1.36 2007/05/16 20:40:34 tg Exp $
Connection: close
Content-Type: application/x-www-form-urlencoded
Content-Length: ${#qs}

$qs"
	res=$(sleep $((RANDOM % 99 + 21)); \
	    print -r -- "$qs" | nc $host $port 2>/dev/null)
	logit "ports report to $host:$port with '$qs' -> ${res:-ERROR}"
	[[ $res = *OK* ]] || ok=0
}

host=${rpt#http://}
host=${host%%/*}
# do it twice in case DNS is slow
if ! whence -p host >&- 2>&-; then
	print warning: cannot do DNS checks
elif [[ $host = *bsdstats.org*(.) ]]; then
	res=$(host -t txt bsdstats.org. 2>&1 & dnspid=$!; \
	    (/bin/sleep 12; kill $dnspid) >&- 2>&- & wait $dnspid)
	[[ $res = *@(not found|not exist|NXDOMAIN)* ]] && res=
	[[ $res = *UP* ]] || res=$(host -t txt bsdstats.org. 2>&1 & dnspid=$!; \
	    (/bin/sleep 12; kill $dnspid) >&- 2>&- & wait $dnspid)
	[[ $res = *@(not found|not exist|NXDOMAIN)* ]] && res=
	if [[ $res != *UP* ]]; then
		print not connecting to $host: bsdstats.org not up
		return 0
	fi
else
	res=$(host -t a ${host%%+(.)}. 2>&1 & dnspid=$!; \
	    (/bin/sleep 12; kill $dnspid) >&- 2>&- & wait $dnspid)
	[[ $res = *@(not found|not exist|NXDOMAIN)* ]] && res=
	[[ $res = *UP* ]] || res=$(host -t a ${host%%+(.)}. 2>&1 & dnspid=$!; \
	    (/bin/sleep 12; kill $dnspid) >&- 2>&- & wait $dnspid)
	[[ $res = *@(not found|not exist|NXDOMAIN)* ]] && res=
	if [[ $res != *${host%%+(.)}* ]]; then
		print not connecting to $host: cannot resolve
		return 0
	fi
fi

if print test | uuencode -m - >/dev/null 2>&1; then
	uname_code=ok:$(uname -a | uuencode -m - | tr -d '\012\015 ')
else
	print warning: uuencode missing or incomplete
	uname_code=not:$RANDOM$(date +%s)
fi
uname_code=$uname_code$stats_sysadd

print "last report time was: $stats_report_time" \
    "($(timet2date $stats_report_time))"
(( stats_report_time < 1136073623 )) && stats_report_time=0
[[ $stats_uname_code = $uname_code ]] || stats_report_time=0
(( stats_token_time < 1136073623 )) && stats_token_time=0
(( stats_token_time > 0 )) || stats_token=
integer ok=1
if [[ -z $stats_token || -z $stats_key ]]; then
	stats_report_time=0
	if ! whence -p openssl >&- 2>&-; then
		print -u2 Error: openssl tool missing
		return 1
	fi
	stats_key=$(uri_escape $(openssl rand -base64 32))
	uri="getid.php?key=$stats_key"
	res=$(sleep $((RANDOM % 99 + 21)); $fetch "$rpt$uri" 2>/dev/null)
	logit "firstrun $uri -> ${res:-ERROR}"
	stats_token=$(uri_escape $(eval $res; print -nr -- "$KEY"))
	stats_token_time=$(date +%s)
fi
integer now=$(date +%s)
if (( now > (stats_report_time + 10 * 86400) )); then
	version=$(uname -r)
	arch=$(sysctl -n hw.machine_arch 2>&-)
	[[ -n $arch ]] || arch=$(sysctl -n hw.machine 2>&-)
	[[ -n $arch ]] || arch=$(uname -m)
	if [[ $opsys = GNU* ]]; then
		[[ -z $stats_sysadd && -s /etc/debian_version ]] && \
		    stats_sysadd=.Debian-$(tr / _ </etc/debian_version)
	elif [[ $ops_m = 1 && -n $stats_sysadd ]]; then
		version=$(uname -M | sed 's/^.*BSD #\([0-9]\).*/\1/')
	elif [[ $opsys = MirBSD && -z $stats_sysadd ]]; then
		version=$(uname -l)
		version=${version#\#}
		version=${version%%-*}
		typeset -i10 pl=0x${version##*[a-z]}
		[[ ${version%%[a-z]*} -lt 8 ]] && pl=157
		version=${version%%[a-z]*}
		if (( pl < 128 )); then
			version=$version-beta
		elif (( pl == 159 )); then
			version=$version-finite
		elif (( pl >= 160 )); then
			version=$version-current
		elif (( (pl % 2) == 1 )); then
			version=$version-stable
		else
			case $pl {
			(128)	version=${version}semel ;;
			(130)	version=${version}bis ;;
			(132)	version=${version}ter ;;
			(134)	version=${version}quater ;;
			(136)	version=${version}quinquies ;;
			(*)	version=${version}num.$(( pl / 2 - 63 ))ies ;;
			}
		fi
	fi
	uri="enable_token.php?key=$stats_key&token=$stats_token"
	res=$(sleep $((RANDOM % 99 + 21)); $fetch "$rpt$uri" 2>/dev/null)
	logit "init $uri -> ${res:-ERROR}"
	uri="report_system.php?token=$stats_key&key=$stats_token"
	uri="$uri&rel=$(uri_escape $version$stats_sysadd)"
	uri="$uri&arch=$arch&opsys=$opsys"
	res=$(sleep $((RANDOM % 99 + 21)); $fetch "$rpt$uri" 2>/dev/null)
	logit "system report $uri -> ${res:-ERROR}"
	[[ $res = *OK* ]] || ok=0
	if [[ $bsdstats_flags = YES ]]; then
		# Hardware report: CPU(s)
		integer ncpus=$(sysctl -n hw.ncpu)
		cpu=$(sysctl -n hw.model)
		(( ncpus < 2 )) && ncpus=1
		uri="report_cpu.php?token=$stats_key&key=$stats_token"
		uri="$uri&cpus=$ncpus&vendor=${cpu%% *}"
		uri="$uri&cpu_type=$(uri_escape "${cpu#* }")"
		res=$(sleep $((RANDOM % 99 + 21)); $fetch "$rpt$uri" 2>/dev/null)
		logit "cpu report $uri -> ${res:-ERROR}"
		[[ $res = *OK* ]] || ok=0
		# Software report
		qs=
		# report MirPorts Framework installed binary packages
		(find /usr/mpkg/db/pkg -name +CONTENTS -print0 2>/dev/null | \
		    xargs -0 grep '^@comment.*subdir=' | \
		    sed 's!^[^:]*/\([^/:]*\)/+CONTENTS:.*subdir=\([^, ]*\).*$!\1:\2!' | \
		    sort) |&	# interesting that we _need_ the parens here oO
		while IFS=: read -pr name dir; do
			qs="$qs&port[]=$(uri_escape "${dir%%/*}")"
			# convert stem-version-pl-flavour-...
			# to stem-version_MirPorts_pl,flavour,...
			stem=${name%%-[0-9]*}
			name=${name#$stem-}		# version-pl-flavour
			vers=${name%%-[a-zA-z]*}	# version-pl
			name=${name#$vers}		# -flavour
			vers=${vers%-+([0-9])}-MirPorts${vers#${vers%-+([0-9])}}
			vers=$(print -r "$vers" | tr - _)
			name=$(print -r -- "$name" | tr - ,)
			qs="$qs:$(uri_escape "$stem-$vers$name")"
		done
		# scan for NetBSD pkgsrc installed binary packages
		res=
		for dir in /usr/pkg/pkgdb /usr/pkg/db/pkg /var/db/pkg; do
			[[ -e $dir ]] || continue
			for file in $dir/*/+BUILD_INFO; do
				[[ -e $file ]] || continue
				res=y
				break 2
			done
		done
		[[ -n $res ]] || dir=/nonexistent
		(find $dir -name +BUILD_INFO 2>/dev/null | sort) |&
		while IFS= read -pr fn; do
			name=${fn%/*}		# directory
			name=${name##*/}	# pkgname
			[[ $name = *@(nb)+([0-9]) ]] || name=${name}nb0
			# look for pkgsrc's bmake
			bmake=/usr/pkg/bin/bmake
			[[ -x $bmake ]] || bmake=$(whence -p bmake 2>&-)
			# use BSD make (usually in /usr/bin), but not GNU make
			[[ -x $bmake ]] || [[ $opsys = GNU* ]] || \
			    bmake=$(whence -p make 2>&-)
			# (we could also check --version output tho)
			[[ -x $bmake ]] || print warning: cannot find bmake
			[[ -x $bmake ]] || break
			eval $(print 'all:\n\t@print -r -- "dir=${PKGPATH:Q}' \
			    'flavours=${PKG_OPTIONS:Q}"\n.include "'"$fn\"" | \
			    $bmake -f - all)	# subdir, flavours
			qs="$qs&port[]=$(uri_escape "${dir%%/*}")"
			for flavour in $flavours; do
				name=$name,$flavour
			done
			qs="$qs:$(uri_escape "$name")"
		done
		# look for Debian installed software
		(whence -p dpkg-query >&- 2>&- && \
		    dpkg-query -Wf '${Section}\t${Package}\t${Version}\n') |&
		while IFS='	' read -pr section name ver; do
			qs="$qs&port[]=$(uri_escape "$section")"
			name="$name-$(print -nr -- "$ver" | tr ':-' ';_')"
			qs="$qs:$(uri_escape "$name")"
		done
		# send info about any found binary packages now at once
		[[ -z $qs ]] || report_ports
	fi
	uri="disable_token.php?key=$stats_key&token=$stats_token"
	res=$(sleep $((RANDOM % 99 + 21)); $fetch "$rpt$uri" 2>/dev/null)
	logit "done $uri -> ${res:-ERROR}"
	if (( ok )); then
		stats_report_time=$(date +%s)
		print "Reported successfully on $(date)"
	fi
else
	print "Nothing to do for now..."
fi
install -c -o root -g staff -m 640 /dev/null /var/db/bsdstats.new
print "stats_key=$stats_key" >/var/db/bsdstats.new
print "stats_token=$stats_token" >>/var/db/bsdstats.new
print "stats_token_time=$stats_token_time" >>/var/db/bsdstats.new
print "stats_report_time=$stats_report_time" >>/var/db/bsdstats.new
print "stats_uname_code=\"$uname_code\"" >>/var/db/bsdstats.new
mv -f /var/db/bsdstats.new /var/db/bsdstats
(( ok )) || print some failures occured, check /var/log/messages, tag bsdstats
print "done, used token from $stats_token_time" \
    "($(timet2date $stats_token_time))"
return 0
