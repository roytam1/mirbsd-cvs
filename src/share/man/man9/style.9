.\" $MirOS: src/share/man/man9/style.9,v 1.25 2014/12/15 22:14:02 tg Exp $
.\"-
.\" Copyright (c) 2002-2015 The MirOS Project.
.\" Copyright (c) ? OpenBSD
.\" Copyright (c) 1995 FreeBSD Inc.
.\" All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL [your name] OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.\"	$OpenBSD: style.9,v 1.50 2008/11/14 13:42:05 tedu Exp $
.\"
.\"-
.\" Copyright (c) 2008, 2009, 2010
.\"	Thorsten “mirabilos” Glaser <tg@mirbsd.org>
.\"-
.\" Try to make GNU groff and AT&T nroff more compatible
.\" * ` generates ‘ in gnroff, so use \`
.\" * ' generates ’ in gnroff, \' generates ´, so use \*(aq
.\" * - generates ‐ in gnroff, \- generates −, so .tr it to -
.\"   thus use - for hyphens and \- for minus signs and option dashes
.\" * ~ is size-reduced and placed atop in groff, so use \*(TI
.\" * ^ is size-reduced and placed atop in groff, so use \*(ha
.\" * \(en does not work in nroff, so use \*(en
.\" * <>| are problematic, so redefine and use \*(Lt\*(Gt\*(Ba
.\" Also make sure to use \& especially with two-letter words.
.\" The section after the "doc" macropackage has been loaded contains
.\" additional code to convene between the UCB mdoc macropackage (and
.\" its variant as BSD mdoc in groff) and the GNU mdoc macropackage.
.\"
.ie \n(.g \{\
.	if \*[.T]ascii .tr \-\N'45'
.	if \*[.T]latin1 .tr \-\N'45'
.	if \*[.T]utf8 .tr \-\N'45'
.	ds <= \[<=]
.	ds >= \[>=]
.	ds Rq \[rq]
.	ds Lq \[lq]
.	ds sL \(aq
.	ds sR \(aq
.	if \*[.T]utf8 .ds sL `
.	if \*[.T]ps .ds sL `
.	if \*[.T]utf8 .ds sR '
.	if \*[.T]ps .ds sR '
.	ds aq \(aq
.	ds TI \(ti
.	ds ha \(ha
.	ds en \(en
.\}
.el \{\
.	ds aq '
.	ds TI ~
.	ds ha ^
.	ds en \(em
.\}
.\"
.\" Implement .Dd with the Mdocdate RCS keyword
.\"
.rn Dd xD
.de Dd
.ie \\$1$Mdocdate: \{\
.	xD \\$2 \\$3, \\$4
.\}
.el .xD \\$1 \\$2 \\$3 \\$4 \\$5 \\$6 \\$7 \\$8
..
.\"
.\" .Dd must come before definition of .Mx, because when called
.\" with -mandoc, it might implement .Mx itself, but we want to
.\" use our own definition. And .Dd must come *first*, always.
.\"
.Dd $Mdocdate: December 15 2014 $
.\"
.\" Check which macro package we use, and do other -mdoc setup.
.\"
.ie \n(.g \{\
.	if \*[.T]utf8 .tr \[la]\*(Lt
.	if \*[.T]utf8 .tr \[ra]\*(Gt
.	ie d volume-ds-1 .ds tT gnu
.	el .ds tT bsd
.\}
.el .ds tT ucb
.\"
.\" Implement .Mx (MirBSD)
.\"
.ie "\*(tT"gnu" \{\
.	eo
.	de Mx
.	nr curr-font \n[.f]
.	nr curr-size \n[.ps]
.	ds str-Mx \f[\n[curr-font]]\s[\n[curr-size]u]
.	ds str-Mx1 \*[Tn-font-size]\%MirOS\*[str-Mx]
.	if !\n[arg-limit] \
.	if \n[.$] \{\
.	ds macro-name Mx
.	parse-args \$@
.	\}
.	if (\n[arg-limit] > \n[arg-ptr]) \{\
.	nr arg-ptr +1
.	ie (\n[type\n[arg-ptr]] == 2) \
.	as str-Mx1 \~\*[arg\n[arg-ptr]]
.	el \
.	nr arg-ptr -1
.	\}
.	ds arg\n[arg-ptr] "\*[str-Mx1]
.	nr type\n[arg-ptr] 2
.	ds space\n[arg-ptr] "\*[space]
.	nr num-args (\n[arg-limit] - \n[arg-ptr])
.	nr arg-limit \n[arg-ptr]
.	if \n[num-args] \
.	parse-space-vector
.	print-recursive
..
.	ec
.	ds sP \s0
.	ds tN \*[Tn-font-size]
.\}
.el \{\
.	de Mx
.	nr cF \\n(.f
.	nr cZ \\n(.s
.	ds aa \&\f\\n(cF\s\\n(cZ
.	if \\n(aC==0 \{\
.		ie \\n(.$==0 \&MirOS\\*(aa
.		el .aV \\$1 \\$2 \\$3 \\$4 \\$5 \\$6 \\$7 \\$8 \\$9
.	\}
.	if \\n(aC>\\n(aP \{\
.		nr aP \\n(aP+1
.		ie \\n(C\\n(aP==2 \{\
.			as b1 \&MirOS\ #\&\\*(A\\n(aP\\*(aa
.			ie \\n(aC>\\n(aP \{\
.				nr aP \\n(aP+1
.				nR
.			\}
.			el .aZ
.		\}
.		el \{\
.			as b1 \&MirOS\\*(aa
.			nR
.		\}
.	\}
..
.\}
.\"-
.Dt STYLE 9
.Os
.Sh NAME
.Nm style
.Nd BSD style guide for C source code
.Sh DESCRIPTION
This manual page specifies the preferred style for C source files in the
.Mx
source tree.
For historical reasons, it's still called
.Dq Kernel source file style guide (KNF) ,
although it has been applied to userland code for almost forever.
These guidelines should be followed for all new code.
In general, code can be considered
.Dq new code
when it makes up about 50% or more of the file(s) involved.
This is enough to break precedents in the existing code and use the
current style guidelines.
.Bd -literal -offset indent
/*\-
 * Style guide for the MirOS Project's Coding Styles.
 * Derived from the OpenBSD KNF (Kernel Normal Form).
 * indent(1) does not reformat this comment.
 */

/**
 * This is a documentation comment in doxygen format.
 * clang \-Wcomment checks them for correct syntax.
 * Use only if you're honouring that standard.
 */

/*
 * VERY important single-line comments look like this.
 */

/* almost all small single-line comments look like this */
/* A few others are sentences, thus end with a full stop. */

/*
 * Multi-line comments look like this. Make them real sentences,
 * in contrast to single-line comments. Fill them so they look
 * like real paragraphs. indent(1) does reformat this comment.
 * (XXX: does it? It says slash+star+newline isn't reformatted.)
 * British spelling is preferred in general. Restrict yourself
 * to the CESU\-8 (UTF\-8) Unicode BMP subset or, preferably, the
 * ISO_646.irv:1991 7-bit character set (ANSI_X3.4\-1968). Units
 * are metric and conform to the SI; use ISO/IEC 60027\-2 binary
 * praefices for multiples of 1024 and SI praefices for 1000s.
 */
.Ed
.Pp
Kernel include files (i.e.,
.Aq Pa sys/*.h )
come first; normally, you'll need either
.Aq Pa sys/types.h
or
.Aq Pa sys/param.h ,
but not both!
.Aq Pa sys/param.h
includes
.Aq Pa sys/types.h ,
which in turn
includes
.Aq Pa sys/cdefs.h ,
and it's okay to depend on that.
Also, add
.Aq Pa sys/time.h
before the other system includes, but after
.Aq Pa sys/types.h .
Put non-local includes in brackets, local includes in double quotes.
.Bd -literal -offset indent
.if "\*(tT"gnu" .nr in-synopsis-section 1
.In sys/types.h
.if "\*(tT"gnu" .nr in-synopsis-section 0
.Ed
.Pp
Machine and device includes follow.
If it's a networked program, put the network include files next.
.Bd -literal -offset indent
.if "\*(tT"gnu" .nr in-synopsis-section 1
.In net/if.h
.In net/if_dl.h
.In net/route.h
.In netinet/in.h
.In protocols/rwhod.h
.if "\*(tT"gnu" .nr in-synopsis-section 0
.Ed
.Pp
Then there's an optional blank line, followed by the other files from
.Pa /usr/include .
The list of include files should be sorted by group, i.e.,
.Aq Pa sys/param.h
and
.Aq Pa sys/time.h
first, then all other system includes sorted,
then machine and device includes sorted (if possible),
then network includes sorted (if possible), then
.Pa /usr/include
files sorted, then local includes (also sorted if possible).
.Bd -literal -offset indent
.if "\*(tT"gnu" .nr in-synopsis-section 1
.In stdio.h
.if "\*(tT"gnu" .nr in-synopsis-section 0
.Ed
.Pp
Global pathnames are defined in
.Aq Pa paths.h .
Pathnames local to the program go in
.Dq Pa pathnames.h
in the local directory.
.Bd -literal -offset indent
.if "\*(tT"gnu" .nr in-synopsis-section 1
.In paths.h
.if "\*(tT"gnu" .nr in-synopsis-section 0
.Ed
.Pp
Then there's a mandatory blank line, and the user include files.
.Bd -literal -offset indent
.ie "\*(tT"gnu" \{\
.	nr curr-font \n[.f]
.	nr curr-size \n[.ps]
.	nop \*[Fd-font]#include "pathnames.h"
.	ft \n[curr-font]
.	ps \n[curr-size]u
.\}
.el \{\
.	nr cF \n(.f
.	nr cZ \n(.s
.	fI
\&\*(fD#include "pathnames.h"
.	br
.	ft \n(cF
.	fs \n(cZ
.\}
.Ed
.Pp
The includes block is separated by another blank line from the file
identification block.
Add the CVS (or RCS) ID(s) of the file and, if taking over old source code,
the SCCS ID and __COPYRIGHT as well; place another blank line after that.
It is discouraged listing RCS IDs as comments at the beginning of
files if it's possible (this excludes most header files, although some
use a technique to define their ID to a macro which is expanded by the
main source file or somesuch) to use
these macros; copy them over, the macros are safe to be used more
than once in the same file in
.Mx .
Note that this may introduce CVS branch merge conflicts.
These three macros are defined in
.Aq Pa sys/cdefs.h :
.Bd -literal -offset indent
__COPYRIGHT("@(#) Copyright (c) 1989, 1993\en\e
	The Regents [...] reserved.\en");
__SCCSID("@(#)cat.c	8.2 (Berkeley) 4/27/95");
__RCSID("$Mir\&OS: src/bin/cat/cat.c,v [...] Exp $");
.Ed
.Pp
All functions are prototyped somewhere.
.Pp
Function prototypes for private functions (i.e., functions not used
elsewhere) go at the top of the first source module.
In userland, functions local to one source module should be declared
.Ql static .
This should not be done in kernel land since it makes it almost
impossible to use the kernel debugger.
.Pp
Functions used from other parts of the kernel are prototyped in the
relevant include file.
It is strongly recommended that include files do not include other
header files.
Document interdependencies in the relevant manual pages.
.Pp
Functions that are used locally in more than one module go into a
separate header file, e.g.,
.Dq Pa extern.h .
This file is allowed to precede the, otherwise sorted, list of
local include files.
Do not use the same names as other well-known header files, such
as these in
.Pa /usr/include ,
used by library dependencies or part of other applications that
are often pulled in by the
.Xr make 1
.Dq .PATH
command.
.Pp
Use of the
.Li __P
macro has been deprecated.
It is allowed in code imported from other sources but should not be
used in native
.Mx
code.
Only write out prototypes with full variable names in manual pages;
in all other files, prototypes should not have variable names
associated with the types (this is what manpages are for); i.e., use:
.Bd -literal -offset indent
void function(int);
.Ed
not:
.Bd -literal -offset indent -compact
void function(int a);
.Ed
.Pp
Lining up prototypes after type names is discouraged because it is
hard to maintain; use a single space.
If lining up (existing code), prototypes may have an extra space after
a tabulator to enable function names to line up:
.Bd -literal -offset indent
static char	*function(int, const char *);
static void	 usage(void);
.Ed
.Pp
Function or macro names and their argument list are never separated by a space.
.Pp
Use
.Li __dead
from
.Aq Pa sys/cdefs.h
for functions that don't return, i.e.,
.Bd -literal -offset indent
__dead void abort(void);
void usage(int) __dead;
.Ed
.Pp
Use gcc attributes extensively to catch programming errors, e.g.,
.Bd -literal -offset indent
/* one line per function attribute */
wchar_t *ambsntowcs(const char *, size_t)
    __attribute__((__nonnull__(1)))
    __attribute__((__bounded__(__string__, 1, 2)));
/* use of an argument mandated by function pointer API */
static int x_del_char(int __unused);
/* macro evaluating its argument twice */
#define DOUBLE(x) __extension__({		\e
	__typeof__(x) DOUBLE_x = (x);		\e
	   					\e
	(DOUBLE_x + DOUBLE_x);			\e
})
.Ed
.Pp
In header files, put function prototypes within matching pairs of
.Dv __BEGIN_DECLS / __END_DECLS .
This makes the header file usable from languages like C++.
.Pp
Labels start at the second column, i.e. are prefixed with only a single
space (ASCII 20 hex) character, no matter which block they are in.
.Pp
Macros are capitalised and parenthesised and should avoid side-effects.
If they are an inline expansion of a function, the function is defined
all in lowercase; the macro has the same name all in uppercase.
In rare cases, function-like macros that evaluate their arguments only
once are allowed to be treated like real functions and use lowercase.
If the macro needs more than a single line, use braces.
Right-justify the backslashes, as the resulting definition is easier to read.
Use a single space after the
.Li \&#define
.Xr cpp 1
command and, except if lining up single-line macros, after the macro
name or closing parentheses.
If the macro encapsulates a compound statement, enclose it in a
.Dq Li do
loop,
so that it can safely be used in
.Dq Li if
statements, like shown below.
Do not forget the
.Li CONSTCOND
.Xr lint 1
command.
Any final statement-terminating semicolon shall be
supplied by the macro invocation rather than the macro, to make parsing easier
for pretty-printers and editors.
.Bd -literal -offset indent
#define MACRO(x, y) do {					\e
	variable = (x) + (y);					\e
	(y) += 2;						\e
} while (/* CONSTCOND */ 0)
.Ed
.Pp
Enumeration values are all uppercase.
.Bd -literal -offset indent
enum enumtype {
	ONE,
	TWO
} et;
.Ed
.Pp
When declaring variables in structures, declare them sorted by use, then
by size (largest to smallest), then by alphabetical order.
You may attempt to optimise for structure padding to avoid wasting space.
The first category normally doesn't apply, but there are exceptions.
Each one gets its own line.
It is strongly recommended to not line them up either.
Use single spaces, but line up the comments if desirable or,
better, place them on their own lines just before the item
they apply to.
.Pp
Major structures should be declared at the top of the file in which they
are used, or in separate header files if they are used in multiple
source files.
Use of the structures should be by separate declarations and should be
.Dq Li extern
if they are declared in a header file.
.Bd -literal -offset indent
struct foo {
	struct foo *next;	/* list of active foo */
	struct mumble amumble;	/* comment for mumble */
	int bar;
};
struct foo *foohead;		/* head of global foo list */
.Ed
.Pp
Use
.Xr queue 3
and
.Xr tree 3
macros rather than rolling your own lists whenever possible.
Thus, the previous example would be better written:
.Bd -literal -offset indent
.if "\*(tT"gnu" .nr in-synopsis-section 1
.In sys/queue.h
.if "\*(tT"gnu" .nr in-synopsis-section 0

struct foo {
	/* queue glue for foo lists */
	LIST_ENTRY(foo) link;;
	/* comment for mumble */
	struct mumble amumble;
	int bar;
};
/* head of global foo list */
LIST_HEAD(, foo) foohead;
.Ed
.Pp
Avoid using typedefs for structure types.
This makes it impossible
for applications to use pointers to such a structure opaquely, which
is both possible and beneficial when using an ordinary struct tag.
When convention requires a typedef, make its name match the struct tag.
Avoid typedefs ending in
.Dq Li \&_t ,
except as specified in Standard C or by
.Tn POSIX ,
such as
.Dq Li uint32_t
(which requires
.Aq Pa stdint.h ,
or its superset
.Aq Pa inttypes.h ) .
Don't use the same name for a struct tag and a typedef, as this makes
the code unusable from C++.
.Bd -literal -offset indent
/* make the structure name match the typedef */
typedef struct _bar {
	int level;
} BAR;
.Ed
.Bd -literal -offset indent
/*
 * All major routines should have a comment briefly describing
 * what they do. The comment before the "main" routine should
 * describe what the program does.
 */
int
main(int argc, char *argv[])
{
	int aflag, bflag, ch, num;
	const char *errstr;
.Ed
.Pp
For consistency,
.Xr getopt 3
should be used to parse options.
Options should be sorted in the manual page
.Sx SYNOPSIS
and
.Sx DESCRIPTION ,
any
.Fn usage
or similar function, the
.Xr getopt 3
call and the switch statement, unless
parts of the switch cascade.
Elements in a switch statement that cascade should have a FALLTHROUGH comment.
Numerical arguments should be checked for accuracy.
Code that cannot be reached should have a NOTREACHED comment.
The CONSTCOND, FALLTHROUGH, and NOTREACHED comments benefit lint.
.Bd -literal -offset indent
while ((ch = getopt(argc, argv, "abn:")) != \-1)
	switch (ch) {		/* indent the switch */
	case \*(aqa\*(aq:		/* don't indent the case */
		aflag = 1;
		/* FALLTHROUGH */
	case \*(aqb\*(aq:
		bflag = 1;
		break;
	case \*(aqn\*(aq:
		num = strtonum(optarg, 0, INT_MAX, &errstr);
		if (errstr) {
			warnx("number is %s: %s", errstr, optarg);
			usage();
		}
		break;
	case \*(aq?\*(aq:		/* redundant here but ok */
	default:
		usage();
		/* NOTREACHED */
	}
argc \-= optind;
argv += optind;
.Ed
.Pp
Cast expressions and the value to be casted are never separated by a
space; use parentheses about the latter if it's a compound expression.
Use a space after keywords
.Pf ( Li if ,
.Li while ,
.Li for ,
.Li return ,
.Li switch )
but not unary operators like
.Li sizeof ,
.Li typeof ,
.Li alignof ,
or function-like constructs like GCC attributes (see above).
It is recommended to put parentheses around the
.Li return
argument as well, although this is not a strict requirement.
It helps when debugging (define
.Li return
to a debug expression) though, except for void functions.
.Pp
No braces are used for control statements with zero or only a single
statement, unless that statement is more than a single line (in which
case they are permitted), it contains a comment (in which case they
are recommended), or it contains a label (in which case they are mandated).
A separate project may choose to mandate braces for all cases.
Always document single-semicolon bodies with a comment; here, same line is ok.
.Bd -literal -offset indent
for (p = buf; *p != \*(aq\e0\*(aq; ++p)
	;	/* nothing */
while (/* CONSTCOND */ 1)	/* or: for (;;) */
	stmt;
while (/* CONSTCOND */ 1) {
	z = a + really + long + statement + that + needs +
	    two + lines + gets + indented + four + spaces +
	    on + the + second + and + subsequent + lines;
}
while (/* CONSTCOND */ 1) {
	if (cond)
		stmt;
}
if (cond) {
	/* comment */
 somelabel:
	stmt;
}
.Ed
.Pp
Parts of a for loop may be left empty, although while loops
are preferable especially in such cases.
Don't put declarations inside blocks unless the routine is
unusually complicated.
.Bd -literal -offset indent
for (; cnt \*(Lt 15; cnt++) {
	stmt1;
	stmt2;
}
.Ed
.Pp
Indentation is an 8 character tab.
Second level indents are four spaces.
.Bd -literal -offset indent
while (cnt \*(Lt 20)
	z = a + really + long + statement + that + needs +
	    two + lines + gets + indented + four + spaces +
	    on + the + second + and + subsequent + lines;
.Ed
.Pp
Do not add whitespace at the end of a line, and only use tabs
followed by spaces to form the indentation.
Never use more spaces than a tab will produce
and do not use spaces in front of tabs.
.Nm vim
users are
.Em required
to put
.Dq Li let c_space_errors = 1
into their
.Pa \*(TI/.vimrc .
.Pp
Closing and opening braces go on the same line as the else.
Braces that aren't necessary may be left out, unless they cause
a compiler warning.
.Bd -literal -offset indent
if (test)
	stmt;
else if (bar != NULL) {
	stmt;
	stmt;
} else
	stmt;
.Ed
.Pp
Avoid doing multiple assignments in one statement, like this:
.Bd -literal -offset indent
/* bad example */
if (foo) {
	stmt;
	stmt;
} else if (bad)
	*wp++ = QCHAR, *wp++ = c;
else
	stmt;

/* write this as */
if (foo) {
	stmt;
	stmt;
} else if (good) {
	*wp++ = QCHAR;
	*wp++ = c;
} else
	stmt;
.Ed
.Pp
Do not use spaces after function names.
Commas have a space after them.
Do not use spaces after
.Sq \&(
or
.Sq \&[
or preceding
.Sq \&]
or
.Sq \&)
characters.
.Bd -literal -offset indent
if ((error = function(a1, a2)))
	exit(error);
.Ed
.Pp
Use positive error codes.
Negative errors (except \-1) are something only the Other OS does.
.Pp
Unary operators don't require spaces; binary operators do.
Don't use parentheses unless they're required for precedence, the statement
is confusing without them, or the compiler generates a warning without them.
Remember that other people may be confused more easily than you.
Do YOU understand the following?
.Bd -literal -offset indent
a = b\-\*(Gtc[0] + \*(TId == (e \*(Ba\*(Ba f) \*(Ba\*(Ba g && h ? i : j \*(Gt\*(Gt 1;
k = !(l & FLAGS);
.Ed
.Pp
It's much better to break after an operator if you need to apply line breaks.
This is especially true for shell scripts.
The above example could be rewritten as:
.Bd -literal -offset indent
a = (((b\-\*(Gtc[0] + \*(TId) == (e \*(Ba\*(Ba f)) \*(Ba\*(Ba (g && h)) ? \e
    i : (j \*(Gt\*(Gt 1);
k = !(l &
    FLAGS);
.Ed
.Pp
Lines ought to be not larger than 80 characters.
Stick to 75 characters or less if possible, but in some cases
it's ok to put a character in the 80th column.
Descriptions should not be longer than 66 characters,
eMails must not be longer then 72 characters per line.
In object-oriented languages, it may be acceptable to use
up to 100 characters per line.
.Pp
Exits and returns should be 0 on success, and non-zero for errors.
.Bd -literal -offset indent
	/*
	 * avoid obvious comments such as
	 * "Exit 0 on success."
	 */
	exit(0);
}
.Ed
.Pp
The function type should be on a line by itself
preceding the function.
This eases searching for a function implementation:
.Pp
.Li $ grep \-r \*(aq\*(hafunction\*(aq \&.
.Bd -literal -offset indent
static char *
function(int a1, int a2, float fl, int a4)
{
.Ed
.Pp
When declaring variables in functions, declare them sorted by size (largest to
smallest), then in alphabetical order; multiple ones per line are okay.
If a line overflows, reuse the type keyword.
Declarations must follow
.St -ansiC-89 .
.Pp
Be careful not to obfuscate the code by initialising variables in
the declarations.
Use this feature only thoughtfully.
DO NOT use function calls in initialisers!
.Bd -literal -offset indent
struct foo one, *two;
double three;
int *four, five;
char *six, seven, eight, nine, ten, eleven, twelve;

four = myfunction();
.Ed
.Pp
Do not declare functions inside other functions: ANSI C says that
such declarations have file scope regardless of the nesting of the
declaration.
.Pp
Note that
.Xr indent 1
comes with a sample
.Pa .indent.pro
which understands most of these rules, starting from
.Mx 9 .
As of
.Mx 11 ,
it will also be installed into the user home skeleton directory.
.Pp
Use of the
.Dq register
specifier is discouraged in new code.
Optimising compilers such as gcc can generally do a better job
of choosing which variables to place in registers to improve
code performance.
The exception to this is in functions containing assembly code where the
.Dq register
specifier is required for proper code generation in the absence of
compiler optimisation.
.Pp
When using
.Fn longjmp
or
.Fn vfork
in a program, the
.Fl Wextra
or
.Fl Wall
flag should be used to verify that the compiler does not generate
warnings such as
.Bd -literal -offset indent
warning: variable `foo' might be clobbered by `longjmp' or `vfork'.
.Ed
.Pp
If any warnings of this type occur, you must apply the
.Dq volatile
type-qualifier to the variable in question.
Failure to do so may result in improper code generation when optimisation
is enabled.
Note that for pointers, the location of
.Dq volatile
specifies if the type-qualifier applies to the pointer or the thing being
pointed to.
A volatile pointer is declared with
an optional extra space and
.Dq volatile
to the right of the
.Dq * .
Example:
.Bd -literal -offset indent
char * volatile foo;
.Ed
.Pp
says that
.Dq foo
is volatile, but
.Dq *foo
is not.
To make
.Dq *foo
.Pq the thing being pointed to
volatile use the syntax
.Bd -literal -offset indent
volatile char *foo;
.Ed
.Pp
If both the pointer and the thing pointed to are volatile use
.Bd -literal -offset indent
volatile char * volatile foo;
.Ed
.Pp
.Dq const
is also a type-qualifier and the same rules apply.
Assume string literals are constant.
Never make use of broken C APIs such as
.Xr strchr 3
to
.Dq cast away
the
.Dq const
qualifiers.
The description of a read-only hardware register might look something like:
.Bd -literal -offset indent
const volatile char *reg;
.Ed
.Pp
Global flags set inside signal handlers should be of type
.Dq volatile sig_atomic_t
if possible.
This guarantees that the variable may be accessed as an atomic entity,
even when a signal has been delivered.
Global variables of other types (such as structures) are not
guaranteed to have consistent values when accessed via a signal handler.
.Pp
.Dv NULL
is the preferred null pointer constant.
Never use 0 in place of
.Dv NULL .
Use
.Dv NULL
instead of
(type\ *)0 or (type\ *)NULL in all cases except for arguments to variadic
functions where the compiler does not know the type.
.Pp
Don't use
.Ql \&!
for tests unless it's a boolean (or an integral flag used in a boolean
context, almost certainly with a bitwise AND operation, since otherwise
using a bool would be correct), i.e., use
.Bd -literal -offset indent
if (p != NULL && *p == \*(aq\e0\*(aq)
.Ed
not
.Bd -literal -offset indent -compact
if (p && !*p)
.Ed
.Pp
Use
.Aq Pa stdbool.h
for boolean values, not
.Vt int .
.Pp
Routines returning
.Li void *
should not have their return values cast to any pointer type.
Functions used as procedures should not have their return
value explicitly cast to void, either.
The exception are function-like macros like
.Xr sigaddset 3 ,
where failure to do so may result in compiler warnings
about unused LHS in comma operations.
.Pp
You can assume that pointers to variables and function pointers share the
same address space and have the same size as
.Vt ptrdiff_t .
.Pp
Use
.Xr err 3
or
.Xr warn 3 ,
don't roll your own!
.Bd -literal -offset indent
	if ((four = malloc(sizeof(struct foo))) == NULL)
		err(1, NULL);
	if ((six = (int *)overflow()) == NULL)
		errx(1, "Number overflowed.");
	return (eight);
}
.Ed
.Pp
Old-style function declarations looked like this:
.Bd -literal -offset indent
static char *
function(a1, a2, fl, a4)
    int a1, a2;	/* declare ints, too, don't default them */
    float fl;	/* beware double vs. float prototype differences */
    int a4;	/* list in order declared */
{
	...
}
.Ed
.Pp
You really ought to replace them with ANSI C function declarations.
Long parameter lists are wrapped with a normal four space indent.
.Pp
Variable numbers of arguments should look like this:
.Bd -literal -offset indent
.if "\*(tT"gnu" .nr in-synopsis-section 1
.In stdarg.h
.if "\*(tT"gnu" .nr in-synopsis-section 0

void vaf(const char *fmt, ...)
    __attribute__((__format__(__printf__, 1, 2)));

void
vaf(const char *fmt, ...)
{
	va_list ap;
	va_start(ap, fmt);

	STUFF;

	va_end(ap);

	/* No return needed for void functions. */
}

static void
usage(void)
{
	/* from crt0.o */
	extern const char *__progname;
.Ed
.Pp
Usage statements should take the same form as the synopsis in manual pages.
Options without
operands come first, in alphabetical order inside a single set of
braces, followed by options with operands, in alphabetical order,
each in braces, followed by required arguments in the order they
are specified, followed by optional arguments in the order they
are specified.
.Pp
A bar
.Pq Sq \*(Ba
separates either-or options/arguments,
and multiple options/arguments which are specified together are
placed in a single set of braces.
.Pp
If numbers are used as options, they should be placed first,
as shown in the example below.
Uppercase letters take precedence over lowercase.
Note that the options list in manual pages should be purely alphabetical,
except that the no-argument options are listed first.
.Bd -literal -offset indent
"usage: f [\-12aDde] [\-b barg] [\-m marg] req1 req2 [opt1 [opt2]]\en"
"usage: f [\-a \*(Ba \-b] [\-c [\-de] [\-n number]]\en"
.Ed
.Pp
The
.Li __progname
string may be used instead of hard-coding the program's name.
It's better to place the extern declaration outside of the
function body though, as it's file-global in ISO C either way,
and that makes this fact more visible.
.Bd -literal -offset indent
	fprintf(stderr, "usage: %s [\-ab]\en", __progname);
	exit(1);
}
.Ed
.Pp
New core kernel code should be reasonably compliant with the style guides.
The guidelines for third-party maintained modules and device drivers are more
relaxed but at a minimum should be internally consistent with their style;
the current MirPorts Framework package tools are a bad example of style
inconsistency (such as three different indentation styles: three spaces, four
spaces and KNF one tab) and a good example of why it must be prevented.
.Pp
Whenever possible, code should be run through at least one code checker
(e.g.,
.Dq Li gcc \-Wall \-W \-Wpointer\-arith \-Wbad\-function\-cast ... ,
.Dq Li make __CRAZY=Yes ,
.Xr lint 1
or splint from the ports tree) and produce minimal warnings.
Try to write source code that will compile without
any warnings, failures or malfunctions with gcc3
.Fl Os std=c99 Wbounded ,
pcc
.Fl O ,
SUNWcc, and gcc4
.Fl O2 fwrapv std=c99 Wformat .
Do try to keep code working with gcc3
.Fl std=c89 ,
possibly with support for
.Vt long long int .
.Pp
Note that documentation follows its own style guide,
as documented in
.Xr mdoc.samples 7 .
This however does not invalidate the hints given in this guide.
Shell scripts also follow what is applicable from this guide, except that
function declarations are all on one line; use Korn syntax throughoutly;
never use the \` character; it is okay to use reasonably recent
.Xr mksh 1
extensions.
Do not use the
.Ic typeset
built-in command, always write
.Ic local
instead.
.Bd -literal -offset indent
function bla {
	(( x )) && foo=abcdefghijklmnopqrstuvwxyz$(fnord \e
	    ABCDEFGHIJKLMNOPQRSTUVWXYZ)
	[[ $foo = @([a\-z_]*([a\-z0\-9_]) ]] \*(Ba\*(Ba exit 1
}
.Ed
.Sh FILES
.Bl -tag -width "/usr/share/misc/licence.template " -compact
.It Pa /usr/share/misc/licence.template
Licence preferred for new code.
.El
.Pp
.Pa \*(TI/.indent.pro
should contain at least the following items:
.Pp
.Fl c0
.Fl ci4
.Fl di0
.Fl nbs
.Fl ncsp
.Fl nfc1
.Fl nlp
.Fl nlpi
.Fl Tbool
.Fl Tint16_t
.Fl Tint32_t
.Fl Tint64_t
.Fl Tint8_t
.Fl Tintmax_t
.Fl Tintptr_t
.Fl Tmbstate_t
.Fl Toff_t
.Fl Tptrdiff_t
.Fl Tsize_t
.Fl Tssize_t
.Fl Ttime_t
.Fl Tuint16_t
.Fl Tuint32_t
.Fl Tuint64_t
.Fl Tuint8_t
.Fl Tuintmax_t
.Fl Tuintptr_t
.Fl Twchar_t
.Fl Twint_t
and a bunch of others.
Note that the
.Fl c0
option might be problematic for existing code and may be better left out.
.Pa mircvs://src/usr.bin/indent/.indent.pro
contains a more complete list; even then,
.Xr indent 1
does only basic help to apply KNF.
.Sh SEE ALSO
.Xr indent 1 ,
.Xr lint 1 ,
.Xr err 3 ,
.Xr queue 3 ,
.Xr warn 3 ,
.Xr mdoc.samples 7
.Sh HISTORY
This man page is largely based on the src/admin/style/style file from
the
.Tn BSD
4.4-Lite2 release, with updates to reflect the current practice and
desire first of the
.Ox
project, then for the
.Mx
source tree, including an improved Open Source licence.
