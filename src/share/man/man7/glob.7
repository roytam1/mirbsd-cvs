.\"	$MirOS$
.\"	$OpenBSD: glob.7,v 1.3 2009/12/26 15:24:54 schwarze Exp $
.\"
.\" Copyright (c) 2009 Todd C. Miller <Todd.Miller@courtesan.com>
.\"
.\" Permission to use, copy, modify, and distribute this software for any
.\" purpose with or without fee is hereby granted, provided that the above
.\" copyright notice and this permission notice appear in all copies.
.\"
.\" THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
.\" WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
.\" MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
.\" ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
.\" WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
.\" ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
.\" OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
.\"-
.\" Copyright (c) 2008, 2009, 2010, 2013
.\"	Thorsten “mirabilos” Glaser <tg@mirbsd.org>
.\"-
.\" Try to make GNU groff and AT&T nroff more compatible
.\" * ` generates ‘ in gnroff, so use \`
.\" * ' generates ’ in gnroff, \' generates ´, so use \*(aq
.\" * - generates ‐ in gnroff, \- generates −, so .tr it to -
.\"   thus use - for hyphens and \- for minus signs and option dashes
.\" * ~ is size-reduced and placed atop in groff, so use \*(TI
.\" * ^ is size-reduced and placed atop in groff, so use \*(ha
.\" * \(en does not work in nroff, so use \*(en
.\" * <>| are problematic, so redefine and use \*(Lt\*(Gt\*(Ba
.\" Also make sure to use \& especially with two-letter words.
.\" The section after the "doc" macropackage has been loaded contains
.\" additional code to convene between the UCB mdoc macropackage (and
.\" its variant as BSD mdoc in groff) and the GNU mdoc macropackage.
.\"
.ie \n(.g \{\
.	if \*[.T]ascii .tr \-\N'45'
.	if \*[.T]latin1 .tr \-\N'45'
.	if \*[.T]utf8 .tr \-\N'45'
.	ds <= \[<=]
.	ds >= \[>=]
.	ds Rq \[rq]
.	ds Lq \[lq]
.	ds sL \(aq
.	ds sR \(aq
.	if \*[.T]utf8 .ds sL `
.	if \*[.T]ps .ds sL `
.	if \*[.T]utf8 .ds sR '
.	if \*[.T]ps .ds sR '
.	ds aq \(aq
.	ds TI \(ti
.	ds ha \(ha
.	ds en \(en
.\}
.el \{\
.	ds aq '
.	ds TI ~
.	ds ha ^
.	ds en \(em
.\}
.\"
.\" Implement .Dd with the Mdocdate RCS keyword
.\"
.rn Dd xD
.de Dd
.ie \\$1$Mdocdate: \{\
.	xD \\$2 \\$3, \\$4
.\}
.el .xD \\$1 \\$2 \\$3 \\$4 \\$5 \\$6 \\$7 \\$8
..
.\"
.\" .Dd must come before definition of .Mx, because when called
.\" with -mandoc, it might implement .Mx itself, but we want to
.\" use our own definition. And .Dd must come *first*, always.
.\"
.Dd $Mdocdate: March 15 2010 $
.\"
.\" Check which macro package we use, and do other -mdoc setup.
.\"
.ie \n(.g \{\
.	if \*[.T]utf8 .tr \[la]\*(Lt
.	if \*[.T]utf8 .tr \[ra]\*(Gt
.	ie d volume-ds-1 .ds tT gnu
.	el .ds tT bsd
.\}
.el .ds tT ucb
.\"
.\" Implement .Mx (MirBSD)
.\"
.ie "\*(tT"gnu" \{\
.	eo
.	de Mx
.	nr curr-font \n[.f]
.	nr curr-size \n[.ps]
.	ds str-Mx \f[\n[curr-font]]\s[\n[curr-size]u]
.	ds str-Mx1 \*[Tn-font-size]\%MirOS\*[str-Mx]
.	if !\n[arg-limit] \
.	if \n[.$] \{\
.	ds macro-name Mx
.	parse-args \$@
.	\}
.	if (\n[arg-limit] > \n[arg-ptr]) \{\
.	nr arg-ptr +1
.	ie (\n[type\n[arg-ptr]] == 2) \
.	as str-Mx1 \~\*[arg\n[arg-ptr]]
.	el \
.	nr arg-ptr -1
.	\}
.	ds arg\n[arg-ptr] "\*[str-Mx1]
.	nr type\n[arg-ptr] 2
.	ds space\n[arg-ptr] "\*[space]
.	nr num-args (\n[arg-limit] - \n[arg-ptr])
.	nr arg-limit \n[arg-ptr]
.	if \n[num-args] \
.	parse-space-vector
.	print-recursive
..
.	ec
.	ds sP \s0
.	ds tN \*[Tn-font-size]
.\}
.el \{\
.	de Mx
.	nr cF \\n(.f
.	nr cZ \\n(.s
.	ds aa \&\f\\n(cF\s\\n(cZ
.	if \\n(aC==0 \{\
.		ie \\n(.$==0 \&MirOS\\*(aa
.		el .aV \\$1 \\$2 \\$3 \\$4 \\$5 \\$6 \\$7 \\$8 \\$9
.	\}
.	if \\n(aC>\\n(aP \{\
.		nr aP \\n(aP+1
.		ie \\n(C\\n(aP==2 \{\
.			as b1 \&MirOS\ #\&\\*(A\\n(aP\\*(aa
.			ie \\n(aC>\\n(aP \{\
.				nr aP \\n(aP+1
.				nR
.			\}
.			el .aZ
.		\}
.		el \{\
.			as b1 \&MirOS\\*(aa
.			nR
.		\}
.	\}
..
.\}
.\"-
.Dt GLOB 7
.Os
.Sh NAME
.Nm glob
.Nd shell-style pattern matching
.Sh DESCRIPTION
Globbing characters
.Pq wildcards
are special characters used to perform pattern matching of pathnames and
command arguments in the
.Xr mksh 1 ,
.Xr csh 1 ,
and
.Xr sh 1
shells as well as
the C library functions
.Xr fnmatch 3
and
.Xr glob 3 .
A glob pattern is a word containing one or more unquoted
.Ql \&?
or
.Ql *
characters, or
.Dq [..]
sequences.
.Pp
Globs should not be confused with the more powerful
regular expressions used by programs such as
.Xr grep 1 .
While there is some overlap in the special characters used in regular
expressions and globs, their meaning is different.
.Pp
The pattern elements have the following meaning:
.Bl -tag -width Ds
.It \&?
Matches any single character.
.It \&*
Matches any sequence of zero or more characters.
.It [..]
Matches any of the characters inside the brackets.
Ranges of characters can be specified by separating two characters by a
.Ql \-
(e.g.\&
.Dq [a0\-9]
matches the letter
.Sq a
or any digit).
In order to represent itself, a
.Ql \-
must either be quoted or the first or last character in the character list.
Similarly, a
.Ql \&]
must be quoted or the first character in the list if it is to represent itself
instead of the end of the list.
Also, a
.Ql \&!
appearing at the start of the list has special meaning (see below), so to
represent itself it must be quoted or appear later in the list.
.Pp
Within a bracket expression, the name of a
.Em character class
enclosed in
.Sq [:
and
.Sq :]
stands for the list of all characters belonging to that class.
Supported character classes:
.Bl -column "xdigit" "xdigit" "xdigit" -offset indent
.It Li "alnum" Ta "cntrl" Ta "lower" Ta "space"
.It Li "alpha" Ta "digit" Ta "print" Ta "upper"
.It Li "blank" Ta "graph" Ta "punct" Ta "xdigit"
.El
.Pp
These match characters using the macros specified in
.Xr ctype 3 .
A character class may not be used as an endpoint of a range.
.Pp
Note that character classes may not be universally supported.
.It [!..]
Like [..],
except it matches any character not inside the brackets.
.It \e
Matches the character following it verbatim.
This is useful to quote the special characters
.Ql \&? ,
.Ql \&* ,
.Ql \&[ ,
and
.Ql \e
such that they lose their special meaning.
For example, the pattern
.Dq \e\e\e\&*\e[x]\e\&?
matches the string
.Dq \e\&*[x]\&? .
.El
.Pp
Note that when matching a pathname, the path separator
.Ql / ,
is not matched by a
.Ql \&? ,
or
.Ql * ,
character or by a
.Dq [..]
sequence.
Thus,
.Pa /usr/*/*/X11
would match
.Pa /usr/X11R6/lib/X11
and
.Pa /usr/X11R6/include/X11
while
.Pa /usr/*/X11
would not match either.
Likewise,
.Pa /usr/*/bin
would match
.Pa /usr/local/bin
but not
.Pa /usr/bin .
.Sh SEE ALSO
.Xr fnmatch 3 ,
.Xr glob 3 ,
.Xr re_format 7
.Sh HISTORY
In early versions of
.Ux ,
the shell did not do pattern expansion itself.
A dedicated program,
.Pa /etc/glob ,
was used to perform the expansion and pass the results to a command.
In
.At v7 ,
with the introduction of the Bourne shell,
this functionality was incorporated into the shell itself.
