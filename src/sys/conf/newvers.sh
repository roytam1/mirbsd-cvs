#!/bin/mksh
# $MirOS: src/sys/conf/newvers.sh,v 1.20 2010/09/19 10:55:48 tg Exp $
#-
# Copyright (c) 2003, 2004, 2005, 2006, 2008, 2010, 2012
#	Thorsten Glaser <tg@mirbsd.de>
#
# Provided that these terms and disclaimer and all copyright notices
# are retained or reproduced in an accompanying document, permission
# is granted to deal in this work without restriction, including un-
# limited rights to use, publicly perform, distribute, sell, modify,
# merge, give away, or sublicence.
#
# This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
# the utmost extent permitted by applicable law, neither express nor
# implied; without malicious intent or gross negligence. In no event
# may a licensor, author or contributor be held liable for indirect,
# direct, other damage, loss, or other issues arising in any way out
# of dealing in the work, even if advised of the possibility of such
# damage or existence of a defect, except proven that it results out
# of said person's immediate fault when using the work as intended.
#-
# Kernel version generation script
# Called with: MirBSD major minor level openbsdlevel
#
# List of files to check for version number bumps:
#	sys/sys/param.h, share/mk/sys.mk
#	share/tmac/mdoc/doc-{common,syms}
#	share/tmac/tmac.an.old

# MirBSD version cycle calculation
typeset -i     "_osrmj=${1:-9}"	# Major MirBSD revision number fallback
typeset -Uui16 "_osrmn=${2:-0}"	# only update the above once per release!
if (( _osrmn < 0 || _osrmn > 255 || _osrmj < 7 )); then
	print -u2 "Error: versioning information damaged!"
	exit 1
fi
let _osrmx=0
if ((_osrmn < 16)); then
	_osrtc="?"	# <unknown/damaged>
elif ((_osrmn < 128)); then
	_osrtc="n"	# nearly
elif ((_osrmn == 128)); then
	_osrtc="r"	# released
elif ((_osrmn < 160)); then
	_osrtc="s"	# stable
	let _osrmx=_osrmn-128
else
	_osrtc="u"	# unlocked
fi
if ((_osrmx < 1)); then
	_osrex=""	# regular release/snapshot/local build (-semel)
else			# released for the second, third... time
	case $_osrmx {
	(2)	_osrex=bis		;;
	(4)	_osrex=ter		;;
	(6)	_osrex=quater		;;
	(8)	_osrex=quinquies	;;
	(*)	_osrex=num.$((_osrmx / 2 + 1))ies ;;
	}
	(( (_osrmx % 2) == 1 )) && _osrex=-stable
	(( _osrmn == 159 )) && _osrex=-final
fi
onmj="${_osrmn#16#}$_osrex"
osl="${_osrmj}${_osrtc}${onmj}"

# Everything else
[[ -s version ]] || print 0 >version
touch version
let "wv=$(<version)"

if [[ $4 = +([0-9]).+([0-9]) ]]; then
	osc=" from OpenBSD $4"
else
	osc=
fi
ost="$(uname)"
tm="$(date)"
wd="$(pwd)"
wh="$(hostname)"
wk="$(basename "$wd")"
wt="$(TZ=UTC date '+%Y%m%d')"
wu="$(id -un 2>/dev/null)" || wu=root
myname="$(cd $(dirname "$0"); print -r "$(pwd)/$(basename "$0")")"


# arc4random(3) in Pure mkshâ„¢
set -A seedbuf -- $(dd if=/dev/arandom bs=277 count=1 2>&- | \
    hexdump -ve '1/1 "0x%02X "')
set -A rs_S
typeset -i rs_S rs_i=-1 rs_j=0 n
while (( ++rs_i < 256 )); do
	(( rs_S[rs_i] = rs_i ))
done
rs_i=-1
while (( ++rs_i < 256 )); do
	(( n = rs_S[rs_i] ))
	(( rs_j = (rs_j + n + seedbuf[rs_i]) & 0xFF ))
	(( rs_S[rs_i] = rs_S[rs_j] ))
	(( rs_S[rs_j] = n ))
done
rs_i=0
rs_j=0
typeset -i rs_out
function arcfour_byte {
	typeset -i si sj

	(( rs_i = (rs_i + 1) & 0xFF ))
	(( si = rs_S[rs_i] ))
	(( rs_j = (rs_j + si) & 0xFF ))
	(( sj = rs_S[rs_j] ))
	(( rs_S[rs_i] = sj ))
	(( rs_S[rs_j] = si ))
	(( rs_out = rs_S[(si + sj) & 0xFF] ))
}
(( n = 256 * 12 + seedbuf[256] + (RANDOM & 0xFF) ))
while (( n-- )); do
	arcfour_byte
done
(( n = rs_out ))
while (( n-- )); do
	arcfour_byte
done

(( irandseed = ((rs_out + (
    (seedbuf[257] << 24) | (seedbuf[258] << 16) |
    (seedbuf[259] << 8) | seedbuf[260])) | 1) & 0x7FFFFFFF ))


(cat <<EOF
/* Automatically generated by $myname - Do not edit. */

#include <sys/types.h>
#include <sys/slibkern.h>

const char ostype[]="$ost";
const char osrelease[]="$_osrmj";
const char ospatchlevel[]="#${osl}-$wt";
const char osversion[]="${wk}#$wv";
const char sccs[]=
    "	@(#)$ost $_osrmj rev.${onmj}${osc} ($wk) #${wv}: ${tm}\n";
const char version[]=
    "${ost}#$osl ($wk) #${wv}: ${tm}\n\t${wu}@${wh}:${wd}\n";

uint32_t _randseed = ${irandseed};
unsigned char initial_entropy[16] = {
EOF
typeset -Uui16 -Z5 seedbuf rs_S rs_i rs_j
n=260
print -n '\t'
while (( ++n < 277 )); do
	print -n 0x${seedbuf[n]#16#}
	(( n == 276 )) || print -n ', '
done
print '\n};'
print -n 'struct arcfour_status initial_arc4random = {\n\t{'
n=-1
while (( ++n < 256 )); do
	if (( n & 15 )); then
		print -n ' '
	else
		print -n '\n\t\t'
	fi
	print -n 0x${rs_S[n]#16#}
	(( n == 255 )) || print -n ,
done
print '\n\t},' 0x${rs_i#16#}, 0x${rs_j#16#}
print '};'
) >vers.c

print $((wv + 1)) >version
