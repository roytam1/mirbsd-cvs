#!/usr/bin/env mksh
# $MirOS: src/sys/arch/i386/stand/bootxx/mkbxinst.sh,v 1.4 2007/10/20 23:28:11 tg Exp $
# $miros: src/sys/arch/i386/stand/bootxx/mkbxinst.sh,v 1.4 2007/10/20 23:28:11 tg Exp $
#-
# Copyright (c) 2007
#	Thorsten Glaser <tg@mirbsd.de>
#
# Provided that these terms and disclaimer and all copyright notices
# are retained or reproduced in an accompanying document, permission
# is granted to deal in this work without restriction, including un-
# limited rights to use, publicly perform, distribute, sell, modify,
# merge, give away, or sublicence.
#
# This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
# the utmost extent permitted by applicable law, neither express nor
# implied; without malicious intent or gross negligence. In no event
# may a licensor, author or contributor be held liable for indirect,
# direct, other damage, loss, or other issues arising in any way out
# of dealing in the work, even if advised of the possibility of such
# damage or existence of a defect, except proven that it results out
# of said person's immediate fault when using the work as intended.
#-
# Self-installing i386 boot blocks for MirOS BSD
# Reads a list of extents (firstblock lastblock) from standard input
# and writes bootxx to standard output, which can subsequentially be
# stored as partition boot record (or floppy boot sector) on disc.

set -A thecode 0x66 0x31 0xC0 0x66 0x50 0x66 0x9D 0x05 0xC0 0x07 0x8E 0xD0 0xBC 0xFC 0xFF 0xFB 0x50 0x68 0x65 0x00 0x8E 0xD8 0x8E 0xC0 0xCB 0x30 0x41 0x31 0x38 0x20 0x4C 0x6F 0x61 0x64 0x69 0x6E 0x67 0x20 0x00 0x62 0x61 0x64 0x20 0x6D 0x61 0x67 0x69 0x63 0x20 0x45 0x52 0x52 0x0D 0x0A 0x00 0x74 0x0A 0x01 0x80 0x00 0x12 0x00 0x02 0x00 0xB4 0x0E 0xBB 0x07 0x00 0xCD 0x10 0xAC 0x08 0xC0 0x75 0xF4 0xC3 0xE8 0xF7 0xFF 0xB8 0x14 0x01 0x87 0x06 0x38 0x00 0x3D 0x14 0x01 0x75 0x43 0x30 0xE4 0xCD 0x16 0xEA 0xF0 0xFF 0x00 0xF0 0x88 0x16 0x3A 0x00 0xBE 0x19 0x00 0xE8 0xD8 0xFF 0xB8 0x14 0x01 0x86 0x3E 0x3D 0x00 0x80 0xE7 0x80 0x75 0x21 0x50 0xB4 0x02 0xCD 0x16 0x24 0x03 0x58 0x75 0x17 0xB4 0x41 0xBB 0xAA 0x55 0xCD 0x13 0xB8 0x2F 0x01 0x72 0x0B 0x81 0xFB 0x55 0xAA 0x75 0x05 0x80 0xE1 0x01 0x75 0x03 0xA3 0x38 0x00 0x31 0xFF 0xB8 0x10 0x00 0xAB 0x57 0xB8 0x12 0x40 0x8E 0xE0 0x50 0xBE 0x8A 0x01 0x8A 0x0E 0x37 0x00 0x66 0x31 0xC0 0xAC 0x5B 0x5F 0x57 0x88 0xC2 0xC0 0xEA 0x05 0x24 0x1F 0x40 0x42 0x66 0xAB 0x93 0xAB 0xC1 0xE3 0x05 0x01 0xC3 0x53 0x51 0xA4 0xFE 0xCA 0x75 0xFB 0x31 0xC0 0xAB 0xAB 0xAB 0xAB 0x8A 0x16 0x3A 0x00 0xFF 0x16 0x38 0x00 0x59 0xFE 0xC9 0x75 0xCD 0x0F 0xA0 0x51 0x66 0x64 0x81 0x3E 0x50 0x00 0x00 0x4F 0x6D 0x6A 0xBE 0x27 0x00 0x0F 0x85 0x53 0xFF 0xBE 0x34 0x00 0xE8 0x47 0xFF 0x8B 0x16 0x3A 0x00 0x64 0x88 0x36 0x50 0x00 0xCB 0x56 0xB4 0x42 0x31 0xF6 0xE8 0x45 0x00 0x5E 0xC3 0xB6 0x01 0x86 0x36 0x02 0x00 0x52 0xE8 0x11 0x00 0x5A 0xFE 0xCE 0x74 0xF0 0x83 0x06 0x06 0x00 0x20 0x66 0xFF 0x06 0x08 0x00 0xEB 0xEB 0x52 0xA1 0x08 0x00 0x8B 0x16 0x0A 0x00 0xF7 0x36 0x3C 0x00 0x42 0x52 0x31 0xD2 0xF7 0x36 0x3E 0x00 0x59 0xC0 0xE4 0x06 0x86 0xC4 0x09 0xC1 0x88 0xD6 0x58 0x88 0xC2 0xB4 0x02 0xA0 0x02 0x00 0x31 0xDB 0xBD 0x04 0x00 0x60 0x8E 0x06 0x06 0x00 0xCD 0x13 0x1E 0x07 0x9C 0xB8 0x2E 0x0E 0xBB 0x07 0x00 0xCD 0x10 0x9D 0x61 0x73 0xA3 0x4D 0x60 0xBE 0x30 0x00 0x0F 0x84 0xD4 0xFE 0xB8 0x30 0x0E 0x01 0xE8 0xBB 0x07 0x00 0xCD 0x10 0x31 0xC0 0xCD 0x13 0x61 0xEB 0xD0
typeset -i ofs_blkcnt=55
typeset -i ofs_numheads=62
typeset -i ofs_numsecs=60
typeset -i ofs_partp=59
typeset -i begptr=394

typeset -Uui16 curptr=begptr
typeset -i wnum=0 wofs=0 wrec=0

function do_record {
	typeset -i blk=$1 cnt=$2
	typeset -i n=cnt+100
	typeset -Uui16 x=blk y

	(( blk && cnt )) || return

	print -u2 "$wrec @0x${curptr#16#}: ${n#1} @$blk (0x${x#16#})"

	while (( cnt )); do
		let wrec++
		(( n = blk < 0x00000100 ? 0 :
		    blk < 0x00010000 ? 1 :
		    blk < 0x01000000 ? 2 : 3 ))
		(( x = cnt < 33 ? cnt : 32 ))
		(( thecode[curptr++] = (n << 5) | (x - 1) ))
		(( y = blk ))
		(( blk += x ))
		(( cnt -= x ))
		(( n++ ))
		while (( n-- )); do
			(( thecode[curptr++] = y & 0xFF ))
			(( y >>= 8 ))
		done
	done
}

function record_block {
	typeset -i sv blk=$1

	if (( !blk || (wofs && blk != (wofs + wnum)) )); then
		# flush the blocks from the cache
		if (( wnum )); then
			if (( (sv = wofs % numsecs) < (numsecs - 1) )); then
				(( sv = numsecs - sv ))
				(( sv = sv > wnum ? wnum : sv ))
				do_record $wofs $sv
				let wofs+=sv wnum-=sv
			fi

			while (( wnum > numsecs )); do
				do_record $wofs $numsecs
				let wofs+=numsecs wnum-=numsecs
			done

			(( wnum )) && do_record $wofs $wnum
		fi
		let wofs=0 wnum=0
	fi
	if (( blk )); then
		# record some new block into the cache
		(( wofs )) || let wofs=blk
		(( wnum += 1 << sscale ))
	fi
}

typeset -i flag_one=0 partp=0 numheads=0 numsecs=0 sscale=0

while getopts ":0:1h:p:S:s:" ch; do
	case $ch {
	(0)	;;
	(1)	flag_one=1 ;;
	(h)	if (( (numheads = OPTARG) < 1 || OPTARG > 256 )); then
			print -u2 warning: invalid head count "'$OPTARG'"
			numheads=0
		fi ;;
	(p)	if (( (partp = OPTARG) < 1 || OPTARG > 255 )); then
			print -u2 warning: invalid partition type "'$OPTARG'"
			partp=0
		fi ;;
	(S)	if (( (sscale = OPTARG) < 0 || OPTARG > 24 )); then
			print -u2 error: invalid input scale "'$OPTARG'"
			exit 1
		fi ;;
	(s)	if (( (numsecs = OPTARG) < 1 || OPTARG > 63 )); then
			print -u2 warning: invalid sector count "'$OPTARG'"
			numsecs=0
		fi ;;
	(*)	cat >&2 <<'EOD'
Syntax:
	bxinst [-1] [-h heads] [-p partitiontype] [-S scale]
	    [-s sectors] <sectorlist | dd of=image conv=notrunc
Default values: heads=16 sectors=63 partitiontype=0x27 scale=0
EOD
		exit 1 ;;
	}
done
shift $((OPTIND - 1))

if (( !numheads )); then
	print -u2 warning: using default value of 16 heads
	numheads=16
fi

if (( !numsecs )); then
	print -u2 warning: using default value of 63 sectors
	numsecs=63
fi

# read in the extents
while read firstblock lastblock junk; do
	while (( firstblock <= lastblock )); do
		record_block $((firstblock++ << sscale))
	done
done
record_block 0	# just flush
print -u2 "using $wrec blocks, $((curptr-begptr)) bytes ($((510-curptr)) free)"

# fill the block table
if (( curptr > 510 )); then
	print -u2 error: too many blocks
	exit 1
fi
while (( curptr < 510 )); do
	if (( (curptr & 0xFCF) == 0x1C2 )); then
		(( thecode[curptr++] = 0 ))
	else
		(( thecode[curptr++] = RANDOM & 0xFF ))
	fi
done
(( thecode[curptr++] = 0x55 ))
(( thecode[curptr++] = 0xAA ))

# fill in other data
(( thecode[ofs_blkcnt] = wrec ))
(( thecode[ofs_numheads] = numheads & 0xFF ))
(( thecode[ofs_numheads + 1] = numheads >> 8 ))
(( thecode[ofs_numsecs] = numsecs ))
(( flag_one )) && (( thecode[ofs_numsecs + 1] = 0x80 ))
(( thecode[ofs_partp] = partp ))

# create the output string
ostr=
curptr=0
typeset -Uui8 vo
while (( curptr < 512 )); do
	(( vo = thecode[curptr++] ))
	ostr="$ostr\\0${vo#8#}"
done

# over and out
print -n "$ostr"
exit 0
