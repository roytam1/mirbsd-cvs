#!/bin/mksh
# $MirOS: src/usr.sbin/adduser/adduser,v 1.2 2006/07/08 21:45:06 tg Exp $
#-
# Copyright (c) 2006
#	Thorsten Glaser <tg@mirbsd.de>
#
# Licensee is hereby permitted to deal in this work without restric-
# tion, including unlimited rights to use, publicly perform, modify,
# merge, distribute, sell, give away or sublicence, provided all co-
# pyright notices above, these terms and the disclaimer are retained
# in all redistributions or reproduced in accompanying documentation
# or other materials provided with binary redistributions.
#
# All advertising materials mentioning features or use of this soft-
# ware must display the following acknowledgement:
#	This product includes material provided by Thorsten Glaser.
#
# Licensor offers the work "AS IS" and WITHOUT WARRANTY of any kind,
# express, or implied, to the maximum extent permitted by applicable
# law, without malicious intent or gross negligence; in no event may
# licensor, an author or contributor be held liable for any indirect
# or other damage, or direct damage except proven a consequence of a
# direct error of said person and intended use of this work, loss or
# other issues arising in any way out of its use, even if advised of
# the possibility of such damage or existence of a nontrivial bug.

me=${0##*/}

function die
{
	print -u2 "$me: $*"
	exit 1
}

(( $(id -u) )) && die need root

T=$(mktemp /etc/pwd.tmp.XXXXXXXXXX) || die mktemp failed
trap 'rm -f $T; exit 1' 1 2 3 13 15

function Lstripcom
{
	local _line
	set -o noglob
	cat "$@" | while read _line; do
		_line=${_line%%#*}
		[[ -n $_line ]] && print -r -- $_line
	done
	set +o noglob
}

function ask
{
	local question=$1 default=$2
	integer len

	set -o noglob
	[[ -z $default ]] || question="$question [$default]"
	let len=${#question}
	if (( len >= 32 )); then
		question="$question "
	elif (( len >= 24 )); then
		question="$question\t"
	elif (( len >= 16 )); then
		question="$question\t\t"
	elif (( len >= 8 )); then
		question="$question\t\t\t"
	else
		question="$question\t\t\t\t"
	fi
	print -n $question
	read resp
	: ${resp:=$default}
	set +o noglob
}

function ask_pass
{
	local question=$1
	integer len=${#question}

	set -o noglob
	if (( len >= 32 )); then
		question="$question "
	elif (( len >= 24 )); then
		question="$question\t"
	elif (( len >= 16 )); then
		question="$question\t\t"
	elif (( len >= 8 )); then
		question="$question\t\t\t"
	else
		question="$question\t\t\t\t"
	fi
	print -n $question
	stty -echo
	read resp
	stty echo
	set +o noglob
	print
}

function ask_yn
{
	resp=
	while [[ $resp != @(y|n) ]]; do
		ask "$1" "${2:-no}"
		[[ $resp = yes ]] && resp=y
		[[ $resp = no ]] && resp=n
	done
}

function is_free_ugid
{
	while IFS=: read un up id rest; do
		[[ $id = $1 ]] && return 1
	done </etc/passwd
	while IFS=: read un up id rest; do
		[[ $id = $1 ]] && return 1
	done </etc/group
	return 0
}

# Find first free pair of UID/GID
let uid=3000
while :; do
	is_free_ugid $uid && break
	let uid++
done

uname=
gecos=
homedir=
shell=
passwd=

while :; do
	while :; do
		ask "User name?" "$uname"
		if [[ $resp != +([-_a-z0-9\$]) ]]; then
			print -u2 'ERROR: User name can only consist of small'
			print -u2 '\tletters, numbers, dash, underscore or'
			print -u2 '\tdollar sign (SMB/CIFS server names only)'
			continue
		fi
		while IFS=: read uexist rest; do
			[[ $uexist = $resp ]] || continue
			print -u2 "ERROR: User name $resp already exists!"
			continue 2
		done </etc/passwd
		while IFS=: read uexist rest; do
			[[ $uexist = $resp ]] || continue
			print -u2 "ERROR: User name $resp already exists!"
			continue 2
		done </etc/group
		uname=$resp
		break
	done
	while :; do
		ask "User ID?" $uid
		typeset -Ui respval="$resp"
		if (( (respval < 10) || (respval > 32765) )); then
			print -u2 "ERROR: User ID $respval not within bounds!"
			print -u2 '\tAllowed values are between 10 and 32765'
			continue
		fi
		if ! is_free_ugid $respval; then
			print -u2 "ERROR: User ID $respval already exists!"
			continue
		fi
		let uid=$respval
		break
	done
	while :; do
		ask "Real name?" "$gecos"
		if [[ -z $resp ]]; then
			print -u2 "ERROR: empty real name field not allowed!"
			continue
		fi
		if [[ $resp = *:* ]]; then
			print -u2 "ERROR: colon not allowed in real name field!"
			continue
		fi
		gecos=$resp
		break
	done
	while :; do
		ask "Home directory?" "${homedir:-/home/$uname}"
		: ${resp:=/}
		if [[ $resp != /* ]]; then
			print -u2 'ERROR: please use absolute pathname for'
			print -u2 '\tthe home directory!'
			continue
		fi
		if [[ $resp = *@(:|\*|\?)* ]]; then
			print -u2 "ERROR: not allowed in home directory:"
			print -u2 '\tcolon, asterisk, question mark'
			continue
		fi
		if [[ -e $resp ]]; then
			print -u2 "ERROR: directory $homedir already exists!"
			continue
		fi
		homedir=$resp
		break
	done
	while :; do
		ask "Login shell?" "${shell:-/bin/mksh}"
		[[ $shell = /sbin/nologin ]] && break
		shells=
		Lstripcom /etc/shells |&
		while read -p line; do
			shells="$shells $line"
			[[ $line = $resp ]] || continue
			shell=$resp
			break 2
		done
		print -u2 "ERROR: login shell $resp not allowed!"
		print -u2 '\tChoose one of:'
		print -ru2 "       $shells"
	done
	[[ $shell = /sbin/nologin ]] || while :; do
		ask_pass "Login passphrase:"
		t=$resp
		ask_pass "Please repeat:"
		if [[ $t != $resp ]]; then
			t=
			print -u2 'ERROR: passwords do not match! Try again.'
			continue
		fi
		t=
		if [[ -z $resp ]]; then
			ask_yn "Prevent user from logging in?" yes
			[[ $resp = y ]] || continue
			shell=/sbin/nologin
		else
			passwd="$(print -nr -- "$resp" | encrypt)"
			resp=
			if [[ $passwd != @(\$2a\$)* ]]; then
				print -u2 'ERROR: encrypted password is not in'
				print -u2 '\texpected blowfish format, please'
				print -u2 '\tfix this in /etc/login.conf, the'
				print -u2 '\t"default" class settings.'
				continue
			fi
		fi
		break
	done
	[[ $shell = /sbin/nologin ]] && passwd=\*
	print 'For advanced settings, such as login class, additional'
	print '\tgroups, timeouts, please edit the files manually.'
	ask_yn "Everything okay?"
	[[ $resp = y ]] && break
done

chown root:wheel $T
chmod 600 $T
print -r -- "$uname:$passwd:$uid:$uid::0:0:$gecos:$homedir:$shell" >$T
cat /etc/master.passwd >>$T
sort -t: -nk3 -o $T $T
mv /etc/master.passwd /etc/master.passwd.bak
mv $T /etc/master.passwd
chown root:wheel /etc/master.passwd
chmod 600 /etc/master.passwd
rm -f /etc/master.passwd.bak

print -r -- "$uname:*:$uid:" >$T
chown root:wheel $T
chmod 644 $T
cat /etc/group >>$T
sort -t: -nk3 -o $T $T
mv /etc/group /etc/group.bak
mv $T /etc/group
rm -f /etc/group.bak

cp -R /etc/skel "$homedir"
chown -R $uid:$uid "$homedir"

pwd_mkdb -p /etc/master.passwd
exit 0
