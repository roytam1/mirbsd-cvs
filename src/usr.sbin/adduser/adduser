#!/bin/mksh
# $MirOS: src/usr.sbin/adduser/adduser,v 1.8 2008/06/25 12:04:30 tg Exp $
#-
# Copyright (c) 2006, 2007, 2008
#	Thorsten Glaser <tg@mirbsd.de>
#
# Provided that these terms and disclaimer and all copyright notices
# are retained or reproduced in an accompanying document, permission
# is granted to deal in this work without restriction, including un-
# limited rights to use, publicly perform, distribute, sell, modify,
# merge, give away, or sublicence.
#
# This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
# the utmost extent permitted by applicable law, neither express nor
# implied; without malicious intent or gross negligence. In no event
# may a licensor, author or contributor be held liable for indirect,
# direct, other damage, loss, or other issues arising in any way out
# of dealing in the work, even if advised of the possibility of such
# damage or existence of a defect, except proven that it results out
# of said person's immediate fault when using the work as intended.

me=${0##*/}

function die
{
	print -u2 "$me: $*"
	exit 1
}

(( USER_ID )) && die need root

T=$(mktemp /etc/pwd.tmp.XXXXXXXXXX) || die mktemp failed
trap 'rm -f $T; exit 1' 1 2 3 5 13 15
cat /etc/group >$T

function Lstripcom {
	cat "$@" | { set -o noglob; while read _line; do
		_line=${_line%%#*}
		[[ -n $_line ]] && print -r -- $_line
	done; }
}

function ask {
	local question=$1 default=$2
	integer len

	set -o noglob
	[[ -z $default ]] || question="$question [$default]"
	let len=${#question}
	if (( len >= 32 )); then
		question="$question "
	elif (( len >= 24 )); then
		question="$question\t"
	elif (( len >= 16 )); then
		question="$question\t\t"
	elif (( len >= 8 )); then
		question="$question\t\t\t"
	else
		question="$question\t\t\t\t"
	fi
	print -n -- "$question"
	read resp
	: ${resp:=$default}
	set +o noglob
}

function ask_pass {
	local question=$1
	integer len=${#question}

	set -o noglob
	if (( len >= 32 )); then
		question="$question "
	elif (( len >= 24 )); then
		question="$question\t"
	elif (( len >= 16 )); then
		question="$question\t\t"
	elif (( len >= 8 )); then
		question="$question\t\t\t"
	else
		question="$question\t\t\t\t"
	fi
	print -n -- "$question"
	stty -echo
	read resp
	stty echo
	set +o noglob
	print
}

function ask_yn {
	typeset -l rsp

	while [[ $rsp != @(y|n) ]]; do
		ask "$1" "${2:-no}"
		rsp=$resp
		[[ $rsp = yes ]] && rsp=y
		[[ $rsp = no ]] && rsp=n
	done
	resp=$rsp
}

function is_ugid_used {
	grep -q "^[^:]*:[^:]*:$1:" /etc/passwd $T 2>/dev/null
}

# Find first free pair of UID/GID
integer uid=3000
while :; do
	is_ugid_used $uid || break
	let uid++
done

uname=
gecos=
homedir=
shell=
passwd=

while :; do
	while :; do
		ask "User name?" "$uname"
		if [[ $resp != +([-_a-z0-9\$]) ]]; then
			print -u2 'ERROR: User name can only consist of lower'
			print -u2 '\tcase letters, numbers, dash, underscore or'
			print -u2 '\tdollar sign (SMB/CIFS server names only)'
			continue
		fi
		while IFS=: read uexist rest; do
			[[ $uexist = $resp ]] || continue
			print -u2 "ERROR: User name $resp already exists!"
			continue 2
		done </etc/passwd
		uname=$resp
		# lazy assistance
		while IFS=: read uexist pw gid rest; do
			[[ $uexist = $uname ]] || continue
			print "Found group $uname at GID $gid"
			break
		done </etc/group
		break
	done
	while :; do
		ask "User ID?" $uid
		typeset -Ui respval="$resp"
		if (( (respval < 10) || (respval > 32765) )); then
			print -u2 "ERROR: User ID $respval not within bounds!"
			print -u2 '\tAllowed values are between 10 and 32765'
			continue
		fi
		# if user name and UID match, be lazy on group checking
		tline="$uname:*:$respval:"
		while IFS= read -r line; do
			[[ $line = $tline ]] && continue
			print -r -- "$line"
		done </etc/group >$T
		# now validate group name and UID/GID
		while IFS=: read uexist rest; do
			[[ $uexist = $uname ]] || continue
			print -u2 "ERROR: User name $uname already exists!"
			continue 3	# to the outer-most loop
		done <$T
		if is_ugid_used $respval; then
			print -u2 "ERROR: User ID $respval already exists!"
			continue
		fi
		let uid=$respval
		break
	done
	while :; do
		ask "Real name?" "$gecos"
		if [[ -z $resp ]]; then
			print -u2 "ERROR: empty real name field not allowed!"
			continue
		fi
		if [[ $resp = *:* ]]; then
			print -u2 "ERROR: colon not allowed in real name field!"
			continue
		fi
		gecos=$resp
		break
	done
	while :; do
		ask "Home directory?" "${homedir:-/home/$uname}"
		: ${resp:=/}
		if [[ $resp != /* ]]; then
			print -u2 'ERROR: please use absolute pathname for'
			print -u2 '\tthe home directory!'
			continue
		fi
		if [[ $resp = *@(:|\*|\?)* ]]; then
			print -u2 "ERROR: not allowed in home directory:"
			print -u2 '\tcolon, asterisk, question mark'
			continue
		fi
		if [[ -e $resp ]]; then
			print -u2 "ERROR: directory $homedir already exists!"
			continue
		fi
		homedir=$resp
		break
	done
	while :; do
		ask "Login shell?" "${shell:-/bin/mksh}"
		[[ $shell = /sbin/nologin ]] && break
		shells=
		Lstripcom /etc/shells |&
		while read -p line; do
			shells="$shells $line"
			[[ $line = $resp ]] || continue
			shell=$resp
			break 2
		done
		print -u2 "ERROR: login shell $resp not allowed!"
		print -u2 '\tChoose one of:'
		print -u2 "\t${shells# }"
	done
	[[ $shell = /sbin/nologin ]] || while :; do
		ask_pass "Login passphrase:"
		t=$resp
		ask_pass "Please repeat:"
		if [[ $t != $resp ]]; then
			t=
			print -u2 'ERROR: passwords do not match! Try again.'
			continue
		fi
		t=
		if [[ -z $resp ]]; then
			ask_yn "Prevent user from logging in?" yes
			if [[ $resp = y ]]; then
				shell=/sbin/nologin
			else
				passwd=skey
			fi
		else
			passwd="$(encrypt <<<"$resp")"
			resp=
			if [[ $passwd != @(\$2a\$)* ]]; then
				print -u2 'ERROR: encrypted password is not in'
				print -u2 '\texpected blowfish format, please'
				print -u2 '\tfix this in /etc/login.conf, the'
				print -u2 '\t"default" class settings.'
				continue
			fi
		fi
		break
	done
	[[ $shell = /sbin/nologin ]] && passwd=\*
	print 'For advanced settings, such as login class, additional'
	print '\tgroups, timeouts, please edit the files manually.'
	ask_yn "Everything okay?"
	[[ $resp = y ]] && break
done

chown root:wheel $T
chmod 600 $T
print -r -- "$uname:$passwd:$uid:$uid::0:0:$gecos:$homedir:$shell" >$T
cat /etc/master.passwd >>$T
sort -t: -nk3 -o $T $T
mv /etc/master.passwd /etc/master.passwd.bak
mv $T /etc/master.passwd
chown root:wheel /etc/master.passwd
chmod 600 /etc/master.passwd
rm -f /etc/master.passwd.bak

print -r -- "$uname:*:$uid:" >$T
chown root:wheel $T
chmod 644 $T
cat /etc/group >>$T
sort -t: -nk3 -uo $T $T
mv /etc/group /etc/group.bak
mv $T /etc/group
rm -f /etc/group.bak

cp -R /etc/skel "$homedir"
chown -R $uid:$uid "$homedir"

pwd_mkdb -p /etc/master.passwd
exit 0
