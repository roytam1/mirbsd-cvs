#!/bin/mksh
# $MirOS: contrib/hosted/tg/rstat,v 1.3 2010/09/24 19:59:04 tg Exp $
#-
# Copyright © 2010
#	Thorsten Glaser <tg@mirbsd.org>
#
# Provided that these terms and disclaimer and all copyright notices
# are retained or reproduced in an accompanying document, permission
# is granted to deal in this work without restriction, including un‐
# limited rights to use, publicly perform, distribute, sell, modify,
# merge, give away, or sublicence.
#
# This work is provided “AS IS” and WITHOUT WARRANTY of any kind, to
# the utmost extent permitted by applicable law, neither express nor
# implied; without malicious intent or gross negligence. In no event
# may a licensor, author or contributor be held liable for indirect,
# direct, other damage, loss, or other issues arising in any way out
# of dealing in the work, even if advised of the possibility of such
# damage or existence of a defect, except proven that it results out
# of said person’s immediate fault when using the work as intended.
#-
# Display entropy statistics, human-readable

saveIFS=$IFS
function tabularise {
	typeset maxlens aline aligns spaces
	set -A maxlens 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	typeset i=-1 nlins=${#lines[*]} ncols=$1

	if [[ $2 = RL ]]; then
		set -A aligns R L R L R L R L R L R L R L R L
		set -A spaces 0 $4 $3 $4 $3 $4 $3 $4 $3 $4 $3 $4 $3 $4 $3 $4
	else
		set -A aligns L L L L L L L L L L L L L L L L
		set -A spaces 0 $3 $3 $3 $3 $3 $3 $3 $3 $3 $3 $3 $3 $3 $3 $3
	fi

	IFS=!
	while (( ++i < nlins )); do
		typeset j=-1
		set -A aline -- ${lines[i]}
		while (( ++j < ncols )); do
			typeset k=${%aline[j]}
			(( k < 0 )) && k=${#aline[j]}
			(( maxlens[j] = maxlens[j] < k ? k : maxlens[j] ))
		done
	done
	typeset i=-1
	while (( ++i < nlins )); do
		typeset j=-1 oline=
		set -A aline -- ${lines[i]}
		while (( ++j < ncols )); do
			eval typeset -${aligns[j]}'${maxlens[j]}' \
			    'k=${aline[j]}'
			eval typeset -L${spaces[j]} 'sp=" "'
			oline=$oline${oline:+$sp}$k
		done
		print -r -- "$oline"
	done
	IFS=$saveIFS
}

while :; do
	print -n 'Hit Enter to continue: '
	read dummy
	[[ $dummy = q* ]] && exit 0
	count=$(rcnt)
	set -A stats -- $(sysctl -n kern.random)
	print
	#print D: $count ${stats[*]}

	# these numbers are "inclusive", detrend them
	(( stats[16] -= stats[49] ))
	(( stats[40] -= stats[4] ))

	set -A lines
	lines[0]="entropy $((count/8)) bytes!total $((stats[0]/8)) bytes ${stats[11]} sleeping waits"
	lines[1]="used/read $((stats[1]/8)) bytes!srandom read ${stats[2]} times"
	lines[2]="arc4 read ${stats[3]} bytes!stirred ${stats[4]} times, using ${stats[5]} bytes"
	lines[3]="${stats[12]} tytso pool enqueue calls!${stats[13]} tytso pool dequeue calls"
	lines[4]="${stats[14]} queue-full drops!${stats[15]} low watermark low entropy"
	lines[5]="${stats[6]} lopool dequeue calls @ 128by!${stats[7]} enqueue calls, ${stats[8]} bytes"
	tabularise 2 - 5

	i=-1
	set -A lines
	while (( ++i < 4 )); do
		j=-1
		l=
		while (( ++j < 8 )); do
			l=$l${l:+!}"$((i*8+j))b!${stats[i*8+j+16]}"
		done
		lines[i]=$l
	done
	tabularise 16 RL 2 1

	set -A lines
	l=
	i=0 t=TRUE
	l=$l${l:+!}"$t(${stats[48+i]})!$((stats[56+i]/8))"
	i=3 t=TTY
	l=$l${l:+!}"$t(${stats[48+i]})!$((stats[56+i]/8))"
	i=2 t=MOUSE
	l=$l${l:+!}"$t(${stats[48+i]})!$((stats[56+i]/8))"
	i=7 t=IMACS
	l=$l${l:+!}"$t(${stats[48+i]})!$((stats[56+i]/8))"
	lines[0]=$l
	l=
	i=1 t=TIMER
	l=$l${l:+!}"$t!${stats[48+i]}"
	i=5 t=NET
	l=$l${l:+!}"$t(${stats[48+i]})!$((stats[56+i]/8))"
	i=6 t=A/V
	l=$l${l:+!}"$t(${stats[48+i]})!$((stats[56+i]/8))"
	i=4 t=DISK
	l=$l${l:+!}"$t(${stats[48+i]})!$((stats[56+i]/8))"
	lines[1]=$l
	tabularise 8 RL 3 1
done
