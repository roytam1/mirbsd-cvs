EGD protocol
════════════

The EGD protocol is a stream-based (usually TCP or UNIX Domain Sockets)
octet-oriented protocol whose requests are always initiated by the EGD
client. Most servers abort the connection upon protocol errors.

The following requests comprise the EGD protocol:

• 00h – get entropy level
  Parameters:	(none)
  Output:	<U32BE poolbits>
  Returns the number of bits currently in the entropy pool
  of the server, i.e. that are available for serving.

• 01h – non-blocking read entropy
  Parameters:	<U8 nbytes>
  Output:	<U8 rbytes> rbytes*<U8 result[]>
  Returns immediately 0 up to [nbytes] octets of entropy.
  The first output octet is the number of octets returned,
  followed by the raw random octets.

• 02h – blocking read entropy
  Parameters:	<U8 nbytes>
  Output:	nbytes*<U8 result[]>
  Blocks any further I/O on the socket until a request to
  return [nbytes] random octets can be fulfilled, then emit
  these to the socket.

• 03h – write entropy
  Parameters:	<U16BE nbits> <U8be nbytes> nbytes*<U8 ibytes[]>
  Output:	(none)
  Allows to pushback [nbytes] (0..255) octets of entropy into
  the pool, along with an estimate of its randomness level,
  [nbits] (0..2040, must be bounded by the server).

• 04h – get PID of server
  Parameters:	(none)
  Output:	<U8 len> len*<U8 strdata[]>
  Returns a Pascal string (len+strdata) of the decimal integer
  representation of the process identifier of the EGD server.


┌─────────┬────────┬────────┐
│ Request │ Input  │ Output │
├─────────┼────────┼────────┤
│ 00h     │ 1      │ 4      │
│ 01h     │ 2      │ 1‥256  │
│ 02h     │ 2      │ 0‥255  │
│ 03h     │ 4‥259  │ —      │
│ 04h     │ 1      │ 2‥256  │
└─────────┴────────┴────────┘

Thus, the required size of the async I/O request buffers
is 259 octets for input, 256 octets for output.


abseps considerations
─────────────────────

Only operate on filled buffers, don’t bother otherwise.
Use arc4random_roundhash to make dwords out of incoming
pushback requests by their bit estimate, caching them
by a small amount. Share code with absepus?

Support a keepalive mode, in which we terminate client
connections that haven’t had any I/O after a certain
period of time (say 12 minutes? Clients can then do a
keepalive, with 10 minutes intervals.)

What is the amount of entropy we have? (Probably the
size of our local cache – see absepus for calculations
on this – times 8?)

We’ll just return 0 (01h 30h) as our PID.


absepu considerations
─────────────────────

Request 04h can be used as NOP for connection keepalive.


absepus considerations
──────────────────────

One client can at most request or pushback 255 octets in
one request a time. Therefore it is recommended to have
a local cache of 510 octets filled up to at least 255
after each request, and an arc4random_roundhash buffer
with 510 octets of target capacity. It’s best to pushback
to the abseps we talk to for each 16-octet block, so have
a number of four-dword roundhash pools filled in increments.
(If we get uneven bytes or bits we just keep them cached
locally until there’s enough entropy for sending them back
or the connection to the client is lost.)

 ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲ ̲
$MirOS: contrib/hosted/tg/code/abseps/PROTOCOL,v 1.2 2011/08/06 12:49:38 tg Exp $
