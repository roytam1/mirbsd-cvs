# $MirOS$

if stat --help >/dev/null 2>&1; then
	statcmd='stat -c %s'	# GNU stat
else
	statcmd='stat -f %z'	# BSD stat (or so we assume)
fi
integer i=1
cp $1 y1
# rotate
while :; do
	integer j=i+1
	{
		read first
		while read line; do
			print -r -- "$line"
		done
		print -r -- "$first"
	} <y$i >y$j
	let i++
	cmp -s y1 y$j || continue
	rm y$j
	break
done
# run 'em all
integer outersize=999999
for file in y*; do
	integer serial=1
	set -A sums
	integer sums
	cp $file z$file.$serial
	while :; do
		print === entering $file round $serial
		set -A foo $(<z$file.$serial)
		integer xsize=999999
		integer num=${#foo[*]}
		integer i=0
		while (( i < num )); do
			integer j=i+1
			while (( j < num )); do
				local k=${foo[i]}
				foo[i]=${foo[j]}
				foo[j]=$k
				mirpax -w -x cpio -b 512 -M dist ${foo[*]} | gzip -n9 >mksh4.cgz
				integer newsize=$($statcmd mksh4.cgz)
				print "$newsize\t${foo[*]}"
				foo[j]=${foo[i]}
				foo[i]=$k
				let ++j
				(( newsize > 100 )) || continue
				if (( newsize < xsize )); then
					xsize=newsize
					cp mksh4.cgz mksh4.x
				fi
			done
			let ++i
		done
		mirpax -w -x cpio -b 512 -M dist ${foo[*]} | gzip -n9 >mksh4.cgz
		integer newsize=$($statcmd mksh4.cgz)
		print "$newsize\t${foo[*]}"
		if (( newsize < xsize )); then
			cp mksh4.cgz mksh4.x
		fi

		let ++serial
		mirtar tzf mksh4.x >z$file.$serial
		integer newsum=$(cksum z$file.$serial | sed 's/ .*$//')
		[[ " ${sums[*]} " = *@(" $newsum ")* ]] && break
		let sums[serial]=newsum
	done
	integer innersize=$($statcmd mksh4.x)
	if (( innersize < outersize )); then
		outersize=innersize
		cp mksh4.x mksh4.y
	fi
done
rm y+([0-9]) zy+([0-9.]) mksh4.{cgz,x}
print smallest: $outersize
ls -l mksh4.y
