#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
grml2usb
~~~~~~~~

This script installs a grml system (either a running system or ISO[s]) to a USB device

:copyright: (c) 2009 by Michael Prokop <mika@grml.org>
:license: GPL v2 or any later version
:bugreports: http://grml.org/bugs/

"""

# from __future__ import with_statement
from optparse import OptionParser
from inspect import isroutine, isclass
import datetime, logging, os, re, subprocess, sys, tempfile, time, os.path

# global variables
PROG_VERSION = "0.9.13-pre1"
MOUNTED = set()  # register mountpoints
TMPFILES = set() # register tmpfiles
DATESTAMP = time.mktime(datetime.datetime.now().timetuple()) # unique identifier for syslinux.cfg
GRML_FLAVOURS = set() # which flavours are being installed?
global GRML_DEFAULT

# cmdline parsing
USAGE = "Usage: %prog [options] <[ISO[s] | /live/image]> </dev/sdX#>\n\
\n\
%prog installs grml ISO[s] to an USB device to be able to boot from it.\n\
Make sure you have at least one grml ISO or a running grml system (/live/image),\n\
grub or syslinux and root access.\n\
\n\
Run %prog --help for usage hints, further information via: man grml2usb"

# pylint: disable-msg=C0103
parser = OptionParser(usage=USAGE)
parser.add_option("--bootoptions", dest="bootoptions",
                  action="store", type="string",
                  help="use specified bootoptions as default")
parser.add_option("--bootloader-only", dest="bootloaderonly", action="store_true",
                  help="do not copy files but just install a bootloader")
parser.add_option("--copy-only", dest="copyonly", action="store_true",
                  help="copy files only but do not install bootloader")
parser.add_option("--dry-run", dest="dryrun", action="store_true",
                  help="avoid executing commands")
parser.add_option("--fat16", dest="fat16", action="store_true",
                  help="format specified partition with FAT16")
parser.add_option("--force", dest="force", action="store_true",
                  help="force any actions requiring manual interaction")
parser.add_option("--grub-mbr", dest="grubmbr", action="store_true",
                  help="install grub into MBR instead of (default) PBR")
parser.add_option("--lilo-binary", dest="lilobin",  action="store", type="string",
                  help="lilo executable to be used for installing MBR")
parser.add_option("--mbr-menu", dest="mbrmenu", action="store_true",
                  help="enable interactive boot menu in MBR")
parser.add_option("--quiet", dest="quiet", action="store_true",
                  help="do not output anything but just errors on console")
parser.add_option("--skip-addons", dest="skipaddons", action="store_true",
                  help="do not install /boot/addons/ files")
parser.add_option("--skip-grub-config", dest="skipgrubconfig", action="store_true",
                  help="skip generation of grub configuration files")
parser.add_option("--skip-mbr", dest="skipmbr", action="store_true",
                  help="do not install a master boot record (MBR) on the device")
parser.add_option("--skip-syslinux-config", dest="skipsyslinuxconfig", action="store_true",
                  help="skip generation of syslinux configuration files")
parser.add_option("--syslinux", dest="syslinux", action="store_true",
                  help="install syslinux bootloader instead of grub")
parser.add_option("--syslinux-mbr", dest="syslinuxmbr", action="store_true",
                  help="install syslinux master boot record (MBR) instead of default")
parser.add_option("--verbose", dest="verbose", action="store_true",
                  help="enable verbose mode")
parser.add_option("-v", "--version", dest="version", action="store_true",
                  help="display version and exit")
(options, args) = parser.parse_args()


GRML2USB_BASE = '/usr/share/grml2usb'
if not os.path.isdir(GRML2USB_BASE):
    GRML2USB_BASE = os.path.dirname(os.path.realpath(__file__))


class CriticalException(Exception):
    """Throw critical exception if the exact error is not known but fatal."

    @Exception: message"""
    pass


def cleanup():
    """Cleanup function to make sure there aren't any mounted devices left behind.
    """

    logging.info("Cleaning up before exiting...")
    proc = subprocess.Popen(["sync"])
    proc.wait()

    try:
        for device in MOUNTED:
            unmount(device, "")
    # ignore: RuntimeError: Set changed size during iteration
    except RuntimeError:
        logging.debug('caught expection RuntimeError, ignoring')


def register_tmpfile(path):
    """
    TODO - not implemented yet
    """

    TMPFILES.add(path)


def unregister_tmpfile(path):
    """
    TODO - not implemented yet
    """

    if path in TMPFILES:
        TMPFILES.remove(path)


def register_mountpoint(target):
    """register specified target in a set() for handling clean exiting

    @target: destination target of mountpoint
    """

    MOUNTED.add(target)


def unregister_mountpoint(target):
    """unregister specified target in a set() for handling clean exiting

    @target: destination target of mountpoint
    """

    if target in MOUNTED:
        MOUNTED.remove(target)


def get_function_name(obj):
    """Helper function for use in execute() to retrive name of a function

    @obj: the function object
    """
    if not (isroutine(obj) or isclass(obj)):
        obj = type(obj)
    return obj.__module__ + '.' + obj.__name__


def execute(f, *exec_arguments):
    """Wrapper for executing a command. Either really executes
    the command (default) or when using --dry-run commandline option
    just displays what would be executed."""
    # usage: execute(subprocess.Popen, (["ls", "-la"]))
    # TODO: doesn't work for proc = execute(subprocess.Popen...() -> any ideas?
    if options.dryrun:
        # pylint: disable-msg=W0141
        logging.debug('dry-run only: %s(%s)', get_function_name(f), ', '.join(map(repr, exec_arguments)))
    else:
        # pylint: disable-msg=W0142
        return f(*exec_arguments)


def is_exe(fpath):
    """Check whether a given file can be executed

    @fpath: full path to file
    @return:"""
    return os.path.exists(fpath) and os.access(fpath, os.X_OK)


def which(program):
    """Check whether a given program is available in PATH

    @program: name of executable"""
    fpath = os.path.split(program)[0]
    if fpath:
        if is_exe(program):
            return program
    else:
        for path in os.environ["PATH"].split(os.pathsep):
            exe_file = os.path.join(path, program)
            if is_exe(exe_file):
                return exe_file

    return None


def search_file(filename, search_path='/bin' + os.pathsep + '/usr/bin'):
    """Given a search path, find file

    @filename: name of file to search for
    @search_path: path where searching for the specified filename"""
    file_found = 0
    paths = search_path.split(os.pathsep)
    current_dir = '' # make pylint happy :)
    for path in paths:
        # pylint: disable-msg=W0612
        for current_dir, directories, files in os.walk(path):
            if os.path.exists(os.path.join(current_dir, filename)):
                file_found = 1
                break
    if file_found:
        return os.path.abspath(os.path.join(current_dir, filename))
    else:
        return None


def check_uid_root():
    """Check for root permissions"""
    if not os.geteuid()==0:
        sys.exit("Error: please run this script with uid 0 (root).")


def mkfs_fat16(device):
    """Format specified device with VFAT/FAT16 filesystem.

    @device: partition that should be formated"""

    if options.dryrun:
        logging.info("Would execute mkfs.vfat -F 16 %s now.", device)
        return 0

    logging.info("Formating partition with fat16 filesystem")
    logging.debug("mkfs.vfat -F 16 %s", device)
    proc = subprocess.Popen(["mkfs.vfat", "-F", "16", device])
    proc.wait()
    if proc.returncode != 0:
        raise CriticalException("error executing mkfs.vfat")


def generate_main_grub2_config(grml_flavour, bootoptions):
    """Generate grub2 configuration for use via grub.cfg

    @grml_flavour: name of grml flavour the configuration should be generated for
    @bootoptions: additional bootoptions that should be used by default"""

    local_datestamp = DATESTAMP

    return("""\
## main grub2 configuration - generated by grml2usb [main config generated at: %(local_datestamp)s]
set default=0
set timeout=10

insmod fat

if loadfont /boot/grub/ascii.pf2 ; then
   insmod png
   set gfxmode=640x480
   insmod gfxterm
   insmod vbe
   if terminal_output.gfxterm ; then true ; else
    # For backward compatibility with versions of terminal.mod that don't
    # understand terminal_output
    terminal gfxterm
   fi
fi

if background_image /boot/grub/grml.png ; then
  set color_normal=black/black
  set color_highlight=red/black
else
  set menu_color_normal=white/black
  set menu_color_highlight=black/yellow
fi

menuentry "%(grml_flavour)s (default)" {
    set gfxpayload=1024x768x16,1024x768
    linux   /boot/release/%(grml_flavour)s/linux26 apm=power-off quiet boot=live nomce live-media-path=/live/%(grml_flavour)s/ %(bootoptions)s
    initrd  /boot/release/%(grml_flavour)s/initrd.gz
}

menuentry "Memory test (memtest86+)" {
    linux16   /boot/addons/memtest
}

menuentry "Boot Grub (all in one image)" {
    linux   /boot/addons/memdisk
    initrd  /boot/addons/allinone.img
}

menuentry "Boot FreeDOS" {
    linux   /boot/addons/memdisk
    initrd  /boot/addons/balder10.imz
}

menuentry "Boot MirOS bsd4grml" {
    multiboot /boot/addons/bsd4grml/ldbsd.com
    module    /boot/addons/bsd4grml/bsd.rd
    module    /boot/addons/bsd4grml/boot.1
    module    /boot/addons/bsd4grml/boot.2
    module    /boot/addons/bsd4grml/boot.3
    module    /boot/addons/bsd4grml/boot.4
    module    /boot/addons/bsd4grml/boot.5
    module    /boot/addons/bsd4grml/boot.6
    module    /boot/addons/bsd4grml/boot.cfg
}

menuentry "Boot OS of first partition on first disk" {
    set root=(hd0,1)
    chainloader +1
}

""" % {'grml_flavour': grml_flavour, 'local_datestamp': local_datestamp,
        'bootoptions': bootoptions } )


def generate_flavour_specific_grub2_config(grml_flavour, bootoptions):
    """Generate grub2 configuration for use via grub.cfg

    @grml_flavour: name of grml flavour the configuration should be generated for
    @bootoptions: additional bootoptions that should be used by default"""

    local_datestamp = DATESTAMP

    return("""\
## flavour specific configuration for %(grml_flavour)s [grml2usb for %(grml_flavour)s: %(local_datestamp)s]
menuentry "%(grml_flavour)s            - boot in default mode" {
    set gfxpayload=1024x768x16,1024x768
    linux  /boot/release/%(grml_flavour)s/linux26 apm=power-off boot=live nomce quiet live-media-path=/live/%(grml_flavour)s/ %(bootoptions)s
    initrd /boot/release/%(grml_flavour)s/initrd.gz
}

## flavour specific configuration for %(grml_flavour)s [grml2usb for %(grml_flavour)s: %(local_datestamp)s]
menuentry "%(grml_flavour)s-persistent - enable persistency feature" {
    set gfxpayload=1024x768x16,1024x768
    linux  /boot/release/%(grml_flavour)s/linux26 apm=power-off boot=live nomce quiet persistent live-media-path=/live/%(grml_flavour)s/ %(bootoptions)s
    initrd /boot/release/%(grml_flavour)s/initrd.gz
}

## flavour specific configuration for %(grml_flavour)s [grml2usb for %(grml_flavour)s: %(local_datestamp)s]
menuentry "%(grml_flavour)s2ram        - copy compressed grml file to RAM" {
    set gfxpayload=1024x768x16,1024x768
    linux  /boot/release/%(grml_flavour)s/linux26 apm=power-off boot=live nomce quiet live-media-path=/live/%(grml_flavour)s/ toram=%(grml_flavour)s.squashfs %(bootoptions)s
    initrd /boot/release/%(grml_flavour)s/initrd.gz
}

## flavour specific configuration for %(grml_flavour)s [grml2usb for %(grml_flavour)s: %(local_datestamp)s]
menuentry "%(grml_flavour)s-debug      - enable debugging options" {
    set gfxpayload=1024x768x16,1024x768
    linux /boot/release/%(grml_flavour)s/linux26 apm=power-off boot=live nomce quiet live-media-path=/live/%(grml_flavour)s/ debug boot=live initcall_debug%(bootoptions)s
    initrd /boot/release/%(grml_flavour)s/initrd.gz
}

## flavour specific configuration for %(grml_flavour)s [grml2usb for %(grml_flavour)s: %(local_datestamp)s]
menuentry "%(grml_flavour)s-x          - start X Window System" {
    set gfxpayload=1024x768x16,1024x768
    linux  /boot/release/%(grml_flavour)s/linux26 apm=power-off boot=live nomce quiet live-media-path=/live/%(grml_flavour)s/ startx=wm-ng %(bootoptions)s
    initrd /boot/release/%(grml_flavour)s/initrd.gz
}

## flavour specific configuration for %(grml_flavour)s [grml2usb for %(grml_flavour)s: %(local_datestamp)s]
menuentry "%(grml_flavour)s-nofb       - disable framebuffer" {
    linux  /boot/release/%(grml_flavour)s/linux26 apm=power-off boot=live nomce quiet live-media-path=/live/%(grml_flavour)s/ vga=normal video=ofonly %(bootoptions)s
    initrd /boot/release/%(grml_flavour)s/initrd.gz
}

## flavour specific configuration for %(grml_flavour)s [grml2usb for %(grml_flavour)s: %(local_datestamp)s]
menuentry "%(grml_flavour)s-failsafe   - disable hardware detection" {
    linux /boot/release/%(grml_flavour)s/linux26 apm=power-off boot=live nomce quiet live-media-path=/live/%(grml_flavour)s/ vga=normal boot=live noautoconfig atapicd noapic noacpi acpi=off nomodules nofirewire noudev nousb nohotplug noapm nopcmcia nosmp maxcpus=0 noscsi noagp nodma ide=nodma noswap nofstab nosound nogpm nosyslog nodhcp nocpu nodisc nomodem xmodule=vesa noraid nolvm noresume selinux=0 edd=off pci=nomsi %(bootoptions)s
    initrd /boot/release/%(grml_flavour)s/initrd.gz
}

## flavour specific configuration for %(grml_flavour)s [grml2usb for %(grml_flavour)s: %(local_datestamp)s]
menuentry "%(grml_flavour)s-forensic   - do not touch harddisks during hw recognition" {
    set gfxpayload=1024x768x16,1024x768
    linux /boot/release/%(grml_flavour)s/linux26 apm=power-off boot=live nomce quiet live-media-path=/live/%(grml_flavour)s/ nofstab noraid nolvm noautoconfig noswap raid=noautodetect forensic readonly %(bootoptions)s
    initrd /boot/release/%(grml_flavour)s/initrd.gz
}

""" % {'grml_flavour': grml_flavour, 'local_datestamp': local_datestamp,
       'bootoptions': bootoptions } )


def generate_flavour_specific_grub1_config(grml_flavour, install_partition, bootoptions):
    """Generate grub1 configuration for use via menu.lst

    @grml_flavour: name of grml flavour the configuration should be generated for
    @install_partition: partition number for use in (hd0,X)
    @bootoptions: additional bootoptions that should be used by default"""

    local_datestamp = DATESTAMP

    return("""\
## flavour specific configuration for %(grml_flavour)s [grml2usb for %(grml_flavour)s: %(local_datestamp)s]
title %(grml_flavour)s
kernel (hd0,%(install_partition)s)/boot/release/%(grml_flavour)s/linux26 apm=power-off boot=live nomce vga=791 quiet live-media-path=/live/%(grml_flavour)s/ %(bootoptions)s
initrd (hd0,%(install_partition)s)/boot/release/%(grml_flavour)s/initrd.gz

## flavour specific configuration for %(grml_flavour)s [grml2usb for %(grml_flavour)s: %(local_datestamp)s]
title %(grml_flavour)s-persistent
kernel (hd0,%(install_partition)s)/boot/release/%(grml_flavour)s/linux26 apm=power-off boot=live nomce vga=791 quiet persistent live-media-path=/live/%(grml_flavour)s/ %(bootoptions)s
initrd (hd0,%(install_partition)s)/boot/release/%(grml_flavour)s/initrd.gz

## flavour specific configuration for %(grml_flavour)s [grml2usb for %(grml_flavour)s: %(local_datestamp)s]
title %(grml_flavour)s2ram
kernel (hd0,%(install_partition)s)/boot/release/%(grml_flavour)s/linux26 apm=power-off boot=live nomce vga=791 quiet live-media-path=/live/%(grml_flavour)s/ toram=%(grml_flavour)s.squashfs %(bootoptions)s
initrd (hd0,%(install_partition)s)/boot/release/%(grml_flavour)s/initrd.gz

## flavour specific configuration for %(grml_flavour)s [grml2usb for %(grml_flavour)s: %(local_datestamp)s]
title %(grml_flavour)s-debug
kernel (hd0,%(install_partition)s)/boot/release/%(grml_flavour)s/linux26 apm=power-off boot=live nomce vga=791 quiet live-media-path=/live/%(grml_flavour)s/ debug boot=live initcall_debug%(bootoptions)s
initrd (hd0,%(install_partition)s)/boot/release/%(grml_flavour)s/initrd.gz

## flavour specific configuration for %(grml_flavour)s [grml2usb for %(grml_flavour)s: %(local_datestamp)s]
title %(grml_flavour)s-x
kernel (hd0,%(install_partition)s)/boot/release/%(grml_flavour)s/linux26 apm=power-off boot=live nomce vga=791 quiet live-media-path=/live/%(grml_flavour)s/ startx=wm-ng %(bootoptions)s
initrd (hd0,%(install_partition)s)/boot/release/%(grml_flavour)s/initrd.gz

## flavour specific configuration for %(grml_flavour)s [grml2usb for %(grml_flavour)s: %(local_datestamp)s]
title %(grml_flavour)s-nofb
kernel (hd0,%(install_partition)s)/boot/release/%(grml_flavour)s/linux26 apm=power-off boot=live nomce quiet live-media-path=/live/%(grml_flavour)s/ vga=normal video=ofonly %(bootoptions)s
initrd (hd0,%(install_partition)s)/boot/release/%(grml_flavour)s/initrd.gz

## flavour specific configuration for %(grml_flavour)s [grml2usb for %(grml_flavour)s: %(local_datestamp)s]
title %(grml_flavour)s-failsafe
kernel (hd0,%(install_partition)s)/boot/release/%(grml_flavour)s/linux26 apm=power-off boot=live nomce quiet live-media-path=/live/%(grml_flavour)s/ vga=normal boot=live noautoconfig atapicd noapic noacpi acpi=off nomodules nofirewire noudev nousb nohotplug noapm nopcmcia nosmp maxcpus=0 noscsi noagp nodma ide=nodma noswap nofstab nosound nogpm nosyslog nodhcp nocpu nodisc nomodem xmodule=vesa noraid nolvm noresume selinux=0 edd=off pci=nomsi %(bootoptions)s
initrd (hd0,%(install_partition)s)/boot/release/%(grml_flavour)s/initrd.gz

## flavour specific configuration for %(grml_flavour)s [grml2usb for %(grml_flavour)s: %(local_datestamp)s]
title %(grml_flavour)s-forensic
kernel (hd0,%(install_partition)s)/boot/release/%(grml_flavour)s/linux26 apm=power-off boot=live nomce vga=791 quiet live-media-path=/live/%(grml_flavour)s/ nofstab noraid nolvm noautoconfig noswap raid=noautodetect forensic readonly %(bootoptions)s
initrd (hd0,%(install_partition)s)/boot/release/%(grml_flavour)s/initrd.gz

## flavour specific configuration for %(grml_flavour)s [grml2usb for %(grml_flavour)s: %(local_datestamp)s]
title %(grml_flavour)s-serial
kernel (hd0,%(install_partition)s)/boot/release/%(grml_flavour)s/linux26 apm=power-off boot=live nomce quiet live-media-path=/live/%(grml_flavour)s/ vga=normal video=vesafb:off console=tty1 console=ttyS0,9600n8 %(bootoptions)s
initrd (hd0,%(install_partition)s)/boot/release/%(grml_flavour)s/initrd.gz

""" % {'grml_flavour': grml_flavour, 'local_datestamp': local_datestamp,
       'bootoptions': bootoptions, 'install_partition': install_partition } )


def generate_main_grub1_config(grml_flavour, install_partition, bootoptions):
    """Generate grub1 configuration for use via menu.lst

    @grml_flavour: name of grml flavour the configuration should be generated for"""

    local_datestamp = DATESTAMP

    return("""\
## main grub1 configuration - generated by grml2usb [main config generated at: %(local_datestamp)s]
# misc options:
timeout 30
# color red/blue green/black
splashimage=(hd0,%(install_partition)s)/boot/grub/splash.xpm.gz
foreground  = 000000
background  = FFCC33

# define entries:
title %(grml_flavour)s  - Default boot (using 1024x768 framebuffer)
kernel (hd0,%(install_partition)s)/boot/release/%(grml_flavour)s/linux26 apm=power-off vga=791 quiet boot=live nomce live-media-path=/live/%(grml_flavour)s/ %(bootoptions)s
initrd (hd0,%(install_partition)s)/boot/release/%(grml_flavour)s/initrd.gz

title Memory test (memtest86+)
kernel (hd0,%(install_partition)s)/boot/addons/memtest

title Grub - all in one image
kernel (hd0,%(install_partition)s)/boot/addons/memdisk
initrd (hd0,%(install_partition)s)/boot/addons/allinone.img

title FreeDOS
kernel (hd0,%(install_partition)s)/boot/addons/memdisk
initrd (hd0,%(install_partition)s)/boot/addons/balder10.imz

title MirOS BSD
kernel (hd0,%(install_partition)s)/boot/addons/bsd4grml/ldbsd.com

""" % {'grml_flavour': grml_flavour, 'local_datestamp': local_datestamp,
       'bootoptions': bootoptions, 'install_partition': install_partition } )


def generate_isolinux_splash(grml_flavour):
    """Generate bootsplash for isolinux/syslinux

    @grml_flavour: name of grml flavour the configuration should be generated for"""

    # TODO: adjust last bootsplash line (the one following the "Some information and boot ...")

    grml_name = grml_flavour

    return("""\
17/boot/syslinux/logo.16

Some information and boot options available via keys F2 - F10. http://grml.org/
%(grml_name)s
""" % {'grml_name': grml_name} )


def generate_main_syslinux_config(grml_flavour, bootoptions):
    """Generate main configuration for use in syslinux.cfg

    @grml_flavour: name of grml flavour the configuration should be generated for
    @bootoptions: additional bootoptions that should be used by default"""

    local_datestamp = DATESTAMP

    return("""\
## main syslinux configuration - generated by grml2usb [main config generated at: %(local_datestamp)s]
# use this to control the bootup via a serial port
# SERIAL 0 9600
DEFAULT grml
TIMEOUT 300
PROMPT 1
DISPLAY /boot/syslinux/boot.msg
F1 /boot/syslinux/boot.msg
F2 /boot/syslinux/f2
F3 /boot/syslinux/f3
F4 /boot/syslinux/f4
F5 /boot/syslinux/f5
F6 /boot/syslinux/f6
F7 /boot/syslinux/f7
F8 /boot/syslinux/f8
F9 /boot/syslinux/f9
F10 /boot/syslinux/f10
## end of main configuration

## global configuration
# the default option (using %(grml_flavour)s)
LABEL  grml
KERNEL /boot/release/%(grml_flavour)s/linux26
APPEND initrd=/boot/release/%(grml_flavour)s/initrd.gz apm=power-off boot=live nomce vga=791 quiet live-media-path=/live/%(grml_flavour)s/ %(bootoptions)s

# memtest
LABEL  memtest
KERNEL /boot/addons/memtest

# grub
LABEL grub
MENU LABEL grub
KERNEL /boot/addons/memdisk
APPEND initrd=/boot/addons/allinone.img

# dos
LABEL dos
MENU LABEL dos
KERNEL /boot/addons/memdisk
APPEND initrd=/boot/addons/balder10.imz

# bsd
LABEL bsd
MENU LABEL bsd
KERNEL /boot/addons/bsd4grml/ldbsd.com

# hardware detection tool
MENU LABEL hdt
KERNEL /boot/addons/hdt.c32
APPEND pciids=/boot/addons/pci.ids

## end of global configuration
""" % {'grml_flavour': grml_flavour, 'local_datestamp': local_datestamp, 'bootoptions': bootoptions} )


def generate_flavour_specific_syslinux_config(grml_flavour, bootoptions):
    """Generate flavour specific configuration for use in syslinux.cfg

    @grml_flavour: name of grml flavour the configuration should be generated for
    @bootoptions: bootoptions that should be used as a default"""

    local_datestamp = DATESTAMP

    return("""\

# flavour specific configuration for %(grml_flavour)s [grml2usb for %(grml_flavour)s: %(local_datestamp)s]
LABEL  %(grml_flavour)s
KERNEL /boot/release/%(grml_flavour)s/linux26
APPEND initrd=/boot/release/%(grml_flavour)s/initrd.gz apm=power-off boot=live nomce vga=791 quiet live-media-path=/live/%(grml_flavour)s/ %(bootoptions)s

# flavour specific configuration for %(grml_flavour)s [grml2usb for %(grml_flavour)s: %(local_datestamp)s]
LABEL  %(grml_flavour)s-persistent
KERNEL /boot/release/%(grml_flavour)s/linux26
APPEND initrd=/boot/release/%(grml_flavour)s/initrd.gz apm=power-off boot=live nomce vga=791 quiet persistent live-media-path=/live/%(grml_flavour)s/ %(bootoptions)s

# flavour specific configuration for %(grml_flavour)s [grml2usb for %(grml_flavour)s: %(local_datestamp)s]
LABEL  %(grml_flavour)s2ram
KERNEL /boot/release/%(grml_flavour)s/linux26
APPEND initrd=/boot/release/%(grml_flavour)s/initrd.gz apm=power-off boot=live nomce vga=791 quiet live-media-path=/live/%(grml_flavour)s/ toram=%(grml_flavour)s.squashfs %(bootoptions)s

# flavour specific configuration for %(grml_flavour)s [grml2usb for %(grml_flavour)s: %(local_datestamp)s]
LABEL  %(grml_flavour)s-debug
KERNEL /boot/release/%(grml_flavour)s/linux26
APPEND initrd=/boot/release/%(grml_flavour)s/initrd.gz apm=power-off boot=live nomce vga=791 quiet live-media-path=/live/%(grml_flavour)s/ debug boot=live initcall_debug%(bootoptions)s

# flavour specific configuration for %(grml_flavour)s [grml2usb for %(grml_flavour)s: %(local_datestamp)s]
LABEL  %(grml_flavour)s-x
KERNEL /boot/release/%(grml_flavour)s/linux26
APPEND initrd=/boot/release/%(grml_flavour)s/initrd.gz apm=power-off boot=live nomce vga=791 quiet live-media-path=/live/%(grml_flavour)s/ startx=wm-ng %(bootoptions)s

# flavour specific configuration for %(grml_flavour)s [grml2usb for %(grml_flavour)s: %(local_datestamp)s]
LABEL  %(grml_flavour)s-nofb
KERNEL /boot/release/%(grml_flavour)s/linux26
APPEND initrd=/boot/release/%(grml_flavour)s/initrd.gz apm=power-off boot=live nomce quiet live-media-path=/live/%(grml_flavour)s/ vga=normal video=ofonly %(bootoptions)s

# flavour specific configuration for %(grml_flavour)s [grml2usb for %(grml_flavour)s: %(local_datestamp)s]
LABEL  %(grml_flavour)s-failsafe
KERNEL /boot/release/%(grml_flavour)s/linux26
APPEND initrd=/boot/release/%(grml_flavour)s/initrd.gz apm=power-off boot=live nomce quiet live-media-path=/live/%(grml_flavour)s/ vga=normal boot=live noautoconfig atapicd noapic noacpi acpi=off nomodules nofirewire noudev nousb nohotplug noapm nopcmcia nosmp maxcpus=0 noscsi noagp nodma ide=nodma noswap nofstab nosound nogpm nosyslog nodhcp nocpu nodisc nomodem xmodule=vesa noraid nolvm noresume selinux=0 edd=off pci=nomsi %(bootoptions)s

# flavour specific configuration for %(grml_flavour)s [grml2usb for %(grml_flavour)s: %(local_datestamp)s]
LABEL  %(grml_flavour)s-forensic
KERNEL /boot/release/%(grml_flavour)s/linux26
APPEND initrd=/boot/release/%(grml_flavour)s/initrd.gz apm=power-off boot=live nomce vga=791 quiet live-media-path=/live/%(grml_flavour)s/ nofstab noraid nolvm noautoconfig noswap raid=noautodetect forensic readonly %(bootoptions)s

# flavour specific configuration for %(grml_flavour)s [grml2usb for %(grml_flavour)s: %(local_datestamp)s]
LABEL  %(grml_flavour)s-serial
KERNEL /boot/release/%(grml_flavour)s/linux26
APPEND initrd=/boot/release/%(grml_flavour)s/initrd.gz apm=power-off boot=live nomce quiet live-media-path=/live/%(grml_flavour)s/ vga=normal video=vesafb:off console=tty1 console=ttyS0,9600n8 %(bootoptions)s
""" % {'grml_flavour': grml_flavour, 'local_datestamp': local_datestamp, 'bootoptions': bootoptions} )


def install_grub(device):
    """Install grub on specified device.

    @mntpoint: mountpoint of device where grub should install its files to
    @device: partition where grub should be installed to"""

    if options.dryrun:
        logging.info("Would execute grub-install [--root-directory=mount_point] %s now.", device)
    else:
        device_mountpoint = tempfile.mkdtemp(prefix="grml2usb")
        register_tmpfile(device_mountpoint)
        try:
            try:
                mount(device, device_mountpoint, "")

                # If using --grub-mbr then make sure we install grub in MBR instead of PBR
                # Thanks to grub2. NOT.
                if options.grubmbr:
                    logging.debug("Using option --grub-mbr ...")
                    if device[-1:].isdigit():
                        grub_device = re.match(r'(.*?)\d*$', device).group(1)
                    else:
                        grub_device = device
                else:
                    grub_device = device

                logging.debug("grub-install --recheck --no-floppy --root-directory=%s %s",
                    device_mountpoint, grub_device)
                proc = subprocess.Popen(["grub-install", "--recheck", "--no-floppy",
                    "--root-directory=%s" % device_mountpoint, grub_device], stdout=file(os.devnull, "r+"))
                proc.wait()
                if proc.returncode != 0:
                    # raise Exception("error executing grub-install")
                    logging.critical("Fatal: error executing grub-install (please check the grml2usb FAQ or use --syslinux)")
                    logging.critical("Note:  if using grub2 consider using the --grub-mbr option because grub2's PBR feature is broken.")
                    cleanup()
                    sys.exit(1)
            except CriticalException, error:
                logging.critical("Fatal: %s", error)
                cleanup()
                sys.exit(1)

        finally:
            unmount(device_mountpoint, "")
            os.rmdir(device_mountpoint)
            unregister_tmpfile(device_mountpoint)


def install_syslinux(device):
    """Install syslinux on specified device.

    @device: partition where syslinux should be installed to"""

    if options.dryrun:
        logging.info("Would install syslinux as bootloader on %s", device)
        return 0

    # syslinux -d boot/isolinux /dev/sdb1
    logging.info("Installing syslinux as bootloader")
    logging.debug("syslinux -d boot/syslinux %s", device)
    proc = subprocess.Popen(["syslinux", "-d", "boot/syslinux", device])
    proc.wait()
    if proc.returncode != 0:
        raise CriticalException("Error executing syslinux (either try --fat16 or use grub?)")


def install_bootloader(device):
    """Install bootloader on specified device.

    @device: partition where bootloader should be installed to"""

    # by default we use grub, so install syslinux only on request
    if options.syslinux:
        try:
            install_syslinux(device)
        except CriticalException, error:
            logging.critical("Fatal: %s", error)
            cleanup()
            sys.exit(1)
    else:
        if not which("grub-install"):
            logging.critical("Fatal: grub-install not available (please install the grub package or use the --syslinux option)")
            cleanup()
            sys.exit(1)
        else:
            try:
                install_grub(device)
            except CriticalException, error:
                logging.critical("Fatal: %s", error)
                cleanup()
                sys.exit(1)


def execute_lilo(lilo, device):
    """execute lilo for activating the partitions in the MBR

    @lilo: path of lilo executable
    @device: device where lilo should be executed on"""

    # to support -A for extended partitions:
    logging.info("Activating partitions in MBR via lilo")
    logging.debug("%s -S /dev/null -M %s ext", lilo, device)
    proc = subprocess.Popen([lilo, "-S", "/dev/null", "-M", device, "ext"])
    proc.wait()
    if proc.returncode != 0:
        raise Exception("error executing lilo")

    # activate partition:
    logging.debug("%s -S /dev/null -A %s 1", lilo, device)
    proc = subprocess.Popen([lilo, "-S", "/dev/null", "-A", device, "1"])
    proc.wait()
    if proc.returncode != 0:
        raise Exception("error executing lilo")


def install_syslinux_mbr(device):
    """install syslinux's master boot record (MBR) on the specified device

    @device: device where MBR of syslinux should be installed to"""

    # make sure we have syslinux available
    if not which("syslinux") and not options.copyonly:
        raise Exception("syslinux not available (either install it or consider dropping the --syslinux option)")

    # lilo's mbr is broken, use the one from syslinux instead:
    if not os.path.isfile("/usr/lib/syslinux/mbr.bin"):
        raise Exception("/usr/lib/syslinux/mbr.bin can not be read")

    logging.info("Installing syslinux MBR")
    logging.debug("cat /usr/lib/syslinux/mbr.bin > %s", device)
    try:
        # TODO -> use Popen instead?
        retcode = subprocess.call("cat /usr/lib/syslinux/mbr.bin > "+ device, shell=True)
        if retcode < 0:
            logging.critical("Error copying MBR to device (%s)", retcode)
    except OSError, error:
        logging.critical("Execution failed: %s", error)


def install_mir_mbr(mbrtemplate, device, partition, ismirbsdmbr=True):
    """install 'mbr' master boot record (MBR) on a device

    Retrieve the partition table from "device", install an MBR from the
    "mbrtemplate" file, set the "partition" (0..3) active, and install the
    result back to "device".

    @mbrtemplate: default MBR file

    @device: name of a file assumed to be a hard disc (or USB stick) image, or
    something like "/dev/sdb"

    @partition: must be a number between 0 and 3, inclusive

    @mbrtemplate: must be a valid MBR file of at least 440 (or 439 if
    ismirbsdmbr) bytes.

    @ismirbsdmbr: if true then ignore the active flag, set the mirbsdmbr
    specific flag to 0/1/2/3 and set the MBR's default value accordingly. If
    false then leave the mirbsdmbr specific flag set to FFh, set all
    active flags to 0 and set the active flag of the partition to 80h.  Note:
    behaviour of mirbsdmbr: if flag = 0/1/2/3 then use it, otherwise search for
    the active flag."""

    logging.info("Installing default MBR")

    if not os.path.isfile(mbrtemplate):
        logging.critical("Error: %s can not be read.", mbrtemplate)
        raise CriticalException("Error installing MBR (either try --syslinux-mbr or install missing file?)")

    if (partition < 0) or (partition > 3):
        raise ValueError("partition must be between 0 and 3")

    if ismirbsdmbr:
        nmbrbytes = 439
    else:
        nmbrbytes = 440

    tmpf = tempfile.NamedTemporaryFile()

    logging.debug("executing: dd if='%s' of='%s' bs=512 count=1", device, tmpf.name)
    proc = subprocess.Popen(["dd", "if=%s" % device, "of=%s" % tmpf.name, "bs=512", "count=1"], stderr=file(os.devnull, "r+"))
    proc.wait()
    if proc.returncode != 0:
        raise Exception("error executing dd (first run)")

    logging.debug("executing: dd if=%s of=%s bs=%s count=1 conv=notrunc", mbrtemplate,
        tmpf.name, nmbrbytes)
    proc = subprocess.Popen(["dd", "if=%s" % mbrtemplate, "of=%s" % tmpf.name, "bs=%s" % nmbrbytes,
        "count=1", "conv=notrunc"], stderr=file(os.devnull, "r+"))
    proc.wait()
    if proc.returncode != 0:
        raise Exception("error executing dd (second run)")

    mbrcode = tmpf.file.read(512)
    if len(mbrcode) < 512:
        raise EOFError("MBR size (%d) < 512" % len(mbrcode))

    if ismirbsdmbr:
        mbrcode = mbrcode[0:439] + chr(partition) + \
          mbrcode[440:510] + "\x55\xAA"
    else:
        actives = ["\x00", "\x00", "\x00", "\x00"]
        actives[partition] = "\x80"
        mbrcode = mbrcode[0:446] + actives[0] + \
          mbrcode[447:462] + actives[1] + \
          mbrcode[463:478] + actives[2] + \
          mbrcode[479:494] + actives[3] + \
          mbrcode[495:510] + "\x55\xAA"

    tmpf.file.seek(0)
    tmpf.file.truncate()
    tmpf.file.write(mbrcode)
    tmpf.file.close()

    logging.debug("executing: dd if='%s' of='%s' bs=512 count=1 conv=notrunc", tmpf.name, device)
    proc = subprocess.Popen(["dd", "if=%s" % tmpf.name, "of=%s" % device, "bs=512", "count=1",
                            "conv=notrunc"], stderr=file(os.devnull, "r+"))
    proc.wait()
    if proc.returncode != 0:
        raise Exception("error executing dd (third run)")
    del tmpf


def handle_syslinux_mbr(device):
    """Install syslinux master boot record on given device

    @device: device where MBR should be installed to"""

    if not is_writeable(device):
        raise IOError("device not writeable for user")

    # try to use system's lilo
    if which("lilo"):
        lilo = which("lilo")
    else:
        # otherwise fall back to our static version
        from platform import architecture
        if architecture()[0] == '64bit':
            lilo = GRML2USB_BASE + '/lilo/lilo.static.amd64'
        else:
            lilo = GRML2USB_BASE + '/lilo/lilo.static.i386'
    # finally prefer a specified lilo executable
    if options.lilobin:
        lilo = options.lilobin

    if not is_exe(lilo):
        raise Exception("lilo executable can not be execute")

    if options.dryrun:
        logging.info("Would install MBR running lilo and using syslinux.")
        return 0

    execute_lilo(lilo, device)
    install_syslinux_mbr(device)


def is_writeable(device):
    """Check if the device is writeable for the current user

    @device: partition where bootloader should be installed to"""

    if not device:
        return False
        #raise Exception("no device for checking write permissions")

    if not os.path.exists(device):
        return False

    return os.access(device, os.W_OK) and os.access(device, os.R_OK)


def mount(source, target, mount_options):
    """Mount specified source on given target

    @source: name of device/ISO that should be mounted
    @target: directory where the ISO should be mounted to
    @options: mount specific options"""

    # note: options.dryrun does not work here, as we have to
    # locate files and identify the grml flavour

    for x in file('/proc/mounts').readlines():
        if x.startswith(source):
            raise CriticalException("Error executing mount: %s already mounted - please unmount before invoking grml2usb" % source)

    if os.path.isdir(source):
        logging.debug("Source %s is not a device, therefore not mounting.", source)
        return 0

    logging.debug("mount %s %s %s", mount_options, source, target)
    proc = subprocess.Popen(["mount"] + list(mount_options) + [source, target])
    proc.wait()
    if proc.returncode != 0:
        raise CriticalException("Error executing mount (no filesystem on the partition?)")
    else:
        logging.debug("register_mountpoint(%s)", target)
        register_mountpoint(target)


def unmount(target, unmount_options):
    """Unmount specified target

    @target: target where something is mounted on and which should be unmounted
    @options: options for umount command"""

    # make sure we unmount only already mounted targets
    target_unmount = False
    mounts = open('/proc/mounts').readlines()
    mountstring = re.compile(".*%s.*" % re.escape(os.path.realpath(target)))
    for line in mounts:
        if re.match(mountstring, line):
            target_unmount = True

    if not target_unmount:
        logging.debug("%s not mounted anymore", target)
    else:
        logging.debug("umount %s %s", list(unmount_options), target)
        proc = subprocess.Popen(["umount"] + list(unmount_options) + [target])
        proc.wait()
        if proc.returncode != 0:
            raise Exception("Error executing umount")
        else:
            logging.debug("unregister_mountpoint(%s)", target)
            unregister_mountpoint(target)


def check_for_usbdevice(device):
    """Check whether the specified device is a removable USB device

    @device: device name, like /dev/sda1 or /dev/sda
    """

    usbdevice = re.match(r'/dev/(.*?)\d*$', device).group(1)
    # newer systems:
    usbdev = os.path.realpath('/sys/class/block/' + usbdevice + '/removable')
    if not os.path.isfile(usbdev):
        # Ubuntu with kernel 2.6.24 for example:
        usbdev = os.path.realpath('/sys/block/' + usbdevice + '/removable')

    if os.path.isfile(usbdev):
        is_usb = open(usbdev).readline()
        if is_usb.find("1"):
            return 0

    return 1


def check_for_fat(partition):
    """Check whether specified partition is a valid VFAT/FAT16 filesystem

    @partition: device name of partition"""

    try:
        udev_info = subprocess.Popen(["/sbin/blkid", "-s", "TYPE", "-o", "value", partition],
                    stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        filesystem = udev_info.communicate()[0].rstrip()

        if udev_info.returncode == 2:
            raise CriticalException("Failed to read device %s"
                                    " (wrong UID/permissions or device/directory not present?)" % partition)

        if options.syslinux and filesystem != "vfat":
            raise CriticalException("Partition %s does not contain a FAT16 filesystem. (Use --fat16 or run mkfs.vfat %s)" % (partition, partition))

    except OSError:
        raise CriticalException("Sorry, /sbin/blkid not available (install e2fsprogs?)")


def mkdir(directory):
    """Simple wrapper around os.makedirs to get shell mkdir -p behaviour"""

    # just silently pass as it's just fine it the directory exists
    if not os.path.isdir(directory):
        try:
            os.makedirs(directory)
        # pylint: disable-msg=W0704
        except OSError:
            pass


def exec_rsync(source, target):
    """Simple wrapper around rsync to install files

    @source: source file/directory
    @target: target file/directory"""
    logging.debug("Source: %s / Target: %s", source, target)
    proc = subprocess.Popen(["rsync", "-rlptDH", "--inplace", source, target])
    proc.wait()
    if proc.returncode == 12:
        logging.critical("Fatal: No space left on device")
        cleanup()
        sys.exit(1)

    if proc.returncode != 0:
        logging.critical("Fatal: could not install %s", source)
        cleanup()
        sys.exit(1)


def copy_system_files(grml_flavour, iso_mount, target):
    """copy grml's main files (like squashfs, kernel and initrd) to a given target

    @grml_flavour: name of grml flavour the configuration should be generated for
    @iso_mount: path where a grml ISO is mounted on
    @target: path where grml's main files should be copied to"""

    squashfs = search_file(grml_flavour + '.squashfs', iso_mount)
    if squashfs is None:
        logging.critical("Fatal: squashfs file not found")
        raise CriticalException("error locating squashfs file")
    else:
        squashfs_target = target + '/live/' + grml_flavour + '/'
        execute(mkdir, squashfs_target)
    exec_rsync(squashfs, squashfs_target + grml_flavour + '.squashfs')

    filesystem_module = search_file('filesystem.module', iso_mount)
    if filesystem_module is None:
        logging.critical("Fatal: filesystem.module not found")
    else:
        exec_rsync(filesystem_module, squashfs_target + 'filesystem.module')

    release_target = target + '/boot/release/' + grml_flavour
    execute(mkdir, release_target)

    kernel = search_file('linux26', iso_mount)
    if kernel is None:
        logging.critical("Fatal kernel not found")
    else:
        exec_rsync(kernel, release_target + '/linux26')

    initrd = search_file('initrd.gz', iso_mount)
    if initrd is None:
        logging.critical("Fatal: initrd not found")
    else:
        exec_rsync(initrd, release_target + '/initrd.gz')


def copy_grml_files(iso_mount, target):
    """copy some minor grml files to a given target

    @iso_mount: path where a grml ISO is mounted on
    @target: path where grml's main files should be copied to"""

    grml_target = target + '/grml/'
    execute(mkdir, grml_target)

    for myfile in 'grml-cheatcodes.txt', 'grml-version', 'LICENSE.txt', 'md5sums', 'README.txt':
        grml_file = search_file(myfile, iso_mount)
        if grml_file is None:
            logging.warn("Warning: myfile %s could not be found - can not install it", myfile)
        else:
            exec_rsync(grml_file, grml_target + myfile)

    grml_web_target = grml_target + '/web/'
    execute(mkdir, grml_web_target)

    for myfile in 'index.html', 'style.css':
        grml_file = search_file(myfile, iso_mount)
        if grml_file is None:
            logging.warn("Warning: myfile %s could not be found - can not install it")
        else:
            exec_rsync(grml_file, grml_web_target + myfile)

    grml_webimg_target = grml_web_target + '/images/'
    execute(mkdir, grml_webimg_target)

    for myfile in 'button.png', 'favicon.png', 'linux.jpg', 'logo.png':
        grml_file = search_file(myfile, iso_mount)
        if grml_file is None:
            logging.warn("Warning: myfile %s could not be found - can not install it")
        else:
            exec_rsync(grml_file, grml_webimg_target + myfile)


def copy_addons(iso_mount, target):
    """copy grml's addons files (like allinoneimg, bsd4grml,..) to a given target

    @iso_mount: path where a grml ISO is mounted on
    @target: path where grml's main files should be copied to"""

    addons = target + '/boot/addons/'
    execute(mkdir, addons)

    # grub all-in-one image
    allinoneimg = search_file('allinone.img', iso_mount)
    if allinoneimg is None:
        logging.warn("Warning: allinone.img not found (that's fine if you don't need it)")
    else:
        exec_rsync(allinoneimg, addons + 'allinone.img')

    # bsd imag
    bsdimg = search_file('bsd4grml', iso_mount)
    if bsdimg is None:
        logging.warn("Warning: bsd4grml not found (that's fine if you don't need it)")
    else:
        exec_rsync(bsdimg, addons + '/')

    # freedos image
    balderimg = search_file('balder10.imz', iso_mount)
    if balderimg is None:
        logging.warn("Warning: balder10.imz not found (that's fine if you don't need it)")
    else:
        exec_rsync(balderimg, addons + 'balder10.imz')

    # install hdt and pci.ids only when using syslinux (grub doesn't support it)
    if options.syslinux:
        # hdt (hardware detection tool) image
        hdtimg = search_file('hdt.c32', iso_mount)
        if hdtimg:
            exec_rsync(hdtimg, addons + '/hdt.c32')

        # pci.ids file
        picids = search_file('pci.ids', iso_mount)
        if picids:
            exec_rsync(picids, addons + '/pci.ids')

    # memdisk image
    memdiskimg = search_file('memdisk', iso_mount)
    if memdiskimg is None:
        logging.warn("Warning: memdisk not found (that's fine if you don't need it)")
    else:
        exec_rsync(memdiskimg, addons + 'memdisk')

    # memtest86+ image
    memtestimg = search_file('memtest', iso_mount)
    if memtestimg is None:
        logging.warn("Warning: memtest not found (that's fine if you don't need it)")
    else:
        exec_rsync(memtestimg, addons + 'memtest')


def copy_bootloader_files(iso_mount, target):
    """copy grml's bootloader files to a given target

    @iso_mount: path where a grml ISO is mounted on
    @target: path where grml's main files should be copied to"""

    syslinux_target = target + '/boot/syslinux/'
    execute(mkdir, syslinux_target)

    logo = search_file('logo.16', iso_mount)
    exec_rsync(logo, syslinux_target + 'logo.16')

    for ffile in 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'f10':
        bootsplash = search_file(ffile, iso_mount)
        exec_rsync(bootsplash, syslinux_target + ffile)

    grub_target = target + '/boot/grub/'
    execute(mkdir, grub_target)

    if not os.path.isfile(GRML2USB_BASE + "/grub/splash.xpm.gz"):
        logging.critical("Error: %s/grub/splash.xpm.gz can not be read.", GRML2USB_BASE)
        logging.critical("Please make sure you've installed the grml2usb (Debian) package!")
        raise
    else:
        exec_rsync(GRML2USB_BASE + '/grub/splash.xpm.gz', grub_target + 'splash.xpm.gz')

    # grml splash in grub
    if os.path.isfile(GRML2USB_BASE + "/grub/grml.png"):
        exec_rsync(GRML2USB_BASE + '/grub/grml.png', grub_target + 'grml.png')

    # font file for graphical bootsplash in grub
    if os.path.isfile("/usr/share/grub/ascii.pf2"):
        exec_rsync('/usr/share/grub/ascii.pf2', grub_target + 'ascii.pf2')

def install_iso_files(grml_flavour, iso_mount, device, target):
    """Copy files from ISO to given target

    @grml_flavour: name of grml flavour the configuration should be generated for
    @iso_mount: path where a grml ISO is mounted on
    @device: device/partition where bootloader should be installed to
    @target: path where grml's main files should be copied to"""

    # TODO => several improvements:
    # * make sure grml_flavour, iso_mount, target are set when the function is called, otherwise raise exception
    # * provide alternative search_file() if file information is stored in a config.ini file?
    # * catch "install: .. No space left on device" & CO

    if options.dryrun:
        return 0
    elif not options.bootloaderonly:
        logging.info("Copying files. This might take a while....")
        try:
            copy_system_files(grml_flavour, iso_mount, target)
            copy_grml_files(iso_mount, target)
        except CriticalException, error:
            logging.critical("Execution failed: %s", error)
            sys.exit(1)

    if not options.skipaddons:
        if grml_flavour.endswith('-small'):
            logging.info("Note: grml-small doesn't provide any addons, not installing them therefore.")
        else:
            copy_addons(iso_mount, target)

    if not options.copyonly:
        copy_bootloader_files(iso_mount, target)

        if not options.dryrun:
            handle_bootloader_config(grml_flavour, device, target)

    # make sure we sync filesystems before returning
    proc = subprocess.Popen(["sync"])
    proc.wait()


def uninstall_files(device):
    """Get rid of all grml files on specified device

    @device: partition where grml2usb files should be removed from"""

    # TODO - not implemented yet
    logging.critical("TODO: uninstalling files from %s not yet implement, sorry.", device)


def identify_grml_flavour(mountpath):
    """Get name of grml flavour

    @mountpath: path where the grml ISO is mounted to
    @return: name of grml-flavour"""

    version_file = search_file('grml-version', mountpath)

    if version_file == "":
        logging.critical("Error: could not find grml-version file.")
        raise

    try:
        tmpfile = open(version_file, 'r')
        grml_info = tmpfile.readline()
        grml_flavour = re.match(r'[\w-]*', grml_info).group()
    except TypeError:
        raise
    except Exception, e:
        logging.critical("Unexpected error: %s", e)
        raise

    return grml_flavour


def handle_grub1_config(grml_flavour, install_partition, grub_target, bootopt):
    """Main handler for generating grub1 configuration

    @grml_flavour: name of grml flavour the configuration should be generated for
    @install_partition: partition number for use in (hd0,X)
    @grub_target: path of grub's configuration files
    @bootoptions: additional bootoptions that should be used by default"""

    # grub1 config
    grub1_cfg = grub_target + 'menu.lst'
    logging.debug("Creating grub1 configuration file (menu.lst)")

    # install main configuration only *once*, no matter how many ISOs we have:
    if os.path.isfile(grub1_cfg):
        string = open(grub1_cfg).readline()
        main_identifier = re.compile(".*main config generated at: %s.*" % re.escape(str(DATESTAMP)))
        if not re.match(main_identifier, string):
            grub1_config_file = open(grub1_cfg, 'w')
            grub1_config_file.write(generate_main_grub1_config(grml_flavour, install_partition, bootopt))
            grub1_config_file.close()
    else:
        grub1_config_file = open(grub1_cfg, 'w')
        grub1_config_file.write(generate_main_grub1_config(grml_flavour, install_partition, bootopt))
        grub1_config_file.close()

    grub_flavour_config = True
    if os.path.isfile(grub1_cfg):
        string = open(grub1_cfg).readlines()
        flavour = re.compile("grml2usb for %s: %s" % (re.escape(grml_flavour), re.escape(str(DATESTAMP))))
        for line in string:
            if flavour.match(line):
                grub_flavour_config = False

    if grub_flavour_config:
        grub1_config_file = open(grub1_cfg, 'a')
        grub1_config_file.write(generate_flavour_specific_grub1_config(grml_flavour, install_partition, bootopt))
        grub1_config_file.close()

    # make sure grub.conf isn't a symlink but a plain file instead,
    # otherwise it will break on FAT16 filesystems
    # this works around grub-install of (at least) Fedora 10
    if os.path.isfile(grub1_cfg):
        grubconf = grub_target + 'grub.conf'
        if not os.path.islink(grubconf):
            import shutil
            shutil.copyfile(grub1_cfg, grub_target + 'grub.conf')

def handle_grub2_config(grml_flavour, grub_target, bootopt):
    """Main handler for generating grub2 configuration

    @grml_flavour: name of grml flavour the configuration should be generated for
    @grub_target: path of grub's configuration files
    @bootoptions: additional bootoptions that should be used by default"""

    # grub2 config
    grub2_cfg = grub_target + 'grub.cfg'
    logging.debug("Creating grub2 configuration file (grub.lst)")

    global GRML_DEFAULT

    # install main configuration only *once*, no matter how many ISOs we have:
    grub_flavour_is_default = False
    if os.path.isfile(grub2_cfg):
        string = open(grub2_cfg).readline()
        main_identifier = re.compile(".*main config generated at: %s.*" % re.escape(str(DATESTAMP)))
        if not re.match(main_identifier, string):
            grub2_config_file = open(grub2_cfg, 'w')
            GRML_DEFAULT = grml_flavour
            grub_flavour_is_default = True
            grub2_config_file.write(generate_main_grub2_config(grml_flavour, bootopt))
            grub2_config_file.close()
    else:
        grub2_config_file = open(grub2_cfg, 'w')
        GRML_DEFAULT = grml_flavour
        grub_flavour_is_default = True
        grub2_config_file.write(generate_main_grub2_config(grml_flavour, bootopt))
        grub2_config_file.close()

    # install flavour specific configuration only *once* as well
    grub_flavour_config = True
    if os.path.isfile(grub2_cfg):
        string = open(grub2_cfg).readlines()
        flavour = re.compile("grml2usb for %s: %s" % (re.escape(grml_flavour), re.escape(str(DATESTAMP))))
        for line in string:
            if flavour.match(line):
                grub_flavour_config = False

    if grub_flavour_config:
        grub2_config_file = open(grub2_cfg, 'a')
        # display only if the grml flavour isn't the default
        if not grub_flavour_is_default:
            GRML_FLAVOURS.add(grml_flavour)
        grub2_config_file.write(generate_flavour_specific_grub2_config(grml_flavour, bootopt))
        grub2_config_file.close()


def handle_grub_config(grml_flavour, device, target):
    """Main handler for generating grub (v1 and v2) configuration

    @grml_flavour: name of grml flavour the configuration should be generated for
    @device: device/partition where grub should be installed to
    @target: path of grub's configuration files"""

    logging.debug("Generating grub configuration")

    grub_target = target + '/boot/grub/'
    execute(mkdir, grub_target)

    if os.path.isdir(device):
        install_grub1_partition = None
    else:
        if device[-1:].isdigit():
            install_grub1_partition = int(device[-1:]) - 1
        else:
            raise CriticalException("error validating partition schema (raw device?)")

    # do NOT write "None" in kernel cmdline
    if options.bootoptions is None:
        bootopt = ""
    else:
        bootopt = options.bootoptions

    # write menu.lst
    handle_grub1_config(grml_flavour, install_grub1_partition, grub_target, bootopt)
    # write grub.cfg
    handle_grub2_config(grml_flavour, grub_target, bootopt)


def handle_syslinux_config(grml_flavour, target):
    """Main handler for generating syslinux configuration

    @grml_flavour: name of grml flavour the configuration should be generated for
    @target: path of syslinux's configuration files"""

    # do NOT write "None" in kernel cmdline
    if options.bootoptions is None:
        bootopt = ""
    else:
        bootopt = options.bootoptions

    logging.debug("Generating syslinux configuration")
    syslinux_target = target + '/boot/syslinux/'
    # should be present via  copy_bootloader_files(), but make sure it exits:
    execute(mkdir, syslinux_target)
    syslinux_cfg = syslinux_target + 'syslinux.cfg'

    global GRML_DEFAULT

    # install main configuration only *once*, no matter how many ISOs we have:
    syslinux_flavour_is_default = False
    if os.path.isfile(syslinux_cfg):
        string = open(syslinux_cfg).readline()
        main_identifier = re.compile(".*main config generated at: %s.*" % re.escape(str(DATESTAMP)))
        if not re.match(main_identifier, string):
            syslinux_config_file = open(syslinux_cfg, 'w')
            GRML_DEFAULT = grml_flavour
            syslinux_flavour_is_default = True
            syslinux_config_file.write(generate_main_syslinux_config(grml_flavour, bootopt))
            syslinux_config_file.close()
    else:
        syslinux_config_file = open(syslinux_cfg, 'w')
        GRML_DEFAULT = grml_flavour
        syslinux_flavour_is_default = True
        syslinux_config_file.write(generate_main_syslinux_config(grml_flavour, bootopt))
        syslinux_config_file.close()

    # install flavour specific configuration only *once* as well
    syslinux_flavour_config = True
    if os.path.isfile(syslinux_cfg):
        string = open(syslinux_cfg).readlines()
        flavour = re.compile("grml2usb for %s: %s" % (re.escape(grml_flavour), re.escape(str(DATESTAMP))))
        for line in string:
            if flavour.match(line):
                syslinux_flavour_config = False

    if syslinux_flavour_config:
        syslinux_config_file = open(syslinux_cfg, 'a')
        # display only if the grml flavour isn't the default
        if not syslinux_flavour_is_default:
            GRML_FLAVOURS.add(grml_flavour)
        syslinux_config_file.write(generate_flavour_specific_syslinux_config(grml_flavour, bootopt))
        syslinux_config_file.close()

    logging.debug("Generating isolinux/syslinux splash %s", syslinux_target + 'boot.msg')
    isolinux_splash = open(syslinux_target + 'boot.msg', 'w')
    isolinux_splash.write(generate_isolinux_splash(grml_flavour))
    isolinux_splash.close()


def handle_bootloader_config(grml_flavour, device, target):
    """Main handler for generating bootloader's configuration

    @grml_flavour: name of grml flavour the configuration should be generated for
    @device: device/partition where bootloader should be installed to
    @target: path of bootloader's configuration files"""

    if options.skipsyslinuxconfig:
        logging.info("Skipping generation of syslinux configuration as requested.")
    else:
        try:
            handle_syslinux_config(grml_flavour, target)
        except CriticalException, error:
            logging.critical("Fatal: %s", error)
            sys.exit(1)

    if options.skipgrubconfig:
        logging.info("Skipping generation of grub configuration as requested.")
    else:
        try:
            handle_grub_config(grml_flavour, device, target)
        except CriticalException, error:
            logging.critical("Fatal: %s", error)
            sys.exit(1)

def handle_dir(live_image, device):
    """Main logic for copying files of the currently running grml system.

    @live_image: directory where currently running live system resides (usually /live/image)
    @device: partition where the specified ISO should be installed to"""

    logging.info("Using %s as install base", live_image)

    if os.path.isdir(device):
        logging.info("Specified target is a directory, therefore not mounting.")
        device_mountpoint = device
        remove_device_mountpoint = False
    else:
        device_mountpoint = tempfile.mkdtemp(prefix="grml2usb")
        register_tmpfile(device_mountpoint)
        remove_device_mountpoint = True
        try:
            mount(device, device_mountpoint, "")
        except CriticalException, error:
            logging.critical("Fatal: %s", error)
            cleanup()
            sys.exit(1)

    try:
        try:
            grml_flavour = identify_grml_flavour(live_image)
            logging.info("Identified grml flavour \"%s\".", grml_flavour)
            install_iso_files(grml_flavour, live_image, device, device_mountpoint)
        except TypeError:
            logging.critical("Fatal: a critical error happend during execution (not a grml ISO?), giving up")
            sys.exit(1)
    finally:
        if remove_device_mountpoint:
            try:
                unmount(device_mountpoint, "")
                if os.path.isdir(device_mountpoint):
                    os.rmdir(device_mountpoint)
                    unregister_tmpfile(device_mountpoint)
            except CriticalException, error:
                logging.critical("Fatal: %s", error)
                cleanup()


def handle_iso(iso, device):
    """Main logic for mounting ISOs and copying files.

    @iso: full path to the ISO that should be installed to the specified device
    @device: partition where the specified ISO should be installed to"""

    logging.info("Using ISO %s", iso)

    iso_mountpoint = tempfile.mkdtemp(prefix="grml2usb")
    register_tmpfile(iso_mountpoint)
    remove_iso_mountpoint = True

    if not os.path.isfile(iso):
        logging.critical("Fatal: specified ISO %s could not be read", iso)
        cleanup()
        sys.exit(1)

    try:
        mount(iso, iso_mountpoint, ["-o", "loop", "-t", "iso9660"])
    except CriticalException, error:
        logging.critical("Fatal: %s", error)
        sys.exit(1)

    if os.path.isdir(device):
        logging.info("Specified target is a directory, therefore not mounting.")
        device_mountpoint = device
        remove_device_mountpoint = False
        # skip_mbr = True
    else:
        device_mountpoint = tempfile.mkdtemp(prefix="grml2usb")
        register_tmpfile(device_mountpoint)
        remove_device_mountpoint = True
        try:
            mount(device, device_mountpoint, "")
        except CriticalException, error:
            logging.critical("Fatal: %s", error)
            cleanup()
            sys.exit(1)

    try:
        try:
            grml_flavour = identify_grml_flavour(iso_mountpoint)
            logging.info("Identified grml flavour \"%s\".", grml_flavour)
            install_iso_files(grml_flavour, iso_mountpoint, device, device_mountpoint)
        except TypeError:
            logging.critical("Fatal: a critical error happend during execution (not a grml ISO?), giving up")
            sys.exit(1)
    finally:
        if os.path.isdir(iso_mountpoint) and remove_iso_mountpoint:
            unmount(iso_mountpoint, "")
            os.rmdir(iso_mountpoint)
            unregister_tmpfile(iso_mountpoint)
        if remove_device_mountpoint:
            try:
                unmount(device_mountpoint, "")
                if os.path.isdir(device_mountpoint):
                    os.rmdir(device_mountpoint)
                    unregister_tmpfile(device_mountpoint)
            except CriticalException, error:
                logging.critical("Fatal: %s", error)
                cleanup()


def handle_mbr(device):
    """Main handler for installing master boot record (MBR)

    @device: device where the MBR should be installed to"""

    if options.dryrun:
        logging.info("Would install MBR")
        return 0

    if device[-1:].isdigit():
        mbr_device = re.match(r'(.*?)\d*$', device).group(1)
        partition_number = int(device[-1:]) - 1
        skip_install_mir_mbr = False

    # if we get e.g. /dev/loop1 as device we don't want to put the MBR
    # into /dev/loop of course, therefore use /dev/loop1 as mbr_device
    if mbr_device == "/dev/loop":
        mbr_device = device
        logging.info("Detected loop device - using %s as MBR device therefore", mbr_device)
        skip_install_mir_mbr = True

    try:
        if options.syslinuxmbr:
            handle_syslinux_mbr(mbr_device)
        elif not skip_install_mir_mbr:
            if options.mbrmenu:
                install_mir_mbr(GRML2USB_BASE + '/mbr/mbrmgr', mbr_device, partition_number, True)
            else:
                install_mir_mbr(GRML2USB_BASE + '/mbr/mbrldr', mbr_device, partition_number, False)
    except IOError, error:
        logging.critical("Execution failed: %s", error)
        sys.exit(1)
    except Exception, error:
        logging.critical("Execution failed: %s", error)
        sys.exit(1)


def handle_vfat(device):
    """Check for FAT specific settings and options

    @device: device that should checked / formated"""

    # make sure we have mkfs.vfat available
    if options.fat16:
        if not which("mkfs.vfat") and not options.copyonly and not options.dryrun:
            logging.critical('Sorry, mkfs.vfat not available. Exiting.')
            logging.critical('Please make sure to install dosfstools.')
            sys.exit(1)

        exec_mkfs = False
        if options.force:
            print "Forcing mkfs.fat16 on %s as requested via option --force." % device
            exec_mkfs = True
        else:
            # make sure the user is aware of what he is doing
            f = raw_input("Are you sure you want to format the specified partition with fat16? y/N ")
            if f == "y" or f == "Y":
                logging.info("Note: you can skip this question using the option --force")
                exec_mkfs = True

        if exec_mkfs:
            try:
                mkfs_fat16(device)
            except CriticalException, error:
                logging.critical("Execution failed: %s", error)
                sys.exit(1)
        else:
            sys.exit(1)

    # check for vfat filesystem
    if device is not None and not os.path.isdir(device):
        try:
            check_for_fat(device)
        except CriticalException, error:
            logging.critical("Execution failed: %s", error)
            sys.exit(1)

    if not os.path.isdir(device) and not check_for_usbdevice(device):
        print "Warning: the specified device %s does not look like a removable usb device." % device
        f = raw_input("Do you really want to continue? y/N ")
        if f == "y" or f == "Y":
            pass
        else:
            sys.exit(1)


def handle_compat_warning(device):
    """Backwards compatible checks

    @device: device that should be checked"""

    # make sure we can replace old grml2usb script and warn user when using old way of life:
    if device.startswith("/mnt/external") or device.startswith("/mnt/usb") and not options.force:
        print "Warning: the semantics of grml2usb has changed."
        print "Instead of using grml2usb /path/to/iso %s you might" % device
        print "want to use grml2usb /path/to/iso /dev/... instead."
        print "Please check out the grml2usb manpage for details."
        f = raw_input("Do you really want to continue? y/N ")
        if f == "y" or f == "Y":
            pass
        else:
            sys.exit(1)


def handle_logging():
    """Log handling and configuration"""

    if options.verbose and options.quiet:
        parser.error("please use either verbose (--verbose) or quiet (--quiet) option")

    if options.verbose:
        FORMAT = "Debug: %(asctime)-15s %(message)s"
        logging.basicConfig(level=logging.DEBUG, format=FORMAT)
    elif options.quiet:
        FORMAT = "Critical: %(message)s"
        logging.basicConfig(level=logging.CRITICAL, format=FORMAT)
    else:
        FORMAT = "%(message)s"
        logging.basicConfig(level=logging.INFO, format=FORMAT)


def handle_bootloader(device):
    """wrapper for installing bootloader

    @device: device where bootloader should be installed to"""

    # Install bootloader only if not using the --copy-only option
    if options.copyonly:
        logging.info("Not installing bootloader and its files as requested via option copyonly.")
    elif os.path.isdir(device):
        logging.info("Not installing bootloader as %s is a directory.", device)
    else:
        install_bootloader(device)


def main():
    """Main function [make pylint happy :)]"""

    if options.version:
        print os.path.basename(sys.argv[0]) + " " + PROG_VERSION
        sys.exit(0)

    if len(args) < 2:
        parser.error("invalid usage")

    # log handling
    handle_logging()

    # make sure we have the appropriate permissions
    check_uid_root()

    logging.info("Executing grml2usb version %s", PROG_VERSION)

    if options.dryrun:
        logging.info("Running in simulation mode as requested via option dry-run.")

    # specified arguments
    device = args[len(args) - 1]
    isos = args[0:len(args) - 1]

    if not os.path.isdir(device):
        if device[-1:].isdigit():
            if int(device[-1:]) > 4 or device[-2:].isdigit():
                logging.critical("Fatal: installation on partition number >4 not supported. (BIOS won't support it.)")
                sys.exit(1)
        else:
            if os.path.exists(device):
                logging.critical("Fatal: installation on raw device not supported. (BIOS won't support it.)")
                sys.exit(1)

    if not which("rsync"):
        logging.critical("Fatal: rsync not available, can not continue - sorry.")
        sys.exit(1)

    # provide upgrade path
    handle_compat_warning(device)

    # check for vfat partition
    handle_vfat(device)

    # main operation (like installing files)
    for iso in isos:
        if os.path.isdir(iso):
            handle_dir(iso, device)
        else:
            handle_iso(iso, device)

    # install mbr
    if not os.path.isdir(device):
        if not options.skipmbr:
            handle_mbr(device)

    handle_bootloader(device)

    logging.info("Note: grml flavour %s was installed as the default booting system.", GRML_DEFAULT)

    for flavour in GRML_FLAVOURS:
        logging.info("Note: you can boot flavour %s using '%s' on the commandline.", flavour, flavour)

    # finally be politely :)
    logging.info("Finished execution of grml2usb (%s). Have fun with your grml system.", PROG_VERSION)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        logging.info("Received KeyboardInterrupt")
        cleanup()

## END OF FILE #################################################################
# vim:foldmethod=indent expandtab ai ft=python tw=120 fileencoding=utf-8
