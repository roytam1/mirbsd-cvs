┌────────────────────────────────────────────────┐
│ Copyright © 2011 ⅌ Thorsten “mirabilos” Glaser │
│ All rights reserved. – THIS IS AN UNPUBLISHED, │
│ PROPRIETARY WORK OF AUTHORSHIP. This copyright │
│ notice doesn’t evidence any actual or intended │
│ publication of such protected or private work. │
└────────────────────────────────────────────────┘



statt
	x *= 2;
	x = modf(x, &i);
	append_bit((int)i);
können wir
	x *= 2;
	if ((int)x) {
		x -= 1;
		append_bit(1);
	} else
		append_bit(0);
verwenden

frexp gibt's in python, nicht aber in php. das sollte tun:
function frexp($value, &$exp) {
	$exp = 0;
	if ($value == 0) {
		return 0;
	}
	while ($value < 0.5) {
		$value *= 2;
		$exp -= 1;
	}
	while ($value >= 1.0) {
		$value /= 2;
		$exp += 1;
	}
	return $value;
}
ungetestet.

php hat is_finite, aber bitte so testen:
	if (is_nan($v) || is_infinite($v))
		return "none";

python hats nicht… allen ernstes! (ab 2.6 dann)

def is_nan(x):
	if x != x:
		return True
	return False
# this from protobuf, kinda WTF effect…
def isinf(val):
      # Infinity times zero equals NaN.
      return not isnan(val) and isnan(val * 0)

⇒ is_nan(x) or is_nan(x * 0)

Actually, IEEE 754 allows us to:
def is_inf_or_nan(x):
	x = x * 0
	if x != x:
		return True
	return False

Prefer to use math.isinf(x) and math.isnan(x) if
available (Python 2.6+) though; we import math for
frexp anyway (we _could_, strictly spoken, avoid
that – maybe, if it has an import error, as fallback?)
