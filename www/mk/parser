rcsid_parser='$MirOS: www/mk/parser,v 1.19 2008/12/04 19:38:48 tg Exp $'
#-
# This file is part of the website of The MirOS Project, which is
# copyrighted material, please read the LICENCE file for details.

set -A e_author
set -A e_id
set -A ei_body
set -A ei_indir
set -A ei_srcf
set -A ei_skip
set -A ei_time

nl='
'
save_IFS=$IFS
integer entry=0
integer guid
integer state
typeset -l parser_lctmp

for srcf in $sources; do
	eval parser_lctmp=\$tags_${srcf//\-/_}
	tags=:
	for x in $parser_lctmp; do
		tags=$tags$x:
	done
	guid=10000
	ids=:
	state=1
	rcsid_parsed=
	while IFS= read -r line; do
		if [[ $line = RCSID:* && -z $rcsid_parsed ]]; then
			rcsid_parsed=${line##RCSID:*([	 ])}
		elif [[ $line = ---- ]]; then
			if [[ -z ${e_id[entry]} ]]; then
				if [[ -n ${e_date[entry]} ]]; then
					id=${e_date[entry]}
					id=e${id:6:4}${id:3:2}${id::2}
				else
					id=g$((guid++))
				fi
				if [[ -n ${e_author[entry]} ]]; then
					id=${id}-${e_author[entry]%%@(@)*}
				else
					id=${id}-nn
				fi
				e_id[entry]=$id
			fi
			while [[ :$ids = *:${e_id[entry]}:* ]]; do
				e_id[entry]=${e_id[entry]}-g$guid
				let guid++
			done
			ei_srcf[entry]=$srcf
			ids=$ids${e_id[entry]}:
			if [[ $tags != : ]]; then
				ei_skip[entry]=1
				for x in ${e_tag[entry]}; do
					[[ $tags = *:$x:* ]] || continue
					unset ei_skip[entry]
					break
				done
			fi
			let ++entry
			state=2
		elif (( state > 0 )); then
			if [[ $line = @([A-Za-z]*([A-Za-z0-9_]):\ *) ]]; then
				x=${line##+([A-Za-z0-9_]):+([	 ])}	# value
				parser_lctmp=${line/%:+([	 ])$x}	# key
				eval e_$parser_lctmp[entry]=\$x
			elif [[ -z $line ]]; then
				state=0
				continue
			elif [[ $line = \#* ]]; then
				continue	# ignore comment
			else
				print -u2 "Unknown header in data/$srcf.inc:" \
				    "$line"
				exit 1
			fi
			state=1
			if [[ $parser_lctmp = date ]]; then
				# split up german format (d.m.yyyy [H:M:S])
				# date, then pad to dd.mm.yyyy and store as
				# y m d H M S for strftm
				IFS=$IFS:.
				set -A e_tmp ${e_date[entry]}
				IFS=$save_IFS
				typeset -i -Z2 e_tmpd=10#0${e_tmp[0]}
				typeset -i -Z2 e_tmpm=10#0${e_tmp[1]}
				typeset -i -Z4 e_tmpy=10#0${e_tmp[2]}
				e_date[entry]=$e_tmpd.$e_tmpm.$e_tmpy
				# make sure there are no leading zeroes
				ei_time[entry]="$((e_tmpy)) $((e_tmpm)) $((e_tmpd)) $((10#0${e_tmp[3]})) $((10#0${e_tmp[4]})) $((10#0${e_tmp[5]}))"
			elif [[ $parser_lctmp = tag ]]; then
				parser_lctmp=${e_tag[entry]}
				unset e_tag[entry]
				for x in $parser_lctmp; do
					if [[ $x != +([0-9a-z_]) ]]; then
						print -u2 "Invalid tag '$x' in" \
						    "data/$srcf.inc: $line"
						continue
					fi
					e_tag[entry]=${e_tag[entry]}${e_tag[entry]+ }$x
				done
			fi
		else
			ei_body[entry]=${ei_body[entry]}${ei_body[entry]+$nl}$line
		fi
	done <"$TOP/data/$srcf.inc"
	if (( state != 2 )); then
		print -u2 "Last line of data/$srcf.inc not a separator!"
		exit 1
	fi
	[[ -z $rcsid_parsed ]] || rcsid_db[${#rcsid_db[*]}]=$rcsid_parsed
done
integer entries=entry
if [[ -n $notimesort ]]; then
	entry=-1
	state=0
	while (( ++entry < entries )); do
		[[ ${ei_skip[entry]} = 1 ]] || ei_indir[state++]=$entry
	done
else
	( integer e=-1; while (( ++e < entries )); do
		[[ ${ei_skip[e]} = 1 ]] || print ${ei_time[e]} $e
	  done | sort -nbk1,1 -k2,2 -k3,3 -k4,4 -k5,5 -k6,6 ) |&
	state=0
	while read -p y m d H M S entry; do
		ei_indir[state++]=$entry
	done
fi
entries=$state
return 0
