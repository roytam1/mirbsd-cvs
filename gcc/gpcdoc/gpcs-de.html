<html lang="en">
<head>
<title>GNU Pascal Coding Standards (Deutsch)</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta name="description" content="GNU Pascal Coding Standards (Deutsch)">
<meta name="generator" content="makeinfo 4.8">
<link title="Top" rel="top" href="#Top">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
GNU Pascal Coding Standards

   <p>Copyright (C) 2001-2006 Free Software Foundation, Inc.

   <p>Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   <p>Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that
the entire resulting derived work is distributed under the terms of
a permission notice identical to this one.

   <p>Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for
modified versions, except that this permission notice may be stated
in a translation approved by the copyright holders.

<div class="node">
<p><hr>
<a name="Top"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Vorwort">Vorwort</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#dir">(dir)</a>

</div>

<h2 class="unnumbered">Version</h2>

<p>Letzte Änderung 2006-02-02. 
Basierend auf der englischen Version von 2006-02-02.

<ul class="menu">
<li><a accesskey="1" href="#Vorwort">Vorwort</a>:                    Über die GNU Pascal Coding Standards
<li><a accesskey="2" href="#Rechtliches">Rechtliches</a>:                Freie Software soll frei bleiben
<li><a accesskey="3" href="#Gestaltungsratschl_00e4ge">Gestaltungsratschläge</a>:      Allgemeine Projektgestaltung
<li><a accesskey="4" href="#Verhalten-von-Programmen">Verhalten von Programmen</a>:   Wie sich Programme verhalten sollten
<li><a accesskey="5" href="#Pascal-Programmieren">Pascal Programmieren</a>:       Ratschläge zur Gestaltung des Quelltextes
<li><a accesskey="6" href="#Dokumentation">Dokumentation</a>:              Programme dokumentieren
<li><a accesskey="7" href="#Ver_00f6ffentlichungen">Veröffentlichungen</a>:         Der Verlauf der Veröffentlichung
<li><a accesskey="8" href="#Glossar">Glossar</a>:                    Glossar der Worte in diesem Text
<li><a accesskey="9" href="#Index">Index</a>
</ul>

<div class="node">
<p><hr>
<a name="Vorwort"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Rechtliches">Rechtliches</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Top">Top</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">1 Über die GNU Pascal Coding Standards</h2>

<p>Vorwort des Übersetzers:
Dieses Dokument enthält die Übersetzung der
&ldquo;GNU Pascal Coding Standards&rdquo;. Einige Worte werden so beibehalten,
wie sie im Englischen geschrieben wurden, weil es meiner Meinung
nach die Lesbarkeit des Textes fördert. Für Fehler in der
Übersetzung bin ich verantwortlich, nicht die ursprünglichen
Autoren. Für Rückfragen zur Übersetzung bin ich erreichbar unter:
Eike Lange <a href="mailto:eike@g-n-u.de">eike@g-n-u.de</a>. Mein besonderer Dank gilt Roland
Goretzki für seine unermüdliche Arbeit, dieses Dokument vom
Fehlerteufel zu befreien.

   <p>Trotz aller Sorgfalt lassen sich Fehler in der Übersetzung nicht
ganz ausschließen. In Konfliktfällen gilt stets das englische
Original. Bitte teilen sie uns eventuelle Diskrepanzen mit, damit
wir sie beheben können.

   <p>Die GNU Pascal Coding Standards wurden von einer Gruppe freiwilliger
Helfer des GNU Pascal Projektes entwickelt. Das Ziel dieses
Dokumentes ist es, die GNU Coding Standards um spezifische
Informationen für Pascal-Programmierer zu ergänzen. Die
Informationen in den GNU Coding Standard beziehen sich zu großen
Teilen auf die Programmiersprache C. Gleichsam erklären sie jedoch
viele der Regeln und Prinzipien, die zum Schreiben portabler,
robuster und zuverlässiger Programme nützlich sind. Die meisten
dieser Regeln können mit wenigen Anmerkungen versehen aus dem
Dokument übernommen werden, weswegen sich Referenzen zu den GNU
Coding Standards in diesem Dokument befinden.

   <p>Letzte Aktualisierung dieses Dokuments (original): 2006-02-02.

   <p><a name="index-Wo-man-die-GPCS-findet-1"></a><a name="index-Download-der-Coding-Standards-2"></a>
Die GNU Pascal Coding Standards sind als Teil der GPC-Distributionen
erhältlich &ndash; in Binärdistributionen als Info-Dateien, in
Quelltext-Distributions auch als Texinfo-Dateien, aus denen sich
weitere Formate wie HTML, PostScript und PDF erzeugen lassen. Eine
HTML-Version befindet sich auch auf der Homepage von GPC,
<a href="http://www.gnu-pascal.de">http://www.gnu-pascal.de</a>.

   <p><a name="index-Feedback-3"></a><a name="index-Beitr_00e4ge-zum-Dokument-4"></a>
Berichtigungen oder Vorschläge zu diesem Dokument können Sie direkt
beim Autor einreichen: <a href="mailto:eike@g-n-u.de">eike@g-n-u.de</a>. Für das
englischsprachige Original wenden Sie sich bitte an die
Dokumentations-Mailingliste des GNU Pascal Compilers,
<a href="mailto:gpc-doc@gnu.de">gpc-doc@gnu.de</a>. Da unsere Zeit begrenzt ist, sollten Ihre
Vorschläge den geänderten Text enthalten. Ein &ldquo;context diff&rdquo; der
Quelldatei im Texinfo-Format ist sehr willkommen, wobei wir einer
einfachen Mail auch nicht abgeneigt sind.

   <p>Die folgenden Leute sind die Tyrannen, die ihre Art der
Programmierung anderen auferlegen:
Peter Gerwinski `<samp><span class="samp">peter(at)gerwinski.de</span></samp>', Frank
Heckenbach `<samp><span class="samp">frank(at)pascal.gnu.de</span></samp>', Markus Gerwinski
`<samp><span class="samp">markus(at)gerwinski.de</span></samp>', Dominik Freche
`<samp><span class="samp">dominik.freche(at)gmx.net</span></samp>', Nicola Girardi
`<samp><span class="samp">nicola(at)g-n-u.de</span></samp>'.

<div class="node">
<p><hr>
<a name="Rechtliches"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Gestaltungsratschl_00e4ge">Gestaltungsratschläge</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Vorwort">Vorwort</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">2 Freie Software soll frei bleiben</h2>

<p><a name="index-legal-aspects-5"></a>
Dieses Kapitel der GNU Coding Standards beschreibt unter anderem,
wie man sich versichert, daß GNU Software rechtliche
Schwierigkeiten vermeidet. See <a href="standards.html#Intellectual-Property">Intellectual Property</a>.

<div class="node">
<p><hr>
<a name="Gestaltungsratschl%e4ge"></a>
<a name="Gestaltungsratschl_00e4ge"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Verhalten-von-Programmen">Verhalten von Programmen</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Rechtliches">Rechtliches</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">3 Allgemeine Projektgestaltung</h2>

<p><a name="index-Projektgestaltung-6"></a>
Dieses Kapitel beschäftigt sich mit einigen grundlegenden Themen
zur Gestaltung eines Programmes.

<ul class="menu">
<li><a accesskey="1" href="#Die-Programmiersprache">Die Programmiersprache</a>:       Welche Sprache nimmt man
<li><a accesskey="2" href="#Pascal-und-C">Pascal und C</a>:                 Linken mit C Bibliotheken
<li><a accesskey="3" href="#Erweiterungen-benutzen">Erweiterungen benutzen</a>:       Das Benutzen von nicht standardisierten
                                Erweiterungen
</ul>

<div class="node">
<p><hr>
<a name="Die-Programmiersprache"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Pascal-und-C">Pascal und C</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Gestaltungsratschl_00e4ge">Gestaltungsratschläge</a>

</div>

<h3 class="section">3.1 Welche Sprache nimmt man</h3>

<p><a name="index-Programmiersprache-7"></a>
Wir unterstützen die Idee, daß die Vielfalt der Programmiersprachen
etwas Gutes ist. Verschiedene Programmiersprachen sind nützlich für
verschiedene Aufgaben. Anders als die GNU Coding Standards
(see <a href="standards.html#Source-Language">Source Language</a>) wollen wir Sie nicht davon
überzeugen, daß Sie C oder Pascal oder eine andere einzelne
Programmiersprache für alles nutzen sollten.

   <p>Wenn Sie das lesen, dann haben Sie sich möglicherweise schon bei
einigen Projekten für Pascal entschieden oder ziehen dies in
Erwägung. Dieses Dokument will Ihnen Vorschläge unterbreiten,
<em>wie</em> Sie ihren Quellcode formatieren, wenn Sie in GNU Pascal
programmieren.

<div class="node">
<p><hr>
<a name="Pascal-und-C"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Erweiterungen-benutzen">Erweiterungen benutzen</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Die-Programmiersprache">Die Programmiersprache</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Gestaltungsratschl_00e4ge">Gestaltungsratschläge</a>

</div>

<h3 class="section">3.2 Linken mit C Bibliotheken</h3>

<p><a name="index-Pascal-und-C-8"></a><a name="index-Linken-mit-C-Bibliotheken-9"></a>
Sie können eine C-Bibliothek oder eine C-Objektcode-Datei mit Ihrem
Pascal-Programm oder ihrer Unit verlinken. Bitte beachten Sie die
Hinweise im GPC-Handbuch bzgl. der Einzelheiten
(see <a href="gpc.html#Other-Languages">Other Languages</a>).

   <p><a name="index-Wrapper-10"></a>Wir empfehlen die Verwendung von in C geschriebenen
&ldquo;Wrapper-Funktionen&rdquo; zum Zugriff auf C-Bibliotheken, also kleinen
Funktionen, die i.w. nichts anderes machen, als die Funktionen der
C-Bilbiothek aufzurufen. Der Grund dafür ist die Portabilität. Eines
Tages könnte es Änderungen an der zu linkenden Bibliothek geben, die
direkte `<samp><span class="samp">external</span></samp>'-Deklarationen gefährden. Sie sollten dann
die Wrapper anpassen, so daß Pascal Programme mit jeder Version
dieser Bibliothek zusammenarbeiten.

   <p>Bei der Arbeit mit großen Paketen kann es passieren, daß
die Kompatibilität zwischen Versionen einer Library und dem
Programm nicht einfach aufrechterhalten werden kann. In diesem Fall
kann man direkt zur Bibliothek linken, mit der man arbeiten möchte, und
bindet ebenso eine ergänzende Datei hinzu, die ausschließlich der
Versionskontrolle dient. 
Hier ein Beispiel:

<pre class="smallexample">     #include &lt;foo.h&gt;
     #if FOO_MAJOR != 1 || FOO_MINOR != 2
     #error The GPC interface for libfoo was only written for libfoo-1.2.
     #error Please get libfoo-1.2 or check for a version of the GPC interface
     #error matching your version of libfoo.
     #endif
</pre>
   <p>Beachten Sie die Benutzung von `<samp><span class="samp">!=</span></samp>' anstelle von `<samp><span class="samp">&lt;</span></samp>' oder
`<samp><span class="samp">&gt;</span></samp>', um eine sehr präzise Versionskontrolle durchzuführen. 
Bitte beachten Sie auch, daß dieses Verfahren nur dann anwendbar
ist, wenn es nur eine einzige Implementation dieser Bibliothek gibt,
d.h. es läßt sich mit einer Bibliothek wie GTK, aber nicht mit libc,
libm, curses etc. anwenden.

   <p><a name="index-Header_002d_00dcbersetzung-11"></a>Ein automatischer Header-Übersetzer ist geplant. Dieses Werkzeug
würde das Schreiben von Wrapperfunktionen überflüssig machen. Das
Schreiben eines solchen Programmes ist eine schwierige Aufgabe, und
niemand ist sich wirklich sicher, ob sie überhaupt durchführbar ist. 
Wann ein solches Programm verfügbar sein wird, ist ungewiß.

   <p><a name="index-C_002dCode-Compilation-12"></a>Sie können annehmen, daß der GNU C Compiler benutzt wird, um die Wrapper,
und, allgemein, jedes bißchen C-Code zu übersetzen, das Sie Ihrem
Programm hinzufügen. 
Der Grund für diese Annahme ist, daß nur der GNU C Compiler
garantiert, daß alle Konventionen kompatibel zum GNU Pascal Compiler
sind, und das auf jeder Plattform! Der GNU C Compiler und der GNU
Pascal Compiler teilen sich dasselbe Backend. Außerdem wird der GNU
C Compiler immer zusammen mit dem GNU Pascal Compiler erzeugt. Damit
ist `<samp><span class="samp">gcc</span></samp>' überall dort vorhanden, wo auch `<samp><span class="samp">gpc</span></samp>'
installiert ist.

<div class="node">
<p><hr>
<a name="Erweiterungen-benutzen"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Pascal-und-C">Pascal und C</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Gestaltungsratschl_00e4ge">Gestaltungsratschläge</a>

</div>

<h3 class="section">3.3 Das Benutzen von nicht standardisierten Erweiterungen</h3>

<p><a name="index-Nicht_002dStandard-Erweiterungen-13"></a>
GNU Pascal hat viele Möglichkeiten, die Standard Pascal nicht bietet. 
Ob diese Möglichkeiten in einem Programm genutzt werden sollen, ist
eine zu häufig diskutierte Frage.

   <p>Auf der einen Seite kann das Benutzen dieser Möglichkeiten zu
effizienteren oder übersichtlicheren Programmen führen. Auf der
anderen Seite ist dadurch nur der GNU Pascal Compiler in der Lage,
diesen Quelltext zu bearbeiten. Dadurch wird das Kompilieren des
Programmes auf Systemen unmöglich, auf denen dieser Compiler nicht
vorhanden ist.

   <p>Im allgemeinen ist es das beste, Kompatibilität zu anderen Compilern
oder zum Sprachstandard beizubehalten, <em>wenn diese
Kompatibilität einfach zu erhalten ist</em>. Leider ist dies jedoch
oftmals mit erheblichen Nachteilen verbunden. Als Beispiel dienen
viele eingefügte `<samp><span class="samp">{$ifdef}</span></samp>'s, um alle nicht-Standard-Compiler
zu versorgen, was den Code schwerer zu lesen, schreiben, testen und
warten macht. Außerdem sind `<samp><span class="samp">{$ifdef}</span></samp>'s selbst nicht
standardisiert. Sie gewinnen also nicht viel.

   <p>Daher schlagen wir vor, sich nicht zu sehr an Fragen der
Kompatibilität stören. Alles am GNU Pascal Compiler ist offen
(Compiler und Laufzeit-System). Das bedeutet, daß das gesamte
Interface bei Bedarf für andere Compiler verfügbar gemacht werden
kann. Dazu können sogar einfach die Quelltexte übernommen werden,
solange die Lizenzvereinbarung erhalten bleibt. Hier erfahren Sie
mehr über die GNU General Public License:
<a href="http://www.gnu.org/copyleft/gpl.html">http://www.gnu.org/copyleft/gpl.html</a>. Das ist sinnvoller als
eine Zerstückelung des Codes. Ein (begrenztes) Beispiel dieser
Strategie kann in der `<samp><span class="samp">gpc-bp</span></samp>'-Unit (für Borland Pascal)
gefunden werden. Schauen Sie einfach in das Interface. Es ist
meistens einfach, diese Unit um zusätzliche Features zu erweitern.

   <p>Bitte benutzen Sie die folgenden Features nicht, speziell solche
nicht, die lediglich aus Gründen der Rückwärtskompatibilität
eingeführt wurden:

     <ul>
<li>Kommentare der Form `<samp><span class="samp">(* *)</span></samp>' für alte Terminals, wo es die
Zeichen `<samp><span class="samp">{</span></samp>' und `<samp><span class="samp">}</span></samp>' nicht gab.

     <li>die `<samp><span class="samp">#</span></samp>'-Direktiven und `<samp><span class="samp">//</span></samp>'-Kommentare, wie in C/Delphi. 
Wenn eine Datei auch in C genutzt werden muß, so darf sie die
`<samp><span class="samp">#</span></samp>'-Direktiven, die C-Syntax in Conditionalen sowie
`<samp><span class="samp">//</span></samp>'-Kommentare enthalten. 
Gegenwärtig gibt es dazu das folgende Beispiel (das kann sich in
Zukunft ändern): <samp><span class="file">p/rts/constants.h</span></samp> in den GNU Pascal Compiler
Quellen.

     <li>den Mißbrauch der typisierten Konstanten als Variablen, was eine
seltsame Eigenschaft des Borland Pascal Compilers darstellt.

     <li>Zeichen-Konstanten der Form `<samp><span class="samp">^A</span></samp>'. Benutzen Sie bitte `<samp><span class="samp">#1</span></samp>'
oder `<samp><span class="samp">Chr (1)</span></samp>' stattdessen.

     <li>`<samp><span class="samp">CString</span></samp>'s (außer natürlich für C-Schnittstellen)

     <li>komplizierten Borland Pascal Code wie den folgenden anstelle von
`<samp><span class="samp">WriteStr</span></samp>':

     <pre class="smallexample">          Str (Foo, s);
          s := 'Hallo ' + s;
     </pre>
     <li>die meisten Fälle von `<samp><span class="samp">FillChar</span></samp>' und `<samp><span class="samp">Move</span></samp>', außer für
Low-Level-Programmierung und wenn es sich auf Zeichen innerhalb
eines Strings bezieht. Das Benutzen von

     <pre class="smallexample">          FillChar (s, SizeOf (s), 0);
     </pre>
     <p>um einen String zu leeren ist falsch in GNU Pascal und außerdem
ineffizient, sogar in Borland Pascal. Bitte benutzen Sie folgendes:

     <pre class="smallexample">          s := '';
     </pre>
     <p>Dieses Beispiel ändert lediglich das Längenfeld des Strings
`<samp><span class="samp">s</span></samp>', und leert ihn schon dadurch.

     <li>die meisten Fälle von `<samp><span class="samp">GetMem</span></samp>' und `<samp><span class="samp">FreeMem</span></samp>', die
normalerweise ein Work-Around für fehlende Schemata in anderen
Compilern sind.

     <li>die meisten Fälle untypisierter Parameter.

     <li>die meisten selbstgemachten dateinamenbezogenen Routinen. 
(Falls sie in Borland Pascal geschrieben wurden, so sind
sie zumeist sowieso nur unter DOS anwendbar. Benutzen Sie die
Möglichkeiten der `<samp><span class="samp">GPC</span></samp>'-Unit, um einen portablen Weg
einzuschlagen.)

     <li>Assembler-Code. Außer natürlich in seltenen Fällen, wo es um
die Optimierung von Code geht. Dort sollte er mit Hilfe von
`<samp><span class="samp">{$ifdef}</span></samp>' (z.B. für den Prozessortyp) eingekapselt
werden. Unterstützen Sie in einem solchen Fall auch bitte
eine reine Pascal-Version dieser Routinen innerhalb des
`<samp><span class="samp">{$else}</span></samp>'-Teiles. Testen Sie diese Routinen.

     <li>alles, was die `<samp><span class="samp">System</span></samp>'-Unit erfordert.

     <li>Annahmen über Typengrößen.

     <li>Annahmen über &ldquo;Endianness&rdquo;. (Einige Systeme verwenden für die
Anordnung von höher- und niederwertige Bytes eine andere Reihenfolge
als andere Systeme.) [Anm. d. Übersetzers: Die Begriffe &ldquo;Little
Endian&rdquo; und &ldquo;Big Endian&rdquo; lassen sich leider nicht direkt
übersetzen. Schauen Sie ins Glossar (see <a href="#Glossar">Glossar</a>), um mehr über
diese Begriffe herauszufinden.]

     <li>Bezeichner, die mit einem oder mehreren Unterstrichen (`<samp><span class="samp">_</span></samp>')
beginnen oder enden.

     <li>Units, die nur zur Kompatibilität mit Borland Pascal geschrieben
wurden. (see <a href="GPC.html#GPC-Units">GPC Units</a>) Die Units `<samp><span class="samp">CRT</span></samp>'
und `<samp><span class="samp">Printer</span></samp>' hingegen dienen sowohl der Kompatibilität
zu Borland Pascal als auch dem allgemeinen Nutzen.

   </ul>

   <p>Die GNU Coding Standards haben interessante Anmerkungen zu
diesem Thema. See <a href="standards.html#Using-Extensions">Using Extensions</a>.

<div class="node">
<p><hr>
<a name="Verhalten-von-Programmen"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Pascal-Programmieren">Pascal Programmieren</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Gestaltungsratschl_00e4ge">Gestaltungsratschläge</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">4 Wie sich Programme verhalten sollten</h2>

<p>Dieses Kapitel der GNU Coding Standards beschreibt Konventionen zum
Schreiben stabiler Programme. Außerdem gibt es Richtlinien zur
Ausgabe von Fehlermeldungen, zum Kommandozeilen-Interface
und dazu, wie sich Bibliotheken verhalten sollten. 
Bitte lesen Sie auch den entsprechenden Abschnitt der
GNU Coding Standards. See <a href="standards.html#Program-Behavior">Program Behavior</a>.

   <p>Einige Hinweise zur Pascal Programmierung:

   <p><a name="index-Signal_002dFunktionen-14"></a>Die in den GNU Coding Standards besprochene Auswahl zwischen
verschiedenen Signal-Funktionen wurde bereits im Run Time System
getroffen, so daß Sie sich nicht mehr darum kümmern müssen.

   <p><a name="index-Fehlerabfragen-15"></a>Ein weiterer Unterschied zu den GNU Coding Standards ist das
Verhalten bei Fehlerabfragen, die einen &ldquo;unmöglichen&rdquo; Zustand
entdecken. Wir empfehlen, das Programm nicht einfach abzubrechen. 
Dies würde implizieren, daß der Anwender ein Programmierer ist,
der den Fehler schon irgendwie findet. Diese Annahme ist nicht
realistisch! Unser Vorschlag ist es deswegen, eine Fehlermeldung
herauszugeben, die es dem Anwender ermöglicht, eine
Fehlerbeschreibung an die Programmierer zu senden.

   <p>Die GNU Coding Standards schlagen außerdem vor, jeden
Funktionsaufruf auf Fehlerrückgaben zu überprüfen. Dieser
Vorschlag paßt durchaus zu C, jedoch nicht unbedingt zu Pascal. 
In Pascal wird das Abfangen von Fehlern oftmals automatisch
durchgeführt, somit brauchen Sie sich in vielen Fällen nicht
darum zu kümmern. Viele I/O-Routinen geben Ihnen nicht einmal einen
Rückgabewert (beispielsweise `<samp><span class="samp">Reset</span></samp>'). Diejenigen
Fehlerwerte, die zurückgegeben werden, sollten aber auch
überprüft werden.

   <p>Sie können die automatischen Fehlerabfragen ausschalten und sich
selber darum kümmern. Tatsächlich ist es so, daß manche Fehler das
Programm mit einer Nachricht abbrechen lassen. Speziell in Units
oder Modulen wollen Sie stattdessen vielleicht den Benutzern eine
Möglichkeit einräumen, die Ursache des Fehlers zu beheben. Um das zu
tun, benutzen Sie bitte den Compiler-Switch `<samp><span class="samp">{$I-}</span></samp>' und
testen Sie den Wert der Funktion `<samp><span class="samp">IOResult</span></samp>' (see <a href="gpc.html#IOResult">IOResult</a>) oder der globalen Fehlervariablen wie `<samp><span class="samp">InOutRes</span></samp>'
(see <a href="gpc.html#InOutRes">InOutRes</a>). Beachten Sie bitte, daß I/O-Routinen
sofort zurückkehren, während `<samp><span class="samp">InOutRes</span></samp>' gesetzt ist, so daß es
nicht notwendig ist, nach jeder Operation diesen Wert abzufragen. 
Folgendes wird dadurch möglich:

<pre class="smallexample">     {$local I-}
     Rewrite (f, 'bla');
     WriteLn (f, 'foo');
     WriteLn (f, 'bar');
     WriteLn (f, 'baz');
     Close (f);
     {$endlocal}
     if InOutRes &lt;&gt; 0 then
       begin
         WriteLn (StdErr, GetIOErrorMessage);
         ...
       end;
</pre>
   <p>Es kann jedoch nützlich sein, nach `<samp><span class="samp">Rewrite</span></samp>' und anderen
Aufrufe zum Öffnen auf Fehler zu testen, denn dort treten die
meisten Fehler auf, und ein Test macht andere, nachgestellte
Aufrufe oftmals unnötig.

   <p>Die GPC-Unit enthält eine Menge Routinen für den Umgang mit
Temporärdateien, Konfigurationsdateien und vielen anderen
dateinamenbezogenen Aufgaben. Der Vorteil beim Gebrauch dieser
Routinen liegt darin, daß sie unter verschiedenen Betriebssystemen
laufen (zum Beispiel DOS und Unix) und daß evtl. dateinamenbezogene
Probleme an einer zentralen Stelle (dem Run Time System)
behoben werden können. Das ist besser, als verschiedene Stellen
im Code entsprechend anzupassen.

   <p>Soweit es die Bibliotheken betrifft, raten wir davon ab, jede einzelne
Routine in einer einzigen Datei unterzubringen. Wir hoffen, daß der GNU
Pascal Compiler das eines Tages auf der Ebene des Linkers selber macht. 
Gegenwärtig, so glauben wir, ist Programmiererfreundlichkeit sinnvoller
als die Größe der ausführbaren Datei. Außerdem empfehlen wir, auf
Namens-Präfixe zu verzichten. Namenskonflikte können stattdessen
durch qualifizierte Bezeichner (`<samp><span class="samp">UnitName.RoutinenName</span></samp>') gelöst
werden.

<div class="node">
<p><hr>
<a name="Pascal-Programmieren"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Dokumentation">Dokumentation</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Verhalten-von-Programmen">Verhalten von Programmen</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">5 Ratschläge zur Gestaltung des Quelltextes</h2>

<p>Dieses Kapitel gibt Ihnen Ratschläge, wie Sie Ihre Quelltexte gestalten
sollten. Diese Regeln gelten eigentlich nur für veröffentlichten
Code. 
Wenn Sie als Beispiel Kommentare in der alten Form `<samp><span class="samp">(* this one *)</span></samp>'
schreiben möchten, so geht das natürlich vorübergehend, bei der
Veröffentlichung sollten Sie dann allerdings unsere diesbezüglichen
Ratschläge beherzigen. Da man aber niemals wissen kann, ob und wann man
den Code veröffentlicht, ist es vorzuziehen, sich von vornherein an
diese Ratschläge zu halten.

<ul class="menu">
<li><a accesskey="1" href="#Verschiedene-Tips">Verschiedene Tips</a>:            Verschiedene Tips zur Gestaltung
<li><a accesskey="2" href="#Konsitenz_00fcberpr_00fcfung">Konsitenzüberprüfung</a>:         Über die Benutzung von <code>Assert</code>, um
                                abzubrechen, wenn etwas ``Unmögliches''
                                passiert. 
<li><a accesskey="3" href="#Formatierung">Formatierung</a>:                 Wie man die Quellen formatiert
<li><a accesskey="4" href="#Kommentare">Kommentare</a>:                   Quellen kommentieren
<li><a accesskey="5" href="#Reihenfolge">Reihenfolge</a>:                  Reihenfolge der Code-Bereiche
<li><a accesskey="6" href="#Gro_00dfschreibung">Großschreibung</a>:               Großschreibung
<li><a accesskey="7" href="#Compiler_002dDirektiven">Compiler-Direktiven</a>:          Benutzung von Compiler-Direktiven
<li><a accesskey="8" href="#Zwischenraum">Zwischenraum</a>:                 Wie man Leerzeichen in Code benutzt
<li><a accesskey="9" href="#Zeilenumbr_00fcche">Zeilenumbrüche</a>:               Wo man seine Zeilen umbrechen sollte
<li><a href="#Strings">Strings</a>:                      Zeichenketten
<li><a href="#Internationalisierung">Internationalisierung</a>:        Techniken zur Internationalisierung
<li><a href="#MemoryMap">MemoryMap</a>:                    Wie Sie sicher `<samp><span class="samp">MemoryMap</span></samp>' benutzen
</ul>

<div class="node">
<p><hr>
<a name="Verschiedene-Tips"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Konsitenz_00fcberpr_00fcfung">Konsitenzüberprüfung</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pascal-Programmieren">Pascal Programmieren</a>

</div>

<h3 class="section">5.1 Verschiedene Tips zur Gestaltung</h3>

<p><a name="index-Verschiedene-Tips-16"></a>
Pascal Quelldateien sollten die Endung `<samp><span class="samp">.pas</span></samp>' haben. 
Der Dateiname ohne diese Endung sollte der Name des Programmes,
der Unit oder des Modules sein, aber kleingeschrieben. Es sollte nur
eine einzige Unit, ein einziges Programm oder Modul pro Datei geben.

   <p>Der Code sollte mit der Option `<samp><span class="samp">-Wall</span></samp>', sowohl mit als auch
ohne `<samp><span class="samp">-O3</span></samp>' kompilierbar sein und in keinem Fall irgendwelche
Warnungen ergeben. (Siehe: See <a href="#Compiler_002dDirektiven">Compiler-Direktiven</a>, um einzelne
Warnungen gezielt abzuschalten, wenn es gar nicht anders geht.)

   <p>Bitte benutzen Sie nicht die automatische `<samp><span class="samp">Result</span></samp>'-Variable in
Funktionen. Wenn Sie sie haben wollen, so sollten Sie diese auch
deklarieren:

<pre class="smallexample">     function Foo (...) = Bar: Integer;
</pre>
   <p>Benutzen Sie die Art der Deklaration mit `<samp><span class="samp">=</span></samp>', nicht die ohne
Gleichheitszeichen, es sei denn, Sie wollen PXSC-kompatibel sein.

   <p>Wenn eine Funktion einen `<samp><span class="samp">Boolean</span></samp>'-Wert liefert, um den
Erfolg einer Operation anzuzeigen, so sollte `<samp><span class="samp">True</span></samp>' den
Erfolg melden und `<samp><span class="samp">False</span></samp>' das Fehlschlagen. 
Beachten Sie, daß dieses Vorgehen anders ist als in C, wo
`<samp><span class="samp">0</span></samp>' oftmals den Erfolg meldet.

   <p>Vermeiden Sie `<samp><span class="samp">goto</span></samp>' und ähnliche Statements, wie `<samp><span class="samp">Exit</span></samp>',
`<samp><span class="samp">Return</span></samp>', `<samp><span class="samp">Break</span></samp>' und `<samp><span class="samp">Continue</span></samp>'. Vermeiden Sie
`<samp><span class="samp">goto</span></samp>' um jeden Preis (außer <em>möglicherweise</em> ein
nicht-lokales `<samp><span class="samp">goto</span></samp>', um aus einer <em>sehr tief</em>
geschachtelten rekursiven Funktion im Falle eines Fehlers
herauszukommen). Vermeiden Sie die anderen Statements, wenn dies
mit vertretbarem Aufwand möglich ist. Wenn Sie aber dafür eine
weitere `<samp><span class="samp">Boolean</span></samp>'-Variable einführen müssten, so darf dies als
Entschuldigung für das Benutzen dieser Statements gelten. 
Beachten Sie, daß Code oftmals <em>einfacher</em> wird, wenn Sie auf
`<samp><span class="samp">Break</span></samp>' verzichten und stattdessen eine bessere
Abbruchbedingung oder eine andere Sorte Schleife benutzen.

   <p>Niemals sollten Sie die `<samp><span class="samp">for</span></samp>'-Zählvariable verändern oder dem
Wert der Variablen nach dem Durchlaufen dieser Schleife vertrauen. 
(Das ist nicht nur eine Art, seinen Quelltext zu gestalten, sondern
mehr noch eine Definition von Pascal. Solche Dinge ergeben
undefinierte Ergebnisse.)

   <p>Vertrauen Sie niemals undefiniertem Verhalten. Als Beispiele dienen
globale Variablen, die zu Beginn des Programmes mit `<samp><span class="samp">0</span></samp>'
initialisiert zu sein scheinen, angeforderter Speicher, der
initialisiert zu sein scheint, ein freigegebener Speicherbereich,
dessen Inhalt immer noch gültig zu sein scheint oder die oben
besprochenen `<samp><span class="samp">for</span></samp>'-Zählvariablen. Nichts von all dem ist
garantiert und kann mit jeder Compilerversion oder Plattform
geändert werden. Undefiniert ist eben undefiniert. Und der
Eindruck, daß solche Dinge bei 42 anderen Compilern zu
funktionieren scheinen, ist dabei völlig belanglos!

   <p>Bei Vergleichen sollte die sich häufiger ändernde Variable auf der
linken Seite stehen.

<pre class="smallexample">     for i := 1 to 10 do
       if a[i] = Foo then
         for j := 1 to 10 do
           if b[j] = a[i] then ...
</pre>
   <p>In diesem Beispiel ändert sich `<samp><span class="samp">a[i]</span></samp>' häufiger als `<samp><span class="samp">Foo</span></samp>'
und `<samp><span class="samp">b[j]</span></samp>' ändert sich häufiger als `<samp><span class="samp">a[i]</span></samp>' (da `<samp><span class="samp">j</span></samp>'
sich häufiger als `<samp><span class="samp">i</span></samp>' ändert).

   <p>Wir nehmen bei diesem Beispiel an, daß `<samp><span class="samp">Foo</span></samp>' konstant ist. Wenn
`<samp><span class="samp">Foo</span></samp>' ebenfalls von `<samp><span class="samp">i</span></samp>' abhängt, so kann es angebracht
sein, `<samp><span class="samp">Foo</span></samp>' auf die linke Seite zu stellen. Dies sollte dann
aber durch einen Kommentar erläutert werden.

   <p>Vermeiden Sie es, Code doppelt zu schreiben. Es ist zwar so einfach,
den Code an eine andere Stelle zu kopieren, aber es wird ein
Alptraum sein, diesen dann zu pflegen. Benutzen Sie stattdessen
Routinen oder Subroutinen, Units oder Module. Planen Sie Ihren Code
so, daß er erweitert werden kann. Packen Sie schlaue Tricks nicht an
Stellen, die Sie später ändern wollen.

   <p>Umfassen Sie einzelne Statements nicht mit `<samp><span class="samp">begin</span></samp>' und `<samp><span class="samp">end</span></samp>',
es sei denn, Sie wollen das &ldquo;dangling else&rdquo; - Problem vermeiden oder
diese Zeile ist der gesamte Rumpf einer Prozedur bzw. Funktion! 
Siehe folgende Beispiele:

<pre class="smallexample">     if foo then
       begin
         if bar then
           baz
       end  { Vermeiden des ``dangling else'' - Problems. }
     else
       qux  { Einzeiliges Statement. }
</pre>
   <p>Schreiben Sie keine leere Unit-Initialisierung. Folgendes sollten
Sie <em>nicht</em> tun:

<pre class="smallexample">     ...
     
     procedure Foo;
     begin
       ...
     end;
     
     begin
     end.
</pre>
   <p>Stattdessen schreiben Sie einfach:

<pre class="smallexample">     ...
     
     procedure Foo;
     begin
       ...
     end;
     
     end.
</pre>
   <p>Schreiben Sie keine ungenutzten Deklarationen, außer
in Interfaces, wo diese vom importierenden Code genutzt
werden können.

   <p><a name="index-Boolsche-Werte-17"></a><a name="index-Boolean-18"></a>Denken Sie daran: `<samp><span class="samp">Boolean</span></samp>'-Werte sind `<samp><span class="samp">Boolean</span></samp>'-Werte! 
Bitte schreiben Sie `<samp><span class="samp">if Foo then</span></samp>' statt
`<samp><span class="samp">if Foo = True then</span></samp>', und `<samp><span class="samp">if not Foo then</span></samp>' statt
`<samp><span class="samp">if Foo = False then</span></samp>'. 
Benutzen Sie auch `<samp><span class="samp">until False</span></samp>' statt `<samp><span class="samp">until 1 = 0</span></samp>',
das sieht auch hübscher aus. Ein anderes Beispiel ist
`<samp><span class="samp">Foo := Expression</span></samp>' statt `<samp><span class="samp">if
Expression then Foo := True else Foo := False</span></samp>'.

   <p>Vermeiden Sie doppelte globale Bezeichner, überladen Sie eingebaute
Bezeichner nicht, obwohl es der GNU Pascal Compiler verschmerzen
würde. Benutzen Sie dieselben globalen Bezeichner auch nicht in
verschiedenen Units oder Modulen. (Dank &ldquo;qualifizierter
Bezeichner&rdquo; wäre dies für den Compiler kein Problem, aber für den
Benutzer verwirrend.)

   <p><a name="index-Globale-Variablen-19"></a>Wir raten davon ab, globale Variablen für nicht-globale Zwecke
einzusetzen, z.B. eine globale Variable <code>Counter</code> als Zähler in
diversen lokalen Routinen zu verwenden. Deklarieren Sie stattdessen
eine lokale Variable in jeder Routine, die eine benötigt. Dies
ermöglicht i.a. auch eine bessere Optimierung des erzeugten Codes.

   <p><a name="index-Unendliche-Schleifen-20"></a>Wenn Sie eine unendliche Schleife schreiben (auch wenn diese
möglicherweise durch `<samp><span class="samp">Break</span></samp>' verlassen wird), empfehlen wir die
Verwendung der <code>repeat</code> und nicht der <code>while</code> Schleife,
weil dadurch der Code weniger weit nach rechts eingerückt wird
(jedenfalls, sofern die Schleife mehr als eine Anweisung enthält). 
Also:

<pre class="smallexample">     repeat
       ...
     until False
</pre>
   <p>Und nicht:

<pre class="smallexample">     while True do
       begin
         ...
       end
</pre>
   <div class="node">
<p><hr>
<a name="Konsitenz%fcberpr%fcfung"></a>
<a name="Konsitenz_00fcberpr_00fcfung"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Formatierung">Formatierung</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Verschiedene-Tips">Verschiedene Tips</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pascal-Programmieren">Pascal Programmieren</a>

</div>

<h3 class="section">5.2 Explizite Überprüfung der internen Konsistenz</h3>

<p><a name="index-Konsitenz_00fcberpr_00fcfung-21"></a><a name="index-Assert-22"></a>
Wie in der GNU C-Bibliotheksdokumentation (see <a href="libc.html#Consistency-Checking">Consistency Checking</a>) erläutert, ist es häufig von Vorteil, grundlegende
Annahmen in eigenen Programmen zu überprüfen. 
Schauen Sie sich dazu einmal folgende Prozedur an:

<pre class="smallexample">     procedure MachWasMitPString (StrPtr: PString);
</pre>
   <p>Hierbei könnten Sie implizit annehmen, daß diese Prozedur niemals mit
<code>nil</code> als Argument aufgerufen wird. Es ist jedoch sicherer, diese
&ldquo;unmögliche Bedingung&rdquo; zu überprüfen, um sicher zu stellen, daß
<code>StrPtr</code> verschieden von <code>nil</code> ist:

<pre class="smallexample">     procedure MachWasMitPString (StrPtr: PString);
     begin
       Assert (StrPtr &lt;&gt; nil);
       ...
     end;
</pre>
   <p>Wenn die Überprüfung fehlschlägt, dann erzeugt das Programm einen
Laufzeitfehler. Daraus läßt sich der Schluß ziehen, daß der Code, welcher
diese Prozedur aufruft, fehlerhaft ist (oder diese Routine entsprechend
ergänzt werden sollte). Dieses Verfahren kann sich bei der Fehlersuche
wirklich als hilfreich erweisen. Mit anderen Worten: fundamentale Annahmen
am Anfang (oder einem anderen geeigneten Ort) einer Routine zu überprüfen
stellt sicher, daß eine Funktion oder Prozedur nicht falsch benutzt werden
kann.

   <p>Die GNU C-Bibliothek enthält das <code>assert</code>-Makro für diese Art von
Überprüfungen. GNU-Pascals <code>Assert</code> verhält sich ein wenig anders. 
<code>Assert</code> bricht das Programm nicht vollständig ab, sondern erzeugt
einen Laufzeit-Fehler (see <a href="gpc.html#Assert">Assert</a>), den man z.B. mit der
`<samp><span class="samp">Trap</span></samp>'-Unit (see <a href="gpc.html#Trap">Trap</a>) abfangen kann.

   <p>Wenn das Programm hinreichend getestet wurde, kann man die
Überprüfung von <code>Assert</code> abstellen, indem man das Programm mit
der Option `<samp><span class="samp">--no-assertions</span></samp>' neu compiliert. Am Code selbst ist
keine Änderung nötig. Nebenwirkungen der Argumente von
<code>Assert</code> werden weiterhin ausgewertet (dies ist anders als
in C), so daß man weiterhin schreiben kann:

<pre class="smallexample">       Assert (MeineFunktion (Foo, Bar) &gt; 0)
</pre>
   <p><code>MeineFunktion</code> wird auf jeden Fall aufgerufen, die Überprüfung,
ob der Rückgabewert positiv ist, erfolgt jedoch nur, wenn
`<samp><span class="samp">--no-assertions</span></samp>' nicht als Option angegeben wurde.

   <p>Wir empfehlen, die Konsistenzüberprüfung nie abzuschalten, sofern man den
kleinen Laufzeitzuwachs verschmerzen kann.

<div class="node">
<p><hr>
<a name="Formatierung"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Kommentare">Kommentare</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Konsitenz_00fcberpr_00fcfung">Konsitenzüberprüfung</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pascal-Programmieren">Pascal Programmieren</a>

</div>

<h3 class="section">5.3 Wie man die Quellen formatiert</h3>

<p><a name="index-Formatierung-23"></a>
<a name="index-Blanks-24"></a><a name="index-Leerzeichen-25"></a>Als erstes: Vermeiden Sie unnötige Leerzeichen am Ende einer Zeile. 
Vergewissern Sie sich außerdem, daß Sie den Quelltext nicht mit
Tabulatorzeichen speichern. Verschiedene Editoren oder auch verschiedene
Konfigurationen eines Editors interpretieren diese Zeichen
mit einer unterschiedlichen Anzahl Leerzeichen. 
Dies gefährdet Ihre mühsam erarbeitete Einrückung. 
(Wenn Sie GNU Emacs benutzen, so ist die Funktion `<samp><span class="samp">untabify</span></samp>'
sehr nützlich; wenn sie VIM benutzen, die Umgebungsoption
`<samp><span class="samp">expandtab</span></samp>' (`<samp><span class="samp">:set et</span></samp>'); in PENG kann die Option
`<samp><span class="samp">Expand tabs</span></samp>' verwendet werden.)

   <p><a name="index-Steuerzeichen-26"></a>Bitte vermeiden Sie es, in Ihren Quelltext Steuerzeichen einzufügen
(außer NewLine, selbstverständlich). Bitte auch keine Form-Feeds
(`<samp><span class="samp">#12</span></samp>'), wenngleich sie in den GNU Coding Standards zum
Separieren von logischen Bereichen empfohlen werden. Auch keine
`<samp><span class="samp">SUB</span></samp>'-Zeichen (`<samp><span class="samp">#26</span></samp>'), diese werden nämlich unter DOS
als Ende-der-Datei-Zeichen mißbraucht. Ältere DOS-Editoren
fügen dieses Zeichen an das Ende der Datei an, obwohl selbst das
FAT-Dateisystem selbst über das Ende der Datei Bescheid weiß.

   <p><a name="index-Zeilenl_00e4nge-27"></a>Wir empfehlen eine maximale Länge von 68 Zeichen pro Zeile, so daß
eine Quelldatei in TeX mit voreingestelltem Font auf A4 gedruckt
werden kann. oder 78 Zeichen, geeignet für 80 Zeichen breite
Bildschirme. Dies ist keine feste Regel, denn umgebrochene Zeilen
verringern nur allzuoft die Lesbarkeit.

   <p><a name="index-Leerzeilen-28"></a>Benutzen Sie Leerzeilen zwischen Blöcken. Blöcke sind lange
Kommentare, `<samp><span class="samp">type</span></samp>', `<samp><span class="samp">const</span></samp>', `<samp><span class="samp">var</span></samp>', `<samp><span class="samp">label</span></samp>'
Abschnitte, Routinen-Rümpfe, Unit- oder
Modulinitialisierung/-finalisierung, `<samp><span class="samp">interface</span></samp>',
`<samp><span class="samp">implementation</span></samp>', `<samp><span class="samp">module</span></samp>', `<samp><span class="samp">export</span></samp>', `<samp><span class="samp">uses</span></samp>',
`<samp><span class="samp">import</span></samp>' Zeilen, globale Compiler-Direktiven. 
Soweit lange Kommentare eine folgende Deklaration betreffen,
bitten wir Sie, nur eine Zeile vor dem Kommentar abzusetzen,
nicht zwischen Kommentar und Deklaration. 
Eine besondere Ausnahme ist zwischen den Blöcken innerhalb
derselben Routine. Benutzen Sie hier keine Leerzeilen:

<pre class="smallexample">     procedure Short;
     var
       Foo: Integer;
       Bar: Char;
     begin
       ...
     end;
</pre>
   <p>Aber benutzen Sie Leerzeilen, um Subroutinen abzusetzen:

<pre class="smallexample">     procedure Long;
     const
       ...
     var
       Variablen, die von Sub genutzt werden können ...
     
       procedure Sub;
       var
         ...
       begin
         ...
       end;
     
     var
       Variablen, die nicht von Sub genutzt werden können ...
     begin
       ...
     end;
</pre>
   <p>Benutzen Sie bitte auch keine Leerzeile nach der Deklaration des
Namens der Hauptroutine, es sei denn, eine Subroutine folgt sofort. 
Andernfalls würde die Deklaration aussehen wie eine
Forward-Deklaration.

   <p>Beachten Sie bitte, daß wir im obigen Beispiel die lokalen Variablen
in Abschnitte vor und nach der Subroutine aufgeteilt haben. Dies ist
nicht zwingend.

   <p>Alles, was wir über Subroutinen gesagt haben, gilt
selbstverständlich auch für Sub-Subroutinen beliebiger
Verschachtelungstiefe.

   <p>Eine Leerzeile sollte dann zwischen Deklarationen desselben Types
stehen, wenn es Sinn macht, um diese logisch zu separieren. Falls
vor der Deklaration ein Kommentar steht, so soll die Leerzeile vor
dem Kommentar stehen. Anderenfalls soll die Leerzeile vor der
Deklaration stehen.

   <p>Leerzeilen können in langen Kommentaren Absätze teilen.

   <p>Keine Leerzeile am Anfang oder am Ende einer Datei. Lediglich ein
einzelnes Zeilenendzeichen nach dem letzten `<samp><span class="samp">end.</span></samp>'. Niemals
sollten Sie mehrere Leerzeilen hintereinander schreiben.

<div class="node">
<p><hr>
<a name="Kommentare"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Reihenfolge">Reihenfolge</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Formatierung">Formatierung</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pascal-Programmieren">Pascal Programmieren</a>

</div>

<h3 class="section">5.4 Quellen kommentieren</h3>

<p><a name="index-Kommentare-29"></a>
Die Kommentare sollten in geschweiften Klammern stehen, wie hier:

<pre class="smallexample">     { So ist es gut! }
</pre>
   <p>Altmodische Kommentare zwischen Klammern und Sternchen sollten
nicht mehr benutzt werden:

<pre class="smallexample">     (* Ein häßlicher Kommentar. So etwas braucht man nicht mehr! *)
</pre>
   <p>Auch sollten keine Kommentare mehr geschrieben werden, die mit
doppelten Schrägzeichen eingeleitet werden und bis zum Ende der
Zeile gehen:

<pre class="smallexample">     // Machen Sie es nicht.
</pre>
   <p>Obwohl ISO Pascal gemischte Kommentare ausdrücklich erlaubt und
der GNU Pascal Compiler sich mit der Option
`<samp><span class="samp">{$mixed-comments}</span></samp>' auch nicht darüber beschweren würde,
sollten solche Kommentare nicht benutzt werden:

<pre class="smallexample">     (* Dieses ... }
     { ... und jenes. *)
</pre>
   <p><a name="index-Verschachtelte-Kommentare-30"></a>Vermeiden Sie verschachtelte Kommentare wie
`<samp><span class="samp">{ { diesen hier } }</span></samp>'. Das ist nur dann in Ordnung,
wenn Sie TeX in einem Kommentar setzen wollen oder ähnlich
exotische Dinge. Was auch immer Sie für Gründe haben mögen, müssen
Sie diese Option dann zunächst mit der Direktive
`<samp><span class="samp">{$nested-comments}</span></samp>' anschalten. Benutzen Sie bitte nicht die
Kommandozeilenoption `<samp><span class="samp">--nested-comments</span></samp>'. Packen Sie all
diese Optionen in den Quellcode, damit niemand, der den Quellcode
übersetzen möchte, erst die benötigten Optionen erraten muß, und
auch, weil Kommandozeilenoptionen z.B. bein Kompilieren eines
Projektes mit mehreren Units/Modules <em>alle</em> Dateien betreffen
würden.

   <p><a name="index-Sprache-in-Kommentaren-31"></a>Bitte schreiben Sie Kommentare in Englisch! Englisch ist diejenige
Sprache, die die meisten Programmierer in allen Ländern lesen
können. Wenn Sie sich im Englischen nicht fit genug fühlen, dann bitten
Sie jemanden, Ihnen dabei zu helfen. Schreiben Sie so gut, wie Sie
können.

   <p><a name="index-Kommentarraster-32"></a>Sie sollten sich &ldquo;French Spacing&rdquo; angewöhnen, d.h. nur ein
Leerzeichen am Ende eines Satzes. Dabei können Sie in GNU Emacs
`<samp><span class="samp">M-a</span></samp>' und `<samp><span class="samp">M-e</span></samp>' nicht benutzen. Wir hoffen, daß Sie das
verschmerzen können. Bitte lassen Sie nur ein Leerzeichen nach der
öffnenden und der schließenden geschweiften Klammer des Kommentares
Platz.

   <p><a name="index-Plazierung-der-Kommentare-33"></a>Wenn ein Kommentar sich nur auf eine Zeile Code bezieht, so sollte
der Kommentar in derselben Zeile hinter dem Code stehen, soweit
das möglich ist. Bitte lassen Sie zwei Leerzeichen Platz. 
Dies ist ebenfalls für den Interface-Bereich einer Unit und bei
globalen Variablen angemessen. Oftmals benötigt man diese Sorte
Kommentare neben Record-Feldern. Andernfalls sollten Kommentare
in eigenen Zeilen stehen:

<pre class="smallexample">     { foo bar baz }
</pre>
   <p>Oder etwas länger:

<pre class="smallexample">     { foo bar
        baz }
</pre>
   <p>Mit Absätzen:

<pre class="smallexample">     { foo bar
        baz
     
        qux }
</pre>
   <p>Die Kommentare sollten gewöhnlich vor den Code plaziert werden,
auf den sie sich beziehen. Sie erhalten dieselbe Einrückung:

<pre class="smallexample">     { Meine Typen. }
     type
       ...
     
     type
       { Mein erster Typ. }
       Foo = Integer;
       ...
     
     begin
       { Mein erstes Statement. }
       Bla;
       { Anfang der Schleife. }
       repeat
         { Schleifenkörper. }
         ...
       { Beende die Schleife, wenn irgendwas passiert. }
       until Something
     end;
</pre>
   <p>Beachten Sie bitte besonders den Kommentar vor `<samp><span class="samp">until</span></samp>'.

   <p>Kommentare, die eine globale Deklarationen beschreiben, sollten in
eigenen Zeilen direkt vor der Deklaration stehen:

<pre class="smallexample">     { Das ist Foo. Foo kann so Manches. }
     procedure Foo;
</pre>
   <p><a name="index-Dumme-Kommentare-34"></a><a name="index-Triviale-Kommentare-35"></a>Schreiben Sie keine &ldquo;trivialen&rdquo; Kommentare wie den obigen. 
Sie sollten Kommentare dadurch vermeiden, daß Sie durchdachten
Code schreiben. Linus Torvalds macht das in seinem
Kernel Coding Style deutlich:

   <blockquote>
Comments are good, but there is also a danger of over-commenting. 
<strong>Never</strong> try to explain <strong>how</strong> your code works in a comment:
it's much better to write the code so that the <em>working</em> is
obvious, and it's a waste of time to explain badly written code. 
Generally, you want your comments to tell <strong>what</strong> your code does,
not <strong>how</strong>. 
</blockquote>

   <p>Übersetzung:

   <blockquote>
Kommentare sind grundsätzlich sinnvoll, aber es besteht die Gefahr
der &ldquo;Überkommentierung&rdquo;. <strong>Niemals</strong> sollten Sie im
Kommentar erklären, <strong>wie</strong> der Code arbeitet:
Es ist viel besser, offensichtlichen Code zu schreiben, so daß
seine <em>Arbeitsweise</em> sich ergibt. Es ist verschwendete Zeit,
schlecht geschriebenen Code zu kommentieren. Allgemein sollte man
mitteilen, <strong>was</strong> der Code macht, nicht <strong>wie</strong> er es macht. 
</blockquote>

   <p>(Beachten Sie, daß wir in anderen Bereichen ziemlich stark von seinem
Coding Style abweichen.)

   <p><a name="index-Kommentare-bei-nicht-naheliegendem-Code-36"></a><a name="index-Trickreiche-Kommentare-37"></a>&ldquo;Trickreicher&rdquo; Code ist es wert, kommentiert zu werden. Wir
definieren den Code als &ldquo;trickreich&rdquo;, der nicht naheliegende Dinge
tut, auf nicht sofort einleuchtenden Annahmen basiert, unerwartete
Implikationen beinhaltet, bei dessen Änderung etwas Spezielles
beachtet werden muss, der sich nicht so verhält, wie es auf den
ersten Eindruck scheint, der Seiteneffekte enthält oder es
erfordert, daß andere Teile des Codes an anderer Stelle gleichzeitig
mit ihm geändert werden. Trickreicher Code sollte grundsätzlich nur
in bescheidenem Maße benutzt werden.

   <p><a name="index-Kommentare-zu-externen-Quellen-38"></a>In dem Fall, daß sich ein Kommentar auf eine andere
Stelle des Codes bezieht, wobei es egal ist, ob die Referenz in
derselben oder einer anderen Datei liegt, beziehen Sie sich bitte
auf den Namen der Routine oder einen Kontext. Bitte geben Sie den
Bezug nicht in Form von Zeilennummern an (diese ändern sich zu
häufig). Lassen Sie in den Kommentaren außerdem beide Stellen
aufeinander verweisen, wo es Sinn macht. Diese Art der
&ldquo;Kreuzverweise&rdquo; erwies sich schon oft als sinnvoll.

   <p><a name="index-Auskommentieren-39"></a>Code, der auskommentiert werden soll, sollte mit Hilfe von
`<samp><span class="samp">{$if False} ... {$endif}</span></samp>' vom Kompilieren
ausgeschlossen werden. Bitte benutzen Sie dazu keine Kommentare.

   <p><a name="index-Kommentare-zur-Trennung-logischer-Abschnitte-40"></a>Um logische Abschnitte innerhalb größerer Module oder Units zu
markieren, sollten Sie Kommentare benutzen. Wir schlagen Ihnen
folgende leicht zu suchende festgelegte Form vor:

<pre class="smallexample">     {@section Name des Kapitels}
     {@subsection Name des Abschnitts}
</pre>
   <p>Beachten Sie, daß in diesem Fall ausnahmsweise keine Leerzeichen
neben den geschweiften Klammern eingefügt werden.

   <p><a name="index-Beschreibende-Kommentare-41"></a>Ein Modul, eine Unit oder Library sollte im Interface-Bereich
Kommentare haben, so daß dieses Interface zu einer verläßlichen
Dokumentationsquelle wird. Es ist freigestellt, solche Kommentare
für Routinen zu benutzen, die nur im Implementationsbereich
oder in Programmen (im Gegensatz zu Modulen etc.) deklariert werden. 
Mehrere zusammenhängende Deklarationen (z.B. Gruppen von Konstanten)
können sich einen Kommentar teilen.

   <p><a name="index-Kommentare-mit-Textauszeichnung-42"></a>Es wird ein Utility namens `<samp><span class="samp">pas2texi</span></samp>' geschrieben, welches
Texinfo-Dateien aus Pascal-Kommentaren erzeugt. Dieses Utility
wird verschiedene Textauszeichnungsmöglichkeiten innerhalb von
Kommentaren erlauben. Diese Textauszeichnungen werden innerhalb
der Dokumentation von `<samp><span class="samp">pas2texi</span></samp>' oder in späteren
Versionen dieses Dokumentes erläutert werden.

   <p><a name="index-Fixme-Kommentare-43"></a>&ldquo;Fixme&rdquo;-Kommentare dienen dazu, aufzuzeigen, daß an dieser Stelle
Code etwas zu verändern ist. Den Kommentaren werden mindestens
zwei `<samp><span class="samp">@</span></samp>' vorangestellt. Fügen Sie soviele `<samp><span class="samp">@</span></samp>' ein,
wie es der Dringlichkeit der Korrektur entspricht.

   <p>Die Kommentare sollten das Wesentliche des Problems enthalten, vor
allem wenn die Wurzel des Übels woanderes liegt. Beispielsweise
erklärt der Kommentar `<samp><span class="samp">{ @@fjf226 }</span></samp>' den folgenden Code als
Work-Around für ein Problem des GNU Pascal Compilers, welches von
einem Test-Programm namens `<samp><span class="samp">fjf226.pas</span></samp>' verdeutlicht wird. 
(Diese Datei können Sie tatsächlich innerhalb des Quellpaketes des
GNU Pascal Compilers finden.)

   <p>&ldquo;Fixme&rdquo;-Kommentare sollten nicht mit anderen Kommentaren vermischt
werden. Wenn beide Kommentare gebraucht werden, so sollten sie
getrennt, wenn auch direkt hintereinander stehen. Da sie
vorübergehender Natur sind, dürfen solche Kommentare überall stehen,
sogar innerhalb von Anweisungen. Normalerweise stehen sie im Rumpf
einer Routine, solange sie nicht das Interface eines Modules bzw. 
einer Unit beeinflussen. Interfaces, die voraussichtlich in der
Zukunft geändert werden, sollten `<samp><span class="samp">@@</span></samp>'-Kommentare direkt vor
ihren beschreibenden Kommentaren aufweisen.

<div class="node">
<p><hr>
<a name="Reihenfolge"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Gro_00dfschreibung">Großschreibung</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Kommentare">Kommentare</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pascal-Programmieren">Pascal Programmieren</a>

</div>

<h3 class="section">5.5 Reihenfolge der Code Bereiche</h3>

<p><a name="index-Reihenfolge-44"></a>
Jede Datei sollte mit einem Kommentar beginnen, welcher der Reihe
nach folgendes beinhaltet:

     <ul>
<li>eine kurze Beschreibung, was der Code in dieser Datei macht
<li>eine längere Beschreibung über Details des Codes und wo man sich
informieren kann
<li>Copyright-Informationen (Autoren)
<li>Die Lizenz (Klar, Sie wollen immer die GNU General Public License
oder die Lesser General Public License nutzen!) 
</ul>

   <p><a name="index-declaration-blocks-45"></a>Allgemein sollte man diese Deklarations-Reihenfolge einhalten:

     <ul>
<li>`<samp><span class="samp">const</span></samp>'-Deklarationen
<li>`<samp><span class="samp">type</span></samp>'-Deklarationen
<li>`<samp><span class="samp">var</span></samp>'-Deklarationen
<li>`<samp><span class="samp">label</span></samp>'-Deklarationen
<li>Routinen
</ul>

   <p>Sie können von dieser Reihenfolge abweichen, wenn es notwendig
erscheint oder den Code lesbarer gestaltet. Im folgenden sehen Sie
ein Beispiel, bei dem diese Reihenfolge nicht eingehalten werden
kann:

<pre class="smallexample">     type
       TIrgendwas = record
         Dieses, Jenes: Integer
       end;
     
     const
       IrgendEineKonstante = SizeOf (TIrgendwas);
</pre>
   <p>Die obigen Regeln gelten selbstverständlich auch für
Deklarationsbereiche innerhalb von Routinen.

   <p>Wenn Sie mehrere mehr oder weniger unabhängige Bereiche in einer
großen Unit oder einem großen Modul haben, so sollten sie obige
Reihenfolge auf jeden Teilbereich des Modules anwenden. Es sollten
z.B. nicht alle Konstanten aller Bereiche in eine einzelne
`<samp><span class="samp">const</span></samp>'-Deklaration geschrieben werden, das macht den Code
eher unleserlich.

   <p><a name="index-Variablen_002dDeklaration-46"></a>Variablen, die nur im Hauptprogramm genutzt werden, müssen in
Pascal global deklariert werden, wobei GNU Pascal eine Erweiterung
kennt, um diese Beschränkung zu umgehen und Variablen im
Anweisungsteil zu deklarieren (see <a href="gpc.html#var">var</a>). In einem
solchen Fall sollten diese Variablen direkt vor dem `<samp><span class="samp">begin</span></samp>' des
Hauptprogrammes geschrieben werden, nach allen Routinen etc. Das
gilt besonders dann, wenn das Programm groß ist und viele Variablen
deklariert werden. Dadurch wird der Variablen-Deklarations-Bereich
leichter einsehbar und ist einfacher mit den entsprechenden
Code-Bereichen änderbar. Außerdem vermeidet man so, daß
versehentlich Routinen diese Variablen nutzen.

   <p><a name="index-Deklarationen-innerhalb-eines-Typ_002dDeklarations_002dBlocks-47"></a>Wenn Sie einen Typ und seinen zugehörigen Zeiger gleich mit
deklarieren wollen, so deklarieren Sie bitte zuerst den Zeiger. 
Dies ist übersichtlicher, besonders wenn der zugehörige Typ eine
größere Struktur (`<samp><span class="samp">record</span></samp>' oder `<samp><span class="samp">object</span></samp>') ist. Auch wird
es damit möglich, rekursive Strukturen aufzubauen (Typdefinitionen,
die Zeiger auf denselben Typ beinhalten). Bitte stellen Sie den
Typen ein `<samp><span class="samp">T</span></samp>', und den zugehörigen Zeigern ein `<samp><span class="samp">P</span></samp>' voran. 
Folgendes Beispiel veranschaulicht das:

<pre class="smallexample">     type
       PMyInt = ^TMyInt;
       TMyInt = Integer;
     
       PStrList = ^TStrList;
       TStrList = record
         Next: PStrList;
         s: TString
       end;
</pre>
   <p>Bitte beachten Sie in dem Beispiel, daß das `<samp><span class="samp">Next</span></samp>'-Feld als
erstes aufgeführt ist. Wir schlagen vor, daß Sie es bei rekursiven
Typen immer so machen, es ermöglicht einige generische
Listenroutinen und ist etwas effizienter, da beim Durchlaufen der
Liste keine Offsets auftauchen.

   <p>Nicht verpflichtend ist es, alle Zeigertypen innerhalb einer
`<samp><span class="samp">type</span></samp>'-Deklaration zuerst aufzuführen, aber wir raten Ihnen
dazu. Hier ist ein Beispiel dazu:

<pre class="smallexample">     type
       { Zeigertypen }
       PFoo = ^TFoo;
       PBar = ^TBar;
       PBaz = ^TBaz;
     
       { Einige maßgefertigte Integertypen }
       TFoo = Integer attribute (Size = 16);
       TBar = Cardinal attribute (Size = 16);
       TBaz = Cardinal attribute (Size = 32);
</pre>
   <p><a name="index-Deklarationen-innerhalb-von-Objekttypen-48"></a>Innerhalb von Objekt-Typen gibt es drei Deklarationsbereiche. Drei
reservierte Wörter leiten diese Bereiche ein: `<samp><span class="samp">public</span></samp>',
`<samp><span class="samp">protected</span></samp>', `<samp><span class="samp">private</span></samp>'. Innerhalb eines jeden dieser
Bereiche sollte man folgende Reihenfolge einhalten:

     <ul>
<li>Felder
<li>Konstruktoren
<li>Destruktoren (hiervon sollte es nur einen geben)
<li>Methoden
</ul>

   <p><a name="index-Reihenfolge-der-Implementation-49"></a>Im Implementationsbereich sollte man dieselbe Reihenfolge
einhalten wie bei der Deklaration. Dies gilt selbstverständlich
ebenso für Units und Module.

   <p>Benutzen Sie nie ein `<samp><span class="samp">;</span></samp>' am Ende eines Blockes, also vor
`<samp><span class="samp">end</span></samp>', `<samp><span class="samp">until</span></samp>', usw, außer im Fall von `<samp><span class="samp">case</span></samp>'. 
Der letzte Zweig vor `<samp><span class="samp">else</span></samp>' (oder der letzte Zweig, wenn es
keinen `<samp><span class="samp">else</span></samp>'-Zweig gibt) <em>sollte</em> ein abschließendes
`<samp><span class="samp">;</span></samp>' haben, um Probleme wie diese zu vermeiden:

<pre class="smallexample">     case ...
       Foo:
         if Bar then  { später eingefügt }
           begin
             ...
           end  { wenn es hier kein Semikolon gibt ... }
       else  { ... dann wird dieses `<samp><span class="samp">else</span></samp>' plötzlich dem `<samp><span class="samp">then</span></samp>' zugerechnet }
         ...
</pre>
   <p>(Dasselbe gilt auch, wenn es `<samp><span class="samp">if</span></samp>' schon gibt und das
`<samp><span class="samp">else</span></samp>' des `<samp><span class="samp">case</span></samp>' später eingefügt wird.)

   <p>In Objekten mag es merkwürdig aussehen, das `<samp><span class="samp">;</span></samp>' nach dem
letzten Eintrag (meistens eine Objekt-Methode) wegzulassen. 
Deswegen erlauben wir es hier und zur Erhaltung der Konsistenz auch
in Records.

<div class="node">
<p><hr>
<a name="Gro%dfschreibung"></a>
<a name="Gro_00dfschreibung"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Compiler_002dDirektiven">Compiler-Direktiven</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Reihenfolge">Reihenfolge</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pascal-Programmieren">Pascal Programmieren</a>

</div>

<h3 class="section">5.6 Großschreibung</h3>

<p><a name="index-Gro_00dfschreibung-50"></a>
Reservierte Wörter sollten allesamt kleingeschrieben werden,
einschließlich aller Direktiven und Wörter, die nur in manchen
Kontexten reserviert sind (wie `<samp><span class="samp">protected</span></samp>'). Wenn Sie
Direktiven außerhalb ihres Kontextes als Bezeichner benutzen (was
leicht zu Problemen führen kann), so schreiben Sie diese bitte wie
Bezeichner.

   <p>Als besondere Ausnahme darf man `<samp><span class="samp">File</span></samp>' großschreiben, wenn
dieses als eigener Typ gebraucht wird. Anders ist es
selbstverständlich bei `<samp><span class="samp">file of Char</span></samp>'. Im Fall von
`<samp><span class="samp">procedure</span></samp>' als Typ (Borland Pascal) kann man diese Regel
nicht anwenden, denn `<samp><span class="samp">File</span></samp>' kann ein Typ an sich sein, während
`<samp><span class="samp">procedure</span></samp>' ein Typ-Konstruktor ist. Beispiel:

<pre class="smallexample">     procedure Foo (var a: File);  { Das geht }
     procedure Foo (var a: procedure);  { Das geht nicht! }
</pre>
   <p><a name="index-Gro_00dfschreibung-von-Bezeichnern-51"></a>Der nächste Punkt betrifft die Großschreibung von Bezeichnern. Es
gibt hierbei keinen Unterschied zwischen eingebauten und
selbstdefinierten Bezeichnern. Grundsätzlich sollte nur der erste
Buchstabe großgeschrieben werden, außer wenn es sich um
zusammengesetzte Wörter oder Akronyme handelt, dann sollte jeder
Anfangsbuchstabe eines jeden Teilwortes großgeschrieben werden. 
Unterstriche sollten vermieden werden. Akronyme, die zu einem Teil
der natürlichen Sprache geworden sind, sollten so geschrieben
werden wie in der Sprache. Beispielsweise `<samp><span class="samp">Dos</span></samp>' oder `<samp><span class="samp">DOS</span></samp>',
aber immer `<samp><span class="samp">GPC</span></samp>' und niemals `<samp><span class="samp">Gpc</span></samp>'! 
Hier einige Beispiele von Bezeichnern:
`<samp><span class="samp">Copy</span></samp>', `<samp><span class="samp">Reset</span></samp>', `<samp><span class="samp">SubStr</span></samp>', `<samp><span class="samp">BlockRead</span></samp>',
`<samp><span class="samp">IOResult</span></samp>', `<samp><span class="samp">WriteLn</span></samp>', `<samp><span class="samp">Sqr</span></samp>', `<samp><span class="samp">SqRt</span></samp>',
`<samp><span class="samp">EOF</span></samp>', `<samp><span class="samp">EOLn</span></samp>'.

   <p><a name="index-Gro_00dfschreibung-von-Konstanten-52"></a>Anders als bei C-Makros gelten diese Regeln auch für Konstanten.

   <p>Sehr kurze Bezeichner dürfen kleingschrieben werden, z.B. `<samp><span class="samp">i</span></samp>',
`<samp><span class="samp">s1</span></samp>' oder `<samp><span class="samp">xx</span></samp>'. Solche kurzen Bezeichnernamen sollten nur
in lokalen Blöcken auftauchen. Dazu zählen auch Parameter globaler
Routinen, denn der Gültigkeitsbereich solcher Parameter ist lokal. 
Der Gebrauch dieser Bezeichner sollte nicht in einem globalen
Kontext erfolgen, besonders nicht in Units oder Modulen. Der Autor
kann ja nie wissen, in welchen Kontexten die Units/Module benutzt
werden.

   <p>Bitte bleiben Sie einheitlich, was die Groß- und Kleinschreibung
ihrer Bezeichner anbelangt. Wenngleich Pascal Sie auch nicht
schlägt, wenn Sie mal die Großschreibung einer Variablen innerhalb
eines Blockes ändern: Bitte halten Sie sich an eine Form.

   <p><a name="index-Aufz_00e4hlungstypen-53"></a><a name="index-Konstanten-54"></a>Für Bezeichner für die Werte von Aufzählungstypen und für Gruppen
von Konstanten, d.h. an Stellen, wo viele Bezeichner auf einmal
eingeführt werden, kann es nützlich sein, ein zweibuchstabiges
kleingeschriebenes Präfix zu verwenden, dem im Gegensatz zu obigen
Regeln ein Unterstrich (`<samp><span class="samp">_</span></samp>') folgt:

<pre class="smallexample">     type
       TFooBar = (fb_Foo, fb_Bar, fb_Baz, fb_Qux);
</pre>
   <pre class="smallexample">     { Meine Foos }
     const
       mf_Foo = 1;
       mf_Bar = 3;
       mf_Baz = 42;
</pre>
   <p><a name="index-OOP-55"></a>In objektorientiertem Code, meistens in Konstruktoren, hat man den
Fall, daß der Parameter einer Funktion zu einem Feldnamen passen
soll, den dieser Parameter initialisiert. Da beide Namen nicht
übereinstimmen dürfen, sollte das Feld den &ldquo;natürlichen&rdquo; Namen
haben, da es an mehreren Stellen verwendet wird, und der
Parametername verändert werden. Wir haben bislang keine einheitliche
Regel für den Namen des Parameters in einem solchen Fall gefunden. 
Manche Programmierer verwenden `<samp><span class="samp">a</span></samp>' als Präfix. Wenn Sie eine
gute Idee haben, so lassen Sie es uns wissen.

   <p><a name="index-Gro_00dfschreibung-von-Makros-56"></a>Makros sollten nicht genutzt werden! Sie sind die Reinkarnation
des Bösen! Wenn Sie es doch tun, so müssen Sie zur Strafe alle
Buchstaben groß schreiben und einzelne Teilwörter mit
Unterstrichen trennen. Da Makros außerhalb der
Pascal-Geltungsbereiche stehen, macht es durchaus Sinn, sie anders
zu schreiben als den übrigen Pascal-Code. Das gilt ebenso für
Bedingungen im Rahmen der bedingten Kompilierung (Conditionale).

<div class="node">
<p><hr>
<a name="Compiler-Direktiven"></a>
<a name="Compiler_002dDirektiven"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Zwischenraum">Zwischenraum</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Gro_00dfschreibung">Großschreibung</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pascal-Programmieren">Pascal Programmieren</a>

</div>

<h3 class="section">5.7 Benutzung von Compiler-Direktiven</h3>

<p><a name="index-Compiler_002dDirektiven-57"></a>
Anmerkung des Übersetzers:
Um der Doppeldeutigkeit von &ldquo;condition&rdquo;, wie sie in einer
`<samp><span class="samp">if</span></samp>'-Anweisung vorkommt, und wie sie in der bedingten
Ausführung von Code vorkommt, Herr zu werden, habe ich mich
entschieden, in diesem Abschnitt durchgängig &ldquo;Conditional&rdquo; im
letztgenannten Kontext zu verwenden. Der Leser möge mir verzeihen.

   <p>Grundsätzlich sollten Sie so wenig Compiler-Direktiven wie nur
irgend möglich verwenden, weil sie den Code schwerer lesbar
und wartbar machen. So sollten Direktiven aussehen:

<pre class="smallexample">     {$Ihre-Compiler-Direktive}
</pre>
   <p>und niemals so: (see <a href="#Kommentare">Kommentare</a>)

<pre class="smallexample">     (*$mach-es-nicht-Direktive*)
</pre>
   <p>und auch nicht so, weil dies im Gegensatz zu Pascal, von
Zeilenumbrüchen anhängt:

<pre class="smallexample">     #so-auch-nicht-Direktive
</pre>
   <p>Dasselbe bei Makro-Definitionen:

<pre class="smallexample">     {$define ...}
</pre>
   <p>Dies spart außerdem den Backslash vor dem Zeilenumbruch, im
Gegensatz zu `<samp><span class="samp">#define</span></samp>'. Aber Sie wollen ohnehin keine Makros
benutzen, ODER? (see <a href="#Gro_00dfschreibung">Großschreibung</a>)

   <p><a name="index-Blanks-bei-Direktiven-58"></a>Fügen Sie niemals ein Leerzeichen vor der schließenden Klammer ein,
denn es darf auch keines nach der öffnenden Klammer kommen. Wenn
Sie mehrere Direktiven zusammenfügen, so fügen Sie zwischen zweien
kein Leerzeichen ein, ein einfaches Komma genügt.

   <p><a name="index-Kommentare-und-Direktiven-59"></a>Es sollten keine Kommentare innerhalb der Direktiven eingefügt
werden. Schreiben Sie Kommentare stattdessen separat:

<pre class="smallexample">     {$X+}  { Wir brauchen erweiterte Syntax }
</pre>
   <p>Borland Pascal erlaubt, Kommentare mit Direktiven zu vermischen. 
Das ist ein Mißbrauch eines solchen Kommentares!

   <p>Kurze Formen der Direktiven sind in Ordnung, aber man sollte den
langen Formen den Vorzug geben. Die kurzen Formen müssen
großgeschrieben werden, während die langen Formen kleingeschrieben
werden sollten (ausgenommen Argumente, bei denen es auf die
richtige Schreibweise ankommt, wie Fehlermeldungen, Warnungen,
Dateinamen &ndash; bei letzteren ist auch unter DOS die korrekte Groß-
und Kleinschreibung zu verwenden, damit der Code portabel bleibt).

   <p>Sie können verschiedene Direktiven kombinieren, dabei auch kurze
und lange Formen mischen, wie im folgenden Beispiel:

<pre class="smallexample">     {$gnu-pascal,I-,X+}
</pre>
   <p><a name="index-Standard_002dDirektiven-60"></a>Jede Unit und jedes Modul sollte `<samp><span class="samp">{$gnu-pascal,I-}</span></samp>' oder
`<samp><span class="samp">{$gnu-pascal,I+}</span></samp>' nahe am Anfang stehen haben, und zwar
nach dem einleitenden Kommentar mit der Beschreibung und der
Lizenz. `<samp><span class="samp">{$gnu-pascal}</span></samp>' bewirkt, daß die Unit ohne
Dialekt-Optionen kompiliert wird, selbst wenn das aufrufende
Programm Dialekt-Optionen nutzt. `<samp><span class="samp">{$I-}</span></samp>' und `<samp><span class="samp">{$I+}</span></samp>'
zeigen dem Nutzer der Unit, daß Ein-/Ausgabe-Fehler von den Routinen
abgefangen werden oder Laufzeitfehler zu erwarten sind. Der erste
Fall ist dem anderen in den meisten Fällen vorzuziehen. 
Für Programme ist dies optional. Routinen, die Ein-/Ausgabe-Fehler
hervorrufen können, sollten mit dem Attribut `<samp><span class="samp">iocritical</span></samp>'
(see <a href="gpc.html#attribute">attribute</a>) deklariert werden:

<pre class="smallexample">     procedure KritischeRoutine; attribute (iocritical);
</pre>
   <p><a name="index-no_002dwarning-Direktive-61"></a>`<samp><span class="samp">{$W-}</span></samp>' (keine Warnungen) sollte nur lokal genutzt werden
und ein &ldquo;FIXME&rdquo;-Kommentar (see <a href="#Kommentare">Kommentare</a>) haben, denn es
zeigt ein Problem mit dem Code oder dem Compiler.

   <p>Bitte schalten Sie keine Warnungen ab, wenn Sie nur zu faul sind,
Code zu schreiben, der keine Warnungen produziert.

   <p><a name="index-Lokale-Direktiven-62"></a>Jeder Compiler-Schalter, der nicht global gesetzt wird
(beispielsweise zusammen mit `<samp><span class="samp">{$gnu-pascal}</span></samp>', siehe oben),
sollte mit `<samp><span class="samp">{$local ...}</span></samp>' kombiniert werden. Also nicht
so:

<pre class="smallexample">     {$I-} Reset (f); {$I+}
</pre>
   <p>Sondern so:

<pre class="smallexample">     {$local I-} Reset (f); {$endlocal}
</pre>
   <p>Das erste Beispiel ist falsch, wenn vorher schon `<samp><span class="samp">{$I-}</span></samp>'
geschrieben wurde. Selbst wenn ein Programmierer weiß, welches
die aktuellen globalen Einstellungen sind, so können sich diese
eines Tages ändern. Auch dadurch, daß Teile des Codes an
eine andere Stelle kopiert werden. 
Das untere der beiden Beispiele ist daher die sichere Form.

   <p>Um zu verdeutlichen, was wir meinen, hier noch ein Beispiel:

<pre class="smallexample">     {$local W-} Foo; {$endlocal}  { @ GPC gibt hier eine überflüssige Warnung }
</pre>
   <p>Nochmal: Vermeiden Sie es, lokale Direktiven zu gebrauchen. 
`<samp><span class="samp">{$I-}</span></samp>' kann manchmal nütztlich sein. `<samp><span class="samp">{$X+}</span></samp>' sollte
nur dann gebraucht werden, wenn es <em>wirklich</em> notwendig ist,
und dann auch bitte so lokal wie nur irgend möglich. Vermeiden Sie
Zeiger-Arithmetik!

   <p><a name="index-Testen-der-R_00fcckgabewerte-63"></a>Benutzen Sie weder `<samp><span class="samp">{$X+}</span></samp>' noch
`<samp><span class="samp">{$ignore-function-results}</span></samp>', um Funktionswerte zu
überprüfen. Es ist schlicht zu einfach, ein beachtenswertes
Funktionsergebnis zu ignorieren. Manchmal, besonders dann, wenn man
eine C-Bibliothek linkt, hat man es mit Funktionsergebnissen zu tun,
die überflüssig erscheinen, weshalb man sie nicht überprüfen möchte. 
Solche Funktionen lassen sich bald mit dem Attribut `<samp><span class="samp">ignorable</span></samp>'
deklarieren, so daß das Funktionsergebnis stillschweigend ignoriert
wird.

   <p>Benutzen Sie auch dann Dummy-Variablen, wenn Sie
Funktionsergebnisse von Funktionen, deren Ergebnisse
gemeinhin nicht ignoriert werden sollen, ignorieren wollen. 
Überprüfen Sie sehr sorgfältig, ob ein solches Ergebnis wirklich
sicher ignoriert werden kann! Wenn jedoch ein unerwarteter Wert
Sie in eine &ldquo;unmögliche&rdquo; Situation bringen würde, so ist es
normalerweise besser, das Funktionsergebnis zu überprüfen
und im unerwarteten Fall eine Warnung auszudrucken oder gar
abzubrechen. Tun Sie das wenigstens dann, wenn `<samp><span class="samp">DEBUG</span></samp>'
gesetzt ist. (see <a href="#Compiler_002dDirektiven">Compiler-Direktiven</a>).

   <p><a name="index-Linker_002dDirektiven-64"></a>Linker-Direktiven, d.h. `<samp><span class="samp">{$L}</span></samp>' fürBibliotheken und
C-Code-Dateien (oder Dateien anderer Sprachen) sollten nahe am
Anfang des Programmes und nahe am Implementationsanfang von Units
oder Modulen stehen. Mehrere Bibliotheken und C-Quelldateien können
in eine Direktive geschrieben werden, wenn sie logisch
zusammengehören (bspw. eine Bibliothek und ihre zugehörige
Wrapper-Funktion), nicht aber dann, wenn sie nicht zusammengehören. 
Diese Direktiven sollten nicht mit anderen Direktiven gemischt
werden (was auch nicht geht, wenn `<samp><span class="samp">L</span></samp>' zuerst angeführt wird;
anders herum geht es, ist aber nicht ratsam). Die externen
Deklarationen der Bibliothek oder C-Routinen sollten sofort der
zugehörigen Direktive folgen (außer für Units oder Module bei
denjenigen Deklarationen, die in das Interface gehören). Das
Benutzen von `<samp><span class="samp">{$L}</span></samp>' innerhalb eines Programmes ist
normalerweise keine gute Idee. Da lohnt es sich schon, eine Unit zu
schreiben, welche abstrahiert und wiederverwertet werden kann.

   <p><a name="index-Bedingte-Kompilierung-65"></a>Bedingtes Kompilieren kann manchmal nützlich sein, aber es sollten
sowenige `<samp><span class="samp">{$ifdef}</span></samp>'s wie nur irgend möglich geschrieben
werden, denn sie vermindern die Lesbarkeit des Codes sehr stark. 
Wo Conditionale eingesetzt werden, um verschiedene Systeme zu
unterscheiden, sollten die Fähigkeiten des Systems (bspw. 
`<samp><span class="samp">__BYTES_LITTLE_ENDIAN__</span></samp>') oder Gruppen von Systemen
(bspw. `<samp><span class="samp">__OS_DOS__</span></samp>') überprüft werden, nicht einzelne Systeme. 
Dieses Vorgehen funktioniert dann oftmals auch später noch auf
Systemen, von denen man noch nichts weiß oder die noch nicht
existieren.

   <p>Wann immer dies möglich ist, sollte vordefinierten Konstanten der
Vorzug gegenüber `<samp><span class="samp">define</span></samp>'s gegeben werden (bspw. 
`<samp><span class="samp">BytesBigEndian</span></samp>', `<samp><span class="samp">OSDosFlag</span></samp>'). Dies ist im Anweisungsteil
möglich (der &ldquo;immer false&rdquo; - Zweig wird schlicht wegoptimiert,
trotzdem wird seine Syntax überprüft). Bei Typen-Deklarationen ist
es normalerweise nicht möglich. Hier muß man `<samp><span class="samp">define</span></samp>'s
einsetzen. Folgendes ist ein Beispiel aus der CRT-Unit:

<pre class="smallexample">     TWindowXYInternalCard8 = Cardinal attribute (Size = 8);
     TWindowXYInternalFill = Integer attribute (Size = BitSizeOf (Word) - 16);
     TWindowXY = packed record
       {$ifdef __BYTES_BIG_ENDIAN__}
       Fill: TWindowXYInternalFill;
       y, x: TWindowXYInternalCard8
       {$elif defined (__BYTES_LITTLE_ENDIAN__)}
       x, y: TWindowXYInternalCard8;
       Fill: TWindowXYInternalFill
       {$else}
       {$error Endianness is not defined!}
       {$endif}
     end;
</pre>
   <p><a name="index-Debug_002dFlag-66"></a>Das `<samp><span class="samp">DEBUG</span></samp>'-Flag sollte eine Unterstützung beim Debuggen des
Codes sein, also Code, der die Funktionalität beim Debuggen nicht
verändert. Nur dafür sollte er eingesetzt werden. Programme müssen
mit und ohne `<samp><span class="samp">DEBUG</span></samp>' lauffähig sein. Es kann sein, daß der
Code mit `<samp><span class="samp">DEBUG</span></samp>' langsamer läuft und eine Vielzahl von
Mitteilungen produziert. Diese Mitteilungen sollten klar als
Debug-Mitteilungen erkennbar sein, bspw. dadurch, daß der Ausgabe
ein `<samp><span class="samp">DEBUG: </span></samp>' vorangestellt wird. Solcher Code <em>darf</em> auch
einfach abbrechen, wenn fehlerhafte oder merkwürdige Zustände
eintreten.

   <p><a name="index-Conditionale-und-Versionsverwaltung-67"></a>Conditionale können ebenfalls herangezogen werden, um verschiedene
Versionen ein und desselben Codes anzufertigen. So ist es z.B. 
innerhalb eines Mathematik-Programmes möglich, eine eigene
Version mit GMP-Zahlen (GMP ist eine Bibliothek zur
Bearbeitung beliebig großer Zahlen) zu erzeugen und eine
ohne, je nachdem, welches Conditional gesetzt ist. In diesem
Fall sollten die Namen und Bedeutungen aller Conditionale in einem
weit oben im Quelltext stehenden Kommentar erklärt werden. Sehen Sie
sich bitte `<samp><span class="samp">__BP_TYPE_SIZES__</span></samp>', `<samp><span class="samp">__BP_RANDOM__</span></samp>' und
`<samp><span class="samp">__BP_PARAMSTR_0__</span></samp>' als Beispiele aus der Unit `<samp><span class="samp">System</span></samp>'
an. Der Code sollte mit jeder Kombination dieser Conditionale
kompilierbar sein, was bedeutet, eine exponentielle Menge an
Kombinationen zu testen. Noch ein guter Grund, Conditionale so
selten wie möglich zu benutzen oder gar zu vermeiden.

   <p><a name="index-Conditionale-und-Implementationsverwaltung-68"></a>Eine andere denkbare Benutzung von Conditionalen besteht darin, mit
ihrer Hilfe verschiedene Implementationen desselben Codes
anzufertigen. Sie sollten diese Strategie <em>nur</em> dann anwenden,
wenn alle Implementationen unterstützt werden oder es geplant ist,
sie zu unterstützen. Andernfalls sollte die alte Implementation
besser ins Museum wandern. Halten Sie den Code in einem solchen Fall
besser &ldquo;sauber&rdquo;. Die Hinweise bzgl. des Testens gelten auch hier.

   <p><a name="index-Komplizierte-Conditionale-69"></a>Wenn Sie es mit komplizierten Conditionalen zu tun haben, so folgen
Sie bitte der Pascal-Syntax. Formatieren Sie den Code nach den
Regeln von Pascal, nicht nach denen von C. Hier ein dummes
Beispiel:

<pre class="smallexample">     {$if defined (Foo) or False}
</pre>
   <p>Im Gegensatz zu (bitte nicht nachmachen!):

<pre class="smallexample">     {$if defined (Foo) || 0}
</pre>
   <p>Oder noch schlimmer:

<pre class="smallexample">     #if defined (Foo) || 0
</pre>
   <p><a name="index-Auskommentieren-von-Code-70"></a>Eine spezielle Conditionale kann genutzt werden, um Code kurzfristig
auszukommentieren. Hier ist die zugehörige Syntax:

<pre class="smallexample">     {$if False} ... {$endif}
</pre>
   <p><a name="index-Conditionale-und-GPC_002dVersionen-71"></a>Ein Standard-Conditional sollte in Programmen, Units oder Modulen
genutzt werden, wenn Sie sicherstellen wollen, daß die richtige
Version des GNU Pascal Compilers verwendet wird. Folgen Sie diesem
Beispiel:

<pre class="smallexample">     {$if __GPC_RELEASE__ &lt; 20020510}
     {$error This unit requires GPC release 20020510 or newer.}
     {$endif}
</pre>
   <div class="node">
<p><hr>
<a name="Zwischenraum"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Zeilenumbr_00fcche">Zeilenumbrüche</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Compiler_002dDirektiven">Compiler-Direktiven</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pascal-Programmieren">Pascal Programmieren</a>

</div>

<h3 class="section">5.8 Wie man Leerzeichen in Code benutzt.</h3>

<p>Im allgemeinen sollten nie mehrere Leerzeichen aufeinander
folgen, außer für Einrückungen und in speziellen Fällen, die im
folgenden Beschrieben werden.

   <p>Ein einzelner Blank soll vor und nach Operatoren, Zuweisungen
(`<samp><span class="samp">:=</span></samp>') und `<samp><span class="samp">..</span></samp>' stehen. In `<samp><span class="samp">Write</span></samp>', `<samp><span class="samp">WriteLn</span></samp>'
und `<samp><span class="samp">WriteStr</span></samp>' sollte ein Blank um das `<samp><span class="samp">:</span></samp>' angebracht
werden. Ein einzelner Blank soll nach Kommata und anderen `<samp><span class="samp">:</span></samp>'
stehen. Folgendes Beispiel macht es deutlicher:

<pre class="smallexample">     var
       Foo: Integer;
       ...
     begin
       Foo := 42;
       WriteLn (Foo + 3 : 5, ' bar')
     end;
</pre>
   <p>Kein Leerzeichen sollte hingegen nach dem unären Minuszeichen
`<samp><span class="samp">-</span></samp>' stehen. Dieses sind die korrekten Formen: `<samp><span class="samp">x - 1</span></samp>',
`<samp><span class="samp">-x</span></samp>' und `<samp><span class="samp">-1</span></samp>'.

   <p>Ein Leerzeichen sollte vor und eines nach den Klammerzeichen
(`<samp><span class="samp">(</span></samp>') und (`<samp><span class="samp">)</span></samp>') stehen, solange diese nicht neben anderen
Klammern, eckigen Klammern, dem Pointer-Symbol (`<samp><span class="samp">^</span></samp>'), einem
Semikolon oder einem Komma auftreten. Mit anderen Worten: Ein
Leerzeichen sollte zwischen Bezeichnern/Schlüsselwörtern und
der öffnenden Klammern stehen. Beispiel:

<pre class="smallexample">     Foo (Bar^(Baz[Qux * (i + 2)]), Fred (i) + 3);
</pre>
   <p>Für Arrayindizierung wird kein Leerzeichen verwendet (schreiben Sie
`<samp><span class="samp">Foo[42]</span></samp>' anstelle von `<samp><span class="samp">Foo [42]</span></samp>'), jedoch schon bei
Arraydeklarationen:

<pre class="smallexample">     Foo: array [1 .. 42] of Integer;
</pre>
   <p>Bei Mengen-Konstruktoren sollte ggf. ein Blank vor der öffnenden
Klammer stehen &ndash; diese eckigen Klammern sollten wie normale
Klammern behandelt werden:

<pre class="smallexample">     x := [0, 2 .. n];
</pre>
   <p>Aber:

<pre class="smallexample">     Foo ([1, 2, 3]);
</pre>
   <p>Kein Leerzeichen bei `<samp><span class="samp">.</span></samp>' und `<samp><span class="samp">^</span></samp>':

<pre class="smallexample">     Rec.List^.Next^.Field := Foo
</pre>
   <p>Wie wir schon ausführten, soll je ein Blank nach den öffnenden und
vor den schließenden geschweiften Klammern in Kommentaren stehen. 
Dies gilt jedoch nicht für Compiler-Direktiven. Außerdem sollten vor
Kommentaren, die einer Code-Zeile folgen, zwei Leerzeichen stehen:

<pre class="smallexample">     Inc (x);  { Increment x. }
</pre>
   <p><a name="index-Abstand_002c-Einr_00fcckung-72"></a><a name="index-Einr_00fcckung_002c-Abstand-73"></a>Wenn Sie mögen, so fügen Sie beliebig viele Leerzeichen ein, um
&ldquo;tabellarisch&rdquo; aussehenden Quellcode zu erzeugen. Unserer
Meinung nach erhöht dies die Lesbarkeit des Codes ungemein, weil
der menschliche Geist auf solche Strukturen trainiert ist,
Unterschiede in Zeilen besser gesehen werden können, und man
bei Änderungen im Quellcode verwandte Stellen nicht so leicht
übersieht. Eine Anwendung dieser Prinzipien sollte in
Interface-Deklarationen zu finden sein (es ist nicht leicht
anwendbar, wenn jede Routine durch Kommentare getrennt wird, daher
ist in einem solchen Fall möglicherweise ein gemeinsamer Kommentar
empfehlenswert):

<pre class="smallexample">     function Pos             (const SubString, s: String): Integer;
     function LastPos         (const SubString, s: String): Integer;
     function PosCase         (const SubString, s: String): Integer;
     function LastPosCase     (const SubString, s: String): Integer;
     function CharPos         (const Chars: CharSet; const s: String): Integer;
     function LastCharPos     (const Chars: CharSet; const s: String): Integer;
     function PosFrom         (const SubString, s: String; From: Integer): Integer;
     function LastPosTill     (const SubString, s: String; Till: Integer): Integer;
     function PosFromCase     (const SubString, s: String; From: Integer): Integer;
     function LastPosTillCase (const SubString, s: String; Till: Integer): Integer;
</pre>
   <p>Ebenfalls möglich:

<pre class="smallexample">     procedure Foo;
     function  Bar ...;
     procedure Baz;
</pre>
   <p>Und natürlich:

<pre class="smallexample">     const
       FooBar = 1;
       Baz    = 2;
       Quux   = 3;
</pre>
   <p>Dieselbe &ldquo;Tabellenanordnung&rdquo; kann man für Initialisierungen
gebrauchen:

<pre class="smallexample">     const
       Foo: TBarArray =
         (('Foo'    ,  3),
          ('Bar baz', 42),
          (''       , -1));
</pre>
   <p>Und in `<samp><span class="samp">case</span></samp>'-Anweisungen:

<pre class="smallexample">     case ReadKeyWord of
       kbLeft    : if s[n] &gt; l    then Dec (s[n]) else s[n] := m[n];
       kbRight   : if s[n] &lt; m[n] then Inc (s[n]) else s[n] := l;
       kbUp      : if n &gt; 1 then Dec (n) else n := 5;
       kbDown    : if n &lt; 5 then Inc (n) else n := 1;
       kbHome    : s[n] := l;
       kbEnd     : s[n] := m[n];
       kbPgUp,
       kbCtrlPgUp: n := 1;
       kbPgDn,
       kbCtrlPgDn: n := 5;
       kbCR      : Done := True;
     end
</pre>
   <p>Und auch je nach Geschmack in anderem Code:

<pre class="smallexample">     WriteCharAt (1, 1, 1,     Frame[1], TextAttr);
     WriteCharAt (2, 1, w - 2, Frame[2], TextAttr);
     WriteCharAt (w, 1, 1,     Frame[3], TextAttr);
</pre>
   <div class="node">
<p><hr>
<a name="Zeilenumbr%fcche"></a>
<a name="Zeilenumbr_00fcche"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Strings">Strings</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Zwischenraum">Zwischenraum</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pascal-Programmieren">Pascal Programmieren</a>

</div>

<h3 class="section">5.9 Wo man seine Zeilen umbrechen sollte</h3>

<p><a name="index-Zeilenumbr_00fcche-74"></a>
Zeilenumbrüche sind nach <em>lokalen</em> `<samp><span class="samp">const</span></samp>'-, `<samp><span class="samp">type</span></samp>'-
und `<samp><span class="samp">var</span></samp>'-Deklarationen freigestellt, wenn sie nur eine
einzige Deklaration beinhalten (Sie können auch mehrere Bezeichner
in einer Zeile deklarieren/definieren):

<pre class="smallexample">     procedure Baz;
     var Foo, Bar: Integer;
     begin
       ...
     end;
</pre>
   <p>Das geht auch:

<pre class="smallexample">     procedure Baz;
     var
       Foo, Bar: Integer;
     begin
       ...
     end;
</pre>
   <p>Aber bitte nicht so:

<pre class="smallexample">     procedure Baz;
     var Foo, Bar: Integer;
         Qux: Real;
     begin
       ...
     end;
</pre>
   <p>Wenn Sie viele Deklarationen haben, so können Sie Zeilenumbrüche
auf verschiedene Weisen vornehmen. Folgendes Beispiel ist die
bevorzugte Fassung für `<samp><span class="samp">var</span></samp>'-Deklarationen:

<pre class="smallexample">     var
       Foo, Bar, Baz, Qux, Quux, Corge, Grault, Garply, Waldo, Fred,
         Plugh, Xyzzy, Thud: Integer;
</pre>
   <p>oder:

<pre class="smallexample">     var
       Foo, Bar, Baz, Qux, Quux, Corge, Grault, Garply, Waldo: Integer;
       Fred, Plugh, Xyzzy, Thud: Integer;
</pre>
   <p>Die folgende Form ist eher bei der Definition von `<samp><span class="samp">record</span></samp>'-
oder öffentlichen `<samp><span class="samp">object</span></samp>'-Feldern gebräuchlich, besonders,
wenn jeder Zeile ein Kommentar folgt:

<pre class="smallexample">     var
       Foo,
       Bar,
       Baz,
       Qux: Integer;
</pre>
   <p>Kein Zeilenumbruch darf nach `<samp><span class="samp">var</span></samp>'-Deklarationen
innerhalb von Blöcken erfolgen. Solche Zeilenumbrüche setzen das
falsche Signal, daß hier mehrere Deklarationsgruppen erlaubt wären:

<pre class="smallexample">     Foo := Bar;
     var Baz: array [1 .. Foo] of Integer;
</pre>
   <p>Da dieses Statement eine GNU Pascal Erweiterung ist, sollte es
selten eingesetzt werden, bei Variablen, deren Größe erst innerhalb
der Routine berechnet wird oder für Variablen innerhalb von
Modul-/Unit-Initialisierungen beispielsweise, um dafür keine
globalen Variablen zu benötigen. Denken Sie bitte bei der Anwendung
dieses Features über Unterroutinen nach.

   <p><a name="index-Einr_00fcckung-von-Labeln-75"></a>Fügen Sie bitte keinen Zeilenumbruch nach `<samp><span class="samp">label</span></samp>' durch. Sie
sollten Label folgendermaßen deklarieren:

<pre class="smallexample">     label Foo, Bar, Baz;
</pre>
   <p>So sollten Sie es auf keinen Fall tun:

<pre class="smallexample">     label
       Foo,
       Bar,
       Baz;
</pre>
   <p>Verschiedene Deklarationen von Labeln in unterschiedlichen Zeilen
funktionieren auch nicht:

<pre class="smallexample">     label
       Foo;
       Bar;
       Baz;
</pre>
   <p><a name="index-Case-und-der-Zeilenumbruch-76"></a>Hier folgt ein Beispiel, wie man innerhalb eines
`<samp><span class="samp">case</span></samp>'-Blockes Zeilen umbricht:

<pre class="smallexample">     case
       foo:
         begin
           ...
         end;
       bar,
       baz .. qux:
         ...
       else
         ...
     end;
</pre>
   <p>Oder auch &ldquo;tabellarisch&rdquo;:

<pre class="smallexample">     case
       foo:        begin
                     ...
                   end;
       bar,
       baz .. qux: ...
       else        ...
     end;
</pre>
   <p><a name="index-Umbruch-langer-Zeilen-77"></a>Lange Zeilen sollten immer vor oder immer nach Operatoren, sowie
nach Kommata umbrochen werden, wobei die Einrückung die
Gruppierungen verdeutlichen sollte:

<pre class="smallexample">     if (x = y)
        and (foo
             or (bar
                 and (baz or qux))
             or fred) then
</pre>
   <p>Oder so:

<pre class="smallexample">     if (x = y) and
        (foo or
         (bar and
          (baz or qux)) or
         fred) then
</pre>
   <p><a name="index-if-then-else-Anweisungen-und-Zeilenumbr_00fcche-78"></a>Hier sehen Sie, wie Sie Zeilenumbrüche innerhalb von if-then-else
Anweisungen vornehmen können. Diese Art der Einrückung sollte auch
verwendet werden, wenn Sie die `<samp><span class="samp">case</span></samp>'-Anweisung verwenden
würden, dies aber nicht möglich ist (weil die Typen nicht aufzählbar
sind, oder die Werte nicht konstant sind oder ein Vergleich die
Benutzung einer Funktion wie `<samp><span class="samp">StrEqualCase</span></samp>' notwendig machen
würde, oder zusätzliche Bedingungen auftauchen):

<pre class="smallexample">     if ... then
       a
     else if ... then
       b
     else
       c
</pre>
   <p>Wenn `<samp><span class="samp">a</span></samp>' und &ldquo;nicht `<samp><span class="samp">a</span></samp>'&rdquo; die Hauptfälle sind und
`<samp><span class="samp">b</span></samp>' und `<samp><span class="samp">c</span></samp>' Unterfälle von &ldquo;nicht `<samp><span class="samp">a</span></samp>'&rdquo;, so benutzen
Sie bitte die folgende Form (die Unterscheidung ist manchmal
Geschmackssache):

<pre class="smallexample">     if ... then
       a
     else
       if ... then
         b
       else
         c
</pre>
   <p>Das folgende (biologisch gesehen ziemlich unvollständige) Beispiel
enthält eine Mischung beider Formen, die wir für vernünftig halten:

<pre class="smallexample">     if Wohnort = 'Wasser' then
       { Im Wasser lebende Tiere }
       WriteLn ('Ist es ein Fisch?')
     else if Wohnort = 'Luft' then
       { Lufttiere }
       WriteLn ('Ist es ein Vogel?')
     else
       { Landlebewesen }
       if Beine = 8 then
         WriteLn ('Ist es eine Spinne?')
       else
         WriteLn ('Ist es ein Gnu?')
</pre>
   <p>Die Hauptfälle werden hier durch den Wohnort bestimmt, die Anzahl
der Beine bestimmen einige untergeordnete Fälle.

   <p><a name="index-Schleifen-79"></a>Hier eine kurze Zusammenfassung der normalen Schleifen:

<pre class="smallexample">     for ... do
       ...
</pre>
   <pre class="smallexample">     while ... do
       ...
</pre>
   <pre class="smallexample">     repeat
       ...
     until ...
</pre>
   <p>Wenn nur eine einzelne Anweisung nach `<samp><span class="samp">if</span></samp>' oder in einer
`<samp><span class="samp">do</span></samp>'- oder `<samp><span class="samp">for</span></samp>'-Schleife bzw. zwischen `<samp><span class="samp">repeat</span></samp>' und
`<samp><span class="samp">until</span></samp>' existiert und diese Anweisung kurz genug für eine Zeile
ist, so darf diese Anweisung in eine Zeile wie folgt geschrieben
werden:

<pre class="smallexample">     if ... then ...
</pre>
   <pre class="smallexample">     for ... do ...
</pre>
   <pre class="smallexample">     while ... do ...
</pre>
   <pre class="smallexample">     repeat ... until ...
</pre>
   <p>Wenn mehrere Anweisungen mit `<samp><span class="samp">begin</span></samp>' und `<samp><span class="samp">end</span></samp>' in einen
Block gefaßt werden, sieht es folgendermaßen aus:

<pre class="smallexample">     if ... then
       begin
         ...
       end
</pre>
   <pre class="smallexample">     for ... do
       begin
         ...
       end
</pre>
   <pre class="smallexample">     while ... do
       begin
         ...
       end
</pre>
   <p><a name="index-Einr_00fcckung-80"></a>Es wird nach folgenden Ausdrücken 2 Leerzeichen eingerückt:
`<samp><span class="samp">begin</span></samp>', `<samp><span class="samp">then</span></samp>', `<samp><span class="samp">else</span></samp>', `<samp><span class="samp">case</span></samp>', `<samp><span class="samp">do</span></samp>'
(`<samp><span class="samp">for</span></samp>', `<samp><span class="samp">while</span></samp>', `<samp><span class="samp">with</span></samp>', `<samp><span class="samp">to begin</span></samp>',
`<samp><span class="samp">to end</span></samp>'), `<samp><span class="samp">repeat</span></samp>', `<samp><span class="samp">record</span></samp>', `<samp><span class="samp">object</span></samp>',
`<samp><span class="samp">type</span></samp>', `<samp><span class="samp">const</span></samp>', `<samp><span class="samp">var</span></samp>', `<samp><span class="samp">label</span></samp>'.

   <p>Globale Routinen und ihre lokalen Variablen etc. werden nicht
eingerückt, ebenso wie globale Variablen etc. Jede Subroutine (Kopf
und Körper sowie ihre lokalen Variablen etc.) soll eingerückt
werden.

<pre class="smallexample">     program Prog;
     
     var
       GlobalVar: Integer;
     
     procedure GlobalProc;
     var LocalVar: Integer;
     
       procedure LocalProc;
       var LocalLocalVar: Integer;
       begin
         WriteLn ('Dies ist eine lokale Prozedur.')
       end;
     
     begin
       WriteLn ('Dies ist eine globale Prozedur.')
     end;
     
     begin
       WriteLn ('Dies ist das Hautpprogramm.')
     end.
</pre>
   <p>Variante Records sollten so eingerückt werden:

<pre class="smallexample">     type
       Foo = record
         NonVariant: Foo;
       case Discriminant: Bar of
         Val1: (Variant1: Baz;
                Variant2: Qux);
         Val2: (Variant3: Fred)
       end;
     
     var
       Foo: record
         [ wie oben ]
       end = [ Initialisierung ]
</pre>
   <p>Größere Einrückung (mehr als zwei Leerzeichen) kann bei
Zeilenumbrüchen im Code erfolgen, um einen &ldquo;tabularen&rdquo; Code
zu erzeugen.

   <p>Conditionale (`<samp><span class="samp">{$ifdef}</span></samp>') sollten dieselbe Einrückung wie
der zugehörige Code haben:

<pre class="smallexample">     begin
       {$ifdef DEBUG}
       WriteLn ('Debugging-Version');
       {$endif}
       ...
     end;
</pre>
   <p>Kurze Conditionale, die sich nur auf einen Ausdruck beziehen, dürfen
auch in eine Zeile geschrieben werden:

<pre class="smallexample">     Foo := {$ifdef DEBUG} 'Debugging' {$else} 'Veröffentlichung' {$endif};
</pre>
   <p>Wenn Conditionale beabsichtigterweise entgegen den normalen
syntaktischen Regeln genutzt werden, so setzen Sie diese an
passende Stellen und schreiben Kommentare dazu:

<pre class="smallexample">     begin
       { Führe den Code bedingungslos aus, wenn wir debuggen }
       {$ifndef DEBUG}
       if EinigeBedingungen then
       {$endif}
         begin
           ...
         end
     end;
</pre>
   <p>Oftmals finden Sie schönere und nicht weniger effiziente Wege,
dasselbe zu schreiben. In diesem Fall kann es auch so erfolgen:

<pre class="smallexample">     begin
       if {$ifdef DEBUG} True {$else} EinigeBedingungen {$endif} then
         begin
           ...
         end
     end;
</pre>
   <p>Oder noch besser:

<pre class="smallexample">     { global }
     const
       DebugFlag = {$ifdef DEBUG} True {$else} False {$endif};
     
     begin
       if DebugFlag or EinigeBedingungen then
         begin
           ...
         end
     end;
</pre>
   <div class="node">
<p><hr>
<a name="Strings"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Internationalisierung">Internationalisierung</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Zeilenumbr_00fcche">Zeilenumbrüche</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pascal-Programmieren">Pascal Programmieren</a>

</div>

<h3 class="section">5.10 Zeichenketten</h3>

<p><a name="index-Strings-81"></a><a name="index-Zeichenketten-82"></a>
Die meisten der bisherigen Regeln gelten nicht innerhalb von
Strings. Allgemein sollten Textausgaben innerhalb von Zeichenketten
den GNU Coding Standards folgen. Beispielsweise sollten zitierte
Namen von `<samp><span class="samp">`</span></samp>' und `<samp><span class="samp">'</span></samp>' begrenzt werden. In Pascal bedeutet
das, daß Sie doppelte `<samp><span class="samp">'</span></samp>' benutzen müssen. Mehr Informationen:
See <a href="standards.html#Errors">Errors</a>.

   <p>Normalerweise sollten Strings in einfachen Anführungszeichen
so wie `<samp><span class="samp">'dieser schöne Satz, den Sie lesen'</span></samp>' eingeschlossen
sein. Mit doppelten Anführungszeichen sollen nur Zeichenketten
umfaßt werden, die C-Escape-Sequenzen beinhalten, wie
`<samp><span class="samp">"\t"</span></samp>'. Beachten Sie bitte, daß `<samp><span class="samp">NewLine</span></samp>' (`<samp><span class="samp">"\n"</span></samp>')
vordefiniert ist. Geben Sie daher `<samp><span class="samp">NewLine</span></samp>' den Vorzug, wenn
Sie nicht gerade C-Strings für andere Zwecke benötigen.

   <p>Mehrzeilige Strings können folgendermaßen genutzt werden:

<pre class="smallexample">     WriteLn ('Hallo
     Welt!')
</pre>
   <p>Oder (diese Form ist vor allem dann vorzuziehen, wenn der String
selbst Einrückungen und/oder Absätze enthält):

<pre class="smallexample">     WriteLn (
     'Hallo
     Welt!')
</pre>
   <p>Folgendes ist auch möglich:

<pre class="smallexample">     WriteLn ('Hallo' + NewLine + 'Welt!')
</pre>
   <p>(Beachten Sie, daß obiger Code nicht ohne die Unit <code>GPC</code>
kompiliert werden kann.)

   <p>Oder natürlich:

<pre class="smallexample">     WriteLn ('Hallo');
     WriteLn ('Welt!')
</pre>
   <p>Wenn Sie testen möchten, ob ein String leer ist, benutzen Sie
folgende Syntax:

<pre class="smallexample">     if s = '' then
       ...
</pre>
   <p>Der GNU Pascal Compiler optimiert dies automatisch zu folgendem
schnelleren Test. Daher können Sie den vorhergehende, kürzere
Schreibweise ohne Bedenken verwenden:

<pre class="smallexample">     if Length (s) = 0 then
       ...
</pre>
   <p>Dasselbe gilt natürlich auch für `<samp><span class="samp">&lt;&gt;</span></samp>' und sogar für
Zuweisungen, bei denen `<samp><span class="samp">s := ''</span></samp>' die empfohlene Form ist,
welche von GPC intern zu `<samp><span class="samp">SetLength (s, 0)</span></samp>' optimiert wird.

<div class="node">
<p><hr>
<a name="Internationalisierung"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#MemoryMap">MemoryMap</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Strings">Strings</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pascal-Programmieren">Pascal Programmieren</a>

</div>

<h3 class="section">5.11 Techniken zur Internationalisierung</h3>

<p><a name="index-Internationalisierung-83"></a>
Bitte beachten Sie die entsprechende Beschreibung in der
GPC-Dokumentation (see <a href="gpc.html#I18N">I18N</a>).

<div class="node">
<p><hr>
<a name="MemoryMap"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Internationalisierung">Internationalisierung</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pascal-Programmieren">Pascal Programmieren</a>

</div>

<h3 class="section">5.12 MemoryMap</h3>

<p><a name="index-MemoryMap-84"></a>
Dieser Abschnitt der GNU Coding Standards kann so, wie er ist,
auf GNU Pascal übertragen werden. 
Beachten Sie, daß `<samp><span class="samp">mmap</span></samp>' hier `<samp><span class="samp">MemoryMap</span></samp>' bedeutet. 
See <a href="standards.html#Mmap">Mmap</a>.

<div class="node">
<p><hr>
<a name="Dokumentation"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ver_00f6ffentlichungen">Veröffentlichungen</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Pascal-Programmieren">Pascal Programmieren</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">6 Programme dokumentieren</h2>

<p><a name="index-dokumentieren-85"></a>
Wir empfehlen Ihnen, das entsprechende Kapitel der GNU Coding
Standards zu lesen See <a href="standards.html#Documentation">Documentation</a>, die
dortigen Informationen gelten auch für GNU Pascal. Einige
Anmerkungen haben wir aber trotzdem.

   <p>Es wäre schön, eine Man-Page für jedes Programm zu haben. Diese
Man-Page sollte auf eine Info-Dokumentation verweisen. Es existiert
ein GNU Programm namens `<samp><span class="samp">help2man</span></samp>', welches Man-Pages aus der
Ausgabe der `<samp><span class="samp">--help</span></samp>'- und `<samp><span class="samp">--version</span></samp>'-Optionen Ihres
Programmes generiert. Es funktioniert gut, bis auf die Tatsache, daß
es `<samp><span class="samp">FSF</span></samp>' an den Anfang der Man-Page schreibt, was nicht für
jedes mit dem GNU Pascal Compiler erzeugte Programm richtig ist. 
Dies kann jedoch leicht mit der Hand oder automatisch mit einem
Programm wie `<samp><span class="samp">sed</span></samp>' geändert werden.

   <p>Geben Sie sich mit den Man-Pages nicht zuviel Mühe. Sie
gleichzeitig mit der Texinfo-Dokumentation auf dem neusten Stand
zu halten, bedeutet eine Menge Arbeit und ist möglicherweise sehr
fehlerträchtig. Wenn Sie die Man-Page nicht auf dem neuesten Stand
halten, so schafft sie mehr Verwirrung als Nutzen.

   <p>Auf der einen Seite fehlen wichtige Informationen, wenn Man-Pages
zu knapp ausfallen, auf der anderen Seite werden längere Man-Pages
sehr unübersichtlich.

   <p>Mit anderen Worten: Schreiben Sie Info- (bzw. 
Texinfo-)Dokumentation!

<div class="node">
<p><hr>
<a name="Ver%f6ffentlichungen"></a>
<a name="Ver_00f6ffentlichungen"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Glossar">Glossar</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Dokumentation">Dokumentation</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">7 Der Verlauf der Veröffentlichung</h2>

<p><a name="index-Ver_00f6ffentlichung-des-Programmes-86"></a>
Bitte lesen Sie das entsprechende Kapitel der GNU Coding
Standards. Beachten Sie, daß der ganze Aufwand mit den auto-Tools
(`<samp><span class="samp">autoconf</span></samp>', `<samp><span class="samp">automake</span></samp>', <small class="dots">...</small>) im Rahmen von GNU
Pascal normalerweise nicht gebraucht werden. Außerdem sind Makefiles
in GNU Pascal Programmen nicht immer notwendig. 
See <a href="standards.html#Managing-Releases">Managing Releases</a>.

<ul class="menu">
<li><a accesskey="1" href="#Makefile_002dRegeln">Makefile-Regeln</a>:            Wie man Makefiles schreibt
</ul>

<div class="node">
<p><hr>
<a name="Makefile-Regeln"></a>
<a name="Makefile_002dRegeln"></a>
Up:&nbsp;<a rel="up" accesskey="u" href="#Ver_00f6ffentlichungen">Veröffentlichungen</a>

</div>

<h3 class="section">7.1 Wie man Makefiles schreibt</h3>

<p><a name="index-Makefile_002dRegeln-87"></a>
Für Ihre Pascal-Projekte benötigen Sie keine großen `<samp><span class="samp">Makefile</span></samp>'s
und Sie brauchen sich ebenfalls nicht in `<samp><span class="samp">autoconf</span></samp>' und
`<samp><span class="samp">automake</span></samp>' einzuarbeiten. Sie brauchen nur die
Kommandozeilenoption `<samp><span class="samp">--automake</span></samp>'. Alles Weitere erledigt GNU
Pascal für Sie! (Zum Zeitpunkt des Schreibens hat GNU Pascal
einige kleinere Bugs im Zusammenhang mit der
`<samp><span class="samp">automake</span></samp>'-Option. Diese Fehler werden aber nachgebessert. 
Außerdem wird gerade an einem Utility namens `<samp><span class="samp">gp</span></samp>' gearbeitet,
welches Ihnen noch mehr Arbeit beim Kompilieren abnimmt.)

   <p>Ein <em>einfaches</em> Makefile wie das folgende mag angebracht sein:

<pre class="smallexample">     GPC_FLAGS=-O2
     
     all: foo
     
     foo: foo.pas unit1.pas
     	gpc --automake $(GPC_FLAGS) foo.pas
     
     mostlyclean:
     	-rm -f *.o *.gpi *.gpd core
     
     clean: mostlyclean
     	-rm -f foo
     
     distclean: clean
     
     extraclean: distclean
     	-rm -f *~*
     
     maintainer-clean: extraclean
</pre>
   <p>Sie wollen vielleicht dem `<samp><span class="samp">Makefile</span></samp>' noch weitere Regeln
hinzufügen, sei es zur Erstellung der Dokumentation, Datendateien,
Paketen zur Veröffentlichung oder zu was auch immer. Diese Dinge
liegen außerhalb des Rahmens dieses Textes. Die Kompilierung eines
GNU Pascal Programmes erfolgt normalerweise mit
`<samp><span class="samp">gpc --automake</span></samp>'.

<div class="node">
<p><hr>
<a name="Glossar"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Index">Index</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ver_00f6ffentlichungen">Veröffentlichungen</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">8 Glossar der Worte in diesem Text</h2>

<p><a name="index-Glossar-88"></a>
Routinen sind Prozeduren (`<samp><span class="samp">procedure</span></samp>'), Funktionen
(`<samp><span class="samp">function</span></samp>'), Objeckt-Konstruktoren (`<samp><span class="samp">constructor</span></samp>') und
-Destruktoren (`<samp><span class="samp">destructor</span></samp>') sowie (selbstdefinierte)
Operatoren.

   <p>Deklarationen sind diejenigen Bereiche des Programmes, die die
Eigenschaften irgendwelcher Objekte &ldquo;erklären&rdquo;, wie Konstanten,
Typen, Variablen, Units, Module, und selbstverständlich das
Programm.

   <p>Anweisungen bzw. Statements sind solche Teile des Programmes, die
irgendetwas &ldquo;veranlassen&rdquo;. Eine einzelne Anweisung ist eine
Zuweisung (assignment), der Aufruf einer Prozedur (procedure call),
ein Sprungbefehl (`<samp><span class="samp">goto</span></samp>', `<samp><span class="samp">Exit</span></samp>', `<samp><span class="samp">Return</span></samp>',
`<samp><span class="samp">Break</span></samp>', `<samp><span class="samp">Continue</span></samp>'), eine Assembler-Anweisung oder
eine zusammengesetzte Anweisung (`<samp><span class="samp">begin</span></samp>' <small class="dots">...</small> `<samp><span class="samp">end</span></samp>',
`<samp><span class="samp">if</span></samp>', `<samp><span class="samp">case</span></samp>', `<samp><span class="samp">repeat</span></samp>', `<samp><span class="samp">while</span></samp>', `<samp><span class="samp">for</span></samp>',
`<samp><span class="samp">with</span></samp>'), die ihrerseits wieder verschiedene Anweisungen
enthalten dürfen.

   <p>Bezeichner (identifiers) sind Sprachelemente, die Objekten
(Routinen, Konstanten, Variablen, Typen, Units oder Modulen) ihre
Namen geben. Sie können lokal umdefiniert werden, anders als
Schlüsselwörter (keywords), die Teil einer festen Syntax sind
(beispielsweise `<samp><span class="samp">if</span></samp>' <small class="dots">...</small> `<samp><span class="samp">then</span></samp>' <small class="dots">...</small> `<samp><span class="samp">else</span></samp>')
und nicht umdefiniert werden können. Makros sind keine
Sprachelemente, da sie niemals vom Compiler verarbeitet werden,
sondern von einem Präprozessor.

   <p>Endianess ist ein Begriff, der sich auf die Reihenfolge der
Anordnung der höher- und niederwertigen Bytes bezieht. Diese
Reihenfolge ist auf manchen Systeme anders als auf anderen. Schauen
Sie sich bitte die Erklärung dazu im GPC-Info Dokument an
(see <a href="gpc.html#Endianness">Endianness</a>).

   <p><em>Hinweis:</em> Andere Begriffe können hier eingefügt werden,
sobald es sinnvoll erscheint. Wenn Sie die Definition eines
Ausdruckes wissen möchten, so teilen Sie es uns bitte mit.

<div class="node">
<p><hr>
<a name="Index"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Glossar">Glossar</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="unnumbered">Index</h2>

<ul class="index-cp" compact>
<li><a href="#index-Abstand_002c-Einr_00fcckung-72">Abstand, Einrückung</a>: <a href="#Zwischenraum">Zwischenraum</a></li>
<li><a href="#index-Assert-22">Assert</a>: <a href="#Konsitenz_00fcberpr_00fcfung">Konsitenzüberprüfung</a></li>
<li><a href="#index-Aufz_00e4hlungstypen-53">Aufzählungstypen</a>: <a href="#Gro_00dfschreibung">Großschreibung</a></li>
<li><a href="#index-Auskommentieren-39">Auskommentieren</a>: <a href="#Kommentare">Kommentare</a></li>
<li><a href="#index-Auskommentieren-von-Code-70">Auskommentieren von Code</a>: <a href="#Compiler_002dDirektiven">Compiler-Direktiven</a></li>
<li><a href="#index-Bedingte-Kompilierung-65">Bedingte Kompilierung</a>: <a href="#Compiler_002dDirektiven">Compiler-Direktiven</a></li>
<li><a href="#index-Beitr_00e4ge-zum-Dokument-4">Beiträge zum Dokument</a>: <a href="#Vorwort">Vorwort</a></li>
<li><a href="#index-Beschreibende-Kommentare-41">Beschreibende Kommentare</a>: <a href="#Kommentare">Kommentare</a></li>
<li><a href="#index-Blanks-24">Blanks</a>: <a href="#Formatierung">Formatierung</a></li>
<li><a href="#index-Blanks-bei-Direktiven-58">Blanks bei Direktiven</a>: <a href="#Compiler_002dDirektiven">Compiler-Direktiven</a></li>
<li><a href="#index-Boolean-18">Boolean</a>: <a href="#Verschiedene-Tips">Verschiedene Tips</a></li>
<li><a href="#index-Boolsche-Werte-17">Boolsche Werte</a>: <a href="#Verschiedene-Tips">Verschiedene Tips</a></li>
<li><a href="#index-C_002dCode-Compilation-12">C-Code Compilation</a>: <a href="#Pascal-und-C">Pascal und C</a></li>
<li><a href="#index-Case-und-der-Zeilenumbruch-76">Case und der Zeilenumbruch</a>: <a href="#Zeilenumbr_00fcche">Zeilenumbrüche</a></li>
<li><a href="#index-Compiler_002dDirektiven-57">Compiler-Direktiven</a>: <a href="#Compiler_002dDirektiven">Compiler-Direktiven</a></li>
<li><a href="#index-Conditionale-und-GPC_002dVersionen-71">Conditionale und GPC-Versionen</a>: <a href="#Compiler_002dDirektiven">Compiler-Direktiven</a></li>
<li><a href="#index-Conditionale-und-Implementationsverwaltung-68">Conditionale und Implementationsverwaltung</a>: <a href="#Compiler_002dDirektiven">Compiler-Direktiven</a></li>
<li><a href="#index-Conditionale-und-Versionsverwaltung-67">Conditionale und Versionsverwaltung</a>: <a href="#Compiler_002dDirektiven">Compiler-Direktiven</a></li>
<li><a href="#index-Debug_002dFlag-66">Debug-Flag</a>: <a href="#Compiler_002dDirektiven">Compiler-Direktiven</a></li>
<li><a href="#index-declaration-blocks-45">declaration blocks</a>: <a href="#Reihenfolge">Reihenfolge</a></li>
<li><a href="#index-Deklarationen-innerhalb-eines-Typ_002dDeklarations_002dBlocks-47">Deklarationen innerhalb eines Typ-Deklarations-Blocks</a>: <a href="#Reihenfolge">Reihenfolge</a></li>
<li><a href="#index-Deklarationen-innerhalb-von-Objekttypen-48">Deklarationen innerhalb von Objekttypen</a>: <a href="#Reihenfolge">Reihenfolge</a></li>
<li><a href="#index-dokumentieren-85">dokumentieren</a>: <a href="#Dokumentation">Dokumentation</a></li>
<li><a href="#index-Download-der-Coding-Standards-2">Download der Coding Standards</a>: <a href="#Vorwort">Vorwort</a></li>
<li><a href="#index-Dumme-Kommentare-34">Dumme Kommentare</a>: <a href="#Kommentare">Kommentare</a></li>
<li><a href="#index-Einr_00fcckung-80">Einrückung</a>: <a href="#Zeilenumbr_00fcche">Zeilenumbrüche</a></li>
<li><a href="#index-Einr_00fcckung-von-Labeln-75">Einrückung von Labeln</a>: <a href="#Zeilenumbr_00fcche">Zeilenumbrüche</a></li>
<li><a href="#index-Einr_00fcckung_002c-Abstand-73">Einrückung, Abstand</a>: <a href="#Zwischenraum">Zwischenraum</a></li>
<li><a href="#index-Feedback-3">Feedback</a>: <a href="#Vorwort">Vorwort</a></li>
<li><a href="#index-Fehlerabfragen-15">Fehlerabfragen</a>: <a href="#Verhalten-von-Programmen">Verhalten von Programmen</a></li>
<li><a href="#index-Fixme-Kommentare-43">Fixme Kommentare</a>: <a href="#Kommentare">Kommentare</a></li>
<li><a href="#index-Formatierung-23">Formatierung</a>: <a href="#Formatierung">Formatierung</a></li>
<li><a href="#index-Globale-Variablen-19">Globale Variablen</a>: <a href="#Verschiedene-Tips">Verschiedene Tips</a></li>
<li><a href="#index-Glossar-88">Glossar</a>: <a href="#Glossar">Glossar</a></li>
<li><a href="#index-Gro_00dfschreibung-50">Großschreibung</a>: <a href="#Gro_00dfschreibung">Großschreibung</a></li>
<li><a href="#index-Gro_00dfschreibung-von-Bezeichnern-51">Großschreibung von Bezeichnern</a>: <a href="#Gro_00dfschreibung">Großschreibung</a></li>
<li><a href="#index-Gro_00dfschreibung-von-Konstanten-52">Großschreibung von Konstanten</a>: <a href="#Gro_00dfschreibung">Großschreibung</a></li>
<li><a href="#index-Gro_00dfschreibung-von-Makros-56">Großschreibung von Makros</a>: <a href="#Gro_00dfschreibung">Großschreibung</a></li>
<li><a href="#index-Header_002d_00dcbersetzung-11">Header-Übersetzung</a>: <a href="#Pascal-und-C">Pascal und C</a></li>
<li><a href="#index-if-then-else-Anweisungen-und-Zeilenumbr_00fcche-78">if then else Anweisungen und Zeilenumbrüche</a>: <a href="#Zeilenumbr_00fcche">Zeilenumbrüche</a></li>
<li><a href="#index-Internationalisierung-83">Internationalisierung</a>: <a href="#Internationalisierung">Internationalisierung</a></li>
<li><a href="#index-Kommentare-29">Kommentare</a>: <a href="#Kommentare">Kommentare</a></li>
<li><a href="#index-Kommentare-bei-nicht-naheliegendem-Code-36">Kommentare bei nicht naheliegendem Code</a>: <a href="#Kommentare">Kommentare</a></li>
<li><a href="#index-Kommentare-mit-Textauszeichnung-42">Kommentare mit Textauszeichnung</a>: <a href="#Kommentare">Kommentare</a></li>
<li><a href="#index-Kommentare-und-Direktiven-59">Kommentare und Direktiven</a>: <a href="#Compiler_002dDirektiven">Compiler-Direktiven</a></li>
<li><a href="#index-Kommentare-zu-externen-Quellen-38">Kommentare zu externen Quellen</a>: <a href="#Kommentare">Kommentare</a></li>
<li><a href="#index-Kommentare-zur-Trennung-logischer-Abschnitte-40">Kommentare zur Trennung logischer Abschnitte</a>: <a href="#Kommentare">Kommentare</a></li>
<li><a href="#index-Kommentarraster-32">Kommentarraster</a>: <a href="#Kommentare">Kommentare</a></li>
<li><a href="#index-Komplizierte-Conditionale-69">Komplizierte Conditionale</a>: <a href="#Compiler_002dDirektiven">Compiler-Direktiven</a></li>
<li><a href="#index-Konsitenz_00fcberpr_00fcfung-21">Konsitenzüberprüfung</a>: <a href="#Konsitenz_00fcberpr_00fcfung">Konsitenzüberprüfung</a></li>
<li><a href="#index-Konstanten-54">Konstanten</a>: <a href="#Gro_00dfschreibung">Großschreibung</a></li>
<li><a href="#index-Leerzeichen-25">Leerzeichen</a>: <a href="#Formatierung">Formatierung</a></li>
<li><a href="#index-Leerzeilen-28">Leerzeilen</a>: <a href="#Formatierung">Formatierung</a></li>
<li><a href="#index-legal-aspects-5">legal aspects</a>: <a href="#Rechtliches">Rechtliches</a></li>
<li><a href="#index-Linken-mit-C-Bibliotheken-9">Linken mit C Bibliotheken</a>: <a href="#Pascal-und-C">Pascal und C</a></li>
<li><a href="#index-Linker_002dDirektiven-64">Linker-Direktiven</a>: <a href="#Compiler_002dDirektiven">Compiler-Direktiven</a></li>
<li><a href="#index-Lokale-Direktiven-62">Lokale Direktiven</a>: <a href="#Compiler_002dDirektiven">Compiler-Direktiven</a></li>
<li><a href="#index-Makefile_002dRegeln-87">Makefile-Regeln</a>: <a href="#Makefile_002dRegeln">Makefile-Regeln</a></li>
<li><a href="#index-MemoryMap-84"><code>MemoryMap</code></a>: <a href="#MemoryMap">MemoryMap</a></li>
<li><a href="#index-Nicht_002dStandard-Erweiterungen-13">Nicht-Standard Erweiterungen</a>: <a href="#Erweiterungen-benutzen">Erweiterungen benutzen</a></li>
<li><a href="#index-no_002dwarning-Direktive-61">no-warning Direktive</a>: <a href="#Compiler_002dDirektiven">Compiler-Direktiven</a></li>
<li><a href="#index-OOP-55">OOP</a>: <a href="#Gro_00dfschreibung">Großschreibung</a></li>
<li><a href="#index-Pascal-und-C-8">Pascal und C</a>: <a href="#Pascal-und-C">Pascal und C</a></li>
<li><a href="#index-Plazierung-der-Kommentare-33">Plazierung der Kommentare</a>: <a href="#Kommentare">Kommentare</a></li>
<li><a href="#index-Programmiersprache-7">Programmiersprache</a>: <a href="#Die-Programmiersprache">Die Programmiersprache</a></li>
<li><a href="#index-Projektgestaltung-6">Projektgestaltung</a>: <a href="#Gestaltungsratschl_00e4ge">Gestaltungsratschläge</a></li>
<li><a href="#index-Reihenfolge-44">Reihenfolge</a>: <a href="#Reihenfolge">Reihenfolge</a></li>
<li><a href="#index-Reihenfolge-der-Implementation-49">Reihenfolge der Implementation</a>: <a href="#Reihenfolge">Reihenfolge</a></li>
<li><a href="#index-Schleifen-79">Schleifen</a>: <a href="#Zeilenumbr_00fcche">Zeilenumbrüche</a></li>
<li><a href="#index-Signal_002dFunktionen-14">Signal-Funktionen</a>: <a href="#Verhalten-von-Programmen">Verhalten von Programmen</a></li>
<li><a href="#index-Sprache-in-Kommentaren-31">Sprache in Kommentaren</a>: <a href="#Kommentare">Kommentare</a></li>
<li><a href="#index-Standard_002dDirektiven-60">Standard-Direktiven</a>: <a href="#Compiler_002dDirektiven">Compiler-Direktiven</a></li>
<li><a href="#index-Steuerzeichen-26">Steuerzeichen</a>: <a href="#Formatierung">Formatierung</a></li>
<li><a href="#index-Strings-81">Strings</a>: <a href="#Strings">Strings</a></li>
<li><a href="#index-Testen-der-R_00fcckgabewerte-63">Testen der Rückgabewerte</a>: <a href="#Compiler_002dDirektiven">Compiler-Direktiven</a></li>
<li><a href="#index-Trickreiche-Kommentare-37">Trickreiche Kommentare</a>: <a href="#Kommentare">Kommentare</a></li>
<li><a href="#index-Triviale-Kommentare-35">Triviale Kommentare</a>: <a href="#Kommentare">Kommentare</a></li>
<li><a href="#index-Umbruch-langer-Zeilen-77">Umbruch langer Zeilen</a>: <a href="#Zeilenumbr_00fcche">Zeilenumbrüche</a></li>
<li><a href="#index-Unendliche-Schleifen-20">Unendliche Schleifen</a>: <a href="#Verschiedene-Tips">Verschiedene Tips</a></li>
<li><a href="#index-Variablen_002dDeklaration-46">Variablen-Deklaration</a>: <a href="#Reihenfolge">Reihenfolge</a></li>
<li><a href="#index-Ver_00f6ffentlichung-des-Programmes-86">Veröffentlichung des Programmes</a>: <a href="#Ver_00f6ffentlichungen">Veröffentlichungen</a></li>
<li><a href="#index-Verschachtelte-Kommentare-30">Verschachtelte Kommentare</a>: <a href="#Kommentare">Kommentare</a></li>
<li><a href="#index-Verschiedene-Tips-16">Verschiedene Tips</a>: <a href="#Verschiedene-Tips">Verschiedene Tips</a></li>
<li><a href="#index-Wo-man-die-GPCS-findet-1">Wo man die GPCS findet</a>: <a href="#Vorwort">Vorwort</a></li>
<li><a href="#index-Wrapper-10">Wrapper</a>: <a href="#Pascal-und-C">Pascal und C</a></li>
<li><a href="#index-Zeichenketten-82">Zeichenketten</a>: <a href="#Strings">Strings</a></li>
<li><a href="#index-Zeilenl_00e4nge-27">Zeilenlänge</a>: <a href="#Formatierung">Formatierung</a></li>
<li><a href="#index-Zeilenumbr_00fcche-74">Zeilenumbrüche</a>: <a href="#Zeilenumbr_00fcche">Zeilenumbrüche</a></li>
</ul>
<div class="contents">
<h2>Table of Contents</h2>
<ul>
<li><a name="toc_Top" href="#Top">Version</a>
<li><a name="toc_Vorwort" href="#Vorwort">1 Über die GNU Pascal Coding Standards</a>
<li><a name="toc_Rechtliches" href="#Rechtliches">2 Freie Software soll frei bleiben</a>
<li><a name="toc_Gestaltungsratschl_00e4ge" href="#Gestaltungsratschl_00e4ge">3 Allgemeine Projektgestaltung</a>
<ul>
<li><a href="#Die-Programmiersprache">3.1 Welche Sprache nimmt man</a>
<li><a href="#Pascal-und-C">3.2 Linken mit C Bibliotheken</a>
<li><a href="#Erweiterungen-benutzen">3.3 Das Benutzen von nicht standardisierten Erweiterungen</a>
</li></ul>
<li><a name="toc_Verhalten-von-Programmen" href="#Verhalten-von-Programmen">4 Wie sich Programme verhalten sollten</a>
<li><a name="toc_Pascal-Programmieren" href="#Pascal-Programmieren">5 Ratschläge zur Gestaltung des Quelltextes</a>
<ul>
<li><a href="#Verschiedene-Tips">5.1 Verschiedene Tips zur Gestaltung</a>
<li><a href="#Konsitenz_00fcberpr_00fcfung">5.2 Explizite Überprüfung der internen Konsistenz</a>
<li><a href="#Formatierung">5.3 Wie man die Quellen formatiert</a>
<li><a href="#Kommentare">5.4 Quellen kommentieren</a>
<li><a href="#Reihenfolge">5.5 Reihenfolge der Code Bereiche</a>
<li><a href="#Gro_00dfschreibung">5.6 Großschreibung</a>
<li><a href="#Compiler_002dDirektiven">5.7 Benutzung von Compiler-Direktiven</a>
<li><a href="#Zwischenraum">5.8 Wie man Leerzeichen in Code benutzt.</a>
<li><a href="#Zeilenumbr_00fcche">5.9 Wo man seine Zeilen umbrechen sollte</a>
<li><a href="#Strings">5.10 Zeichenketten</a>
<li><a href="#Internationalisierung">5.11 Techniken zur Internationalisierung</a>
<li><a href="#MemoryMap">5.12 MemoryMap</a>
</li></ul>
<li><a name="toc_Dokumentation" href="#Dokumentation">6 Programme dokumentieren</a>
<li><a name="toc_Ver_00f6ffentlichungen" href="#Ver_00f6ffentlichungen">7 Der Verlauf der Veröffentlichung</a>
<ul>
<li><a href="#Makefile_002dRegeln">7.1 Wie man Makefiles schreibt</a>
</li></ul>
<li><a name="toc_Glossar" href="#Glossar">8 Glossar der Worte in diesem Text</a>
<li><a name="toc_Index" href="#Index">Index</a>
</li></ul>
</div>

</body></html>

