$MirOS$
--- Objects/unicodeobject.c.orig	2007-11-02 23:46:38.000000000 +0100
+++ Objects/unicodeobject.c	2008-08-05 20:39:33.000000000 +0200
@@ -254,6 +254,8 @@ PyUnicodeObject *_PyUnicode_New(Py_ssize
 	    }
 	}
         else {
+	    if (length > (PY_SSIZE_T_MAX - 1) / sizeof(Py_UNICODE))
+		return NULL;
 	    unicode->str = PyMem_NEW(Py_UNICODE, length + 1);
         }
         PyObject_INIT(unicode, &PyUnicode_Type);
@@ -262,6 +264,8 @@ PyUnicodeObject *_PyUnicode_New(Py_ssize
         unicode = PyObject_New(PyUnicodeObject, &PyUnicode_Type);
         if (unicode == NULL)
             return NULL;
+	if (length > (PY_SSIZE_T_MAX - 1) / sizeof(Py_UNICODE))
+	    return NULL;
 	unicode->str = PyMem_NEW(Py_UNICODE, length + 1);
     }
 
@@ -1091,6 +1095,9 @@ PyObject *PyUnicode_EncodeUTF7(const Py_
     char * out;
     char * start;
 
+    if (cbAllocated / 5 != size)
+        return PyErr_NoMemory();
+
     if (size == 0)
 		return PyString_FromStringAndSize(NULL, 0);
 
@@ -1689,8 +1696,9 @@ PyUnicode_EncodeUTF16(const Py_UNICODE *
 {
     PyObject *v;
     unsigned char *p;
+    Py_ssize_t nsize, bytesize;
 #ifdef Py_UNICODE_WIDE
-    int i, pairs;
+    Py_ssize_t i, pairs;
 #else
     const int pairs = 0;
 #endif
@@ -1713,8 +1721,14 @@ PyUnicode_EncodeUTF16(const Py_UNICODE *
 	if (s[i] >= 0x10000)
 	    pairs++;
 #endif
-    v = PyString_FromStringAndSize(NULL,
-		  2 * (size + pairs + (byteorder == 0)));
+    /* 2 * (size + pairs + (byteorder == 0)) */
+    if (size > PY_SSIZE_T_MAX || size > PY_SSIZE_T_MAX - pairs - (byteorder == 0))
+	return PyErr_NoMemory();
+    nsize = (size + pairs + (byteorder == 0));
+    bytesize = nsize * 2;
+    if (bytesize / 2 != nsize)
+	return PyErr_NoMemory();
+    v = PyString_FromStringAndSize(NULL, bytesize);
     if (v == NULL)
         return NULL;
 
@@ -2041,7 +2055,12 @@ PyObject *unicodeescape_string(const Py_
     PyObject *repr;
     char *p;
 
-    static const char *hexdigit = "0123456789abcdef";
+    static const char *hexdigit = "0123456789abcdef";	
+#ifdef Py_UNICODE_WIDE
+    const Py_ssize_t expandsize = 10;
+#else
+    const Py_ssize_t expandsize = 6;
+#endif
 
     /* Initial allocation is based on the longest-possible unichr
        escape.
@@ -2057,13 +2076,12 @@ PyObject *unicodeescape_string(const Py_
        escape.
     */
 
+    if (size > (PY_SSIZE_T_MAX - 2 - 1) / expandsize )
+	return PyErr_NoMemory();
+
     repr = PyString_FromStringAndSize(NULL,
         2
-#ifdef Py_UNICODE_WIDE
-        + 10*size
-#else
-        + 6*size
-#endif
+        + expandsize*size
         + 1);
     if (repr == NULL)
         return NULL;
@@ -2303,13 +2321,17 @@ PyObject *PyUnicode_EncodeRawUnicodeEsca
     char *p;
     char *q;
 
-    static const char *hexdigit = "0123456789abcdef";
-
+    static const char *hexdigit = "0123456789abcdef";	
 #ifdef Py_UNICODE_WIDE
-    repr = PyString_FromStringAndSize(NULL, 10 * size);
+    const Py_ssize_t expandsize = 10;
 #else
-    repr = PyString_FromStringAndSize(NULL, 6 * size);
+    const Py_ssize_t expandsize = 6;
 #endif
+    
+    if (size > PY_SSIZE_T_MAX / expandsize )
+	return PyErr_NoMemory();
+    
+    repr = PyString_FromStringAndSize(NULL, expandsize * size);
     if (repr == NULL)
         return NULL;
     if (size == 0)
@@ -4719,7 +4741,13 @@ PyUnicodeObject *pad(PyUnicodeObject *se
         return self;
     }
 
-    u = _PyUnicode_New(left + self->length + right);
+    if (left > PY_SSIZE_T_MAX - self->length || right > PY_SSIZE_T_MAX - (left + self->length)
+            ||
+        !(u = _PyUnicode_New(left + self->length + right))
+    ) {
+        PyErr_SetString(PyExc_OverflowError, "padded string is too long");
+        return NULL;
+    }
     if (u) {
         if (left)
             Py_UNICODE_FILL(u->str, fill, left);
