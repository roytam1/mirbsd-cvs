This package combines LLVM and Clang.


Low Level Virtual Machine (LLVM) is:

1. A compilation strategy designed to enable effective program optimi-
   zation across the entire lifetime of a program. LLVM supports effec-
   tive optimization at compile time, link-time (particularly inter-
   procedural), run-time and offline (i.e., after software is instal-
   led), while remaining transparent to developers and maintaining
   compatibility with existing build scripts.

2. A virtual instruction set - LLVM is a low-level object code repre-
   sentation that uses simple RISC-like instructions, but provides rich,
   language-independent, type information and dataflow (SSA) information
   about operands. This combination enables sophisticated transforma-
   tions on object code, while remaining light-weight enough to be
   attached to the executable. This combination is key to allowing
   link-time, run-time, and offline transformations.

3. A compiler infrastructure - LLVM is also a collection of source code
   that implements the language and compilation strategy. The primary
   components of the LLVM infrastructure are a GCC-based C & C++ front-
   end, a link-time optimization framework with a growing set of global
   and interprocedural analyses and transformations, static back-ends
   for the X86, X86-64, PowerPC 32/64, ARM, Thumb, IA-64, Alpha, SPARC,
   MIPS and CellSPU architectures, a back-end which emits portable C
   code, and a Just-In-Time compiler for X86, X86-64, PowerPC 32/64
   processors, and an emitter for MSIL.

4. LLVM does not imply things that you would expect from a high-level
   virtual machine. It does not require garbage collection or run-time
   code generation (In fact, LLVM makes a great static compiler!). Note
   that optional LLVM components can be used to build high-level virtual
   machines and other systems that need these services.

LLVM is a robust system, particularly well suited for developing new
mid-level language-independent analyses and optimizations of all sorts,
including those that require extensive interprocedural analysis. LLVM is
also a great target for front-end development for conventional or
research programming languages, including those which require compile-
time, link-time, or run-time optimization for effective implementation,
proper tail calls or garbage collection. We have an incomplete list of
projects which have used LLVM for various purposes, showing that you can
get up-and-running quickly with LLVM, giving time to do interesting
things, even if you only have a semester in a University course. We also
have a list of ideas for projects in LLVM.


clang: a C language family frontend for LLVM

 The goal of the Clang project is to create a new C, C++, Objective C
 and Objective C++ front-end for the LLVM compiler. You can get and
 build the source today.

Features and Goals

 Some of the goals for the project include the following:

 End-User Features:
 * Fast compiles and low memory use
 * Expressive diagnostics
 * GCC compatibility

 Utility and Applications:
 * Modular library based architecture
 * Support diverse clients (refactoring, static analysis, code
   generation, etc)
 * Allow tight integration with IDEs
 * Use the LLVM 'BSD' License

 Internal Design and Implementation:
 * A real-world, production quality compiler
 * A simple and hackable code base
 * A single unified parser for C, Objective C, C++, and Objective C++
 * Conformance with C/C++/ObjC and their variants

 Of course this is only a rough outline of the goals and features of
 Clang. To get a true sense of what it is all about, see the Features
 section, which breaks each of these down and explains them in more
 detail.

Why?

 The development of a new front-end was started out of a need -- a need
 for a compiler that allows better diagnostics, better integration with
 IDEs, a license that is compatible with commercial products, and a
 nimble compiler that is easy to develop and maintain. All of these were
 motivations for starting work on a new front-end that could meet these
 needs.

 For a more detailed comparison between Clang and other compilers,
 please see the clang comparison page.

Current Status

 Clang is still in early development stages. If you are looking for
 source analysis or source-to-source transformation tools, clang is
 probably a great solution for you. If you want to use it as a drop in C
 compiler, it is not yet ready.

 Clang currently has pretty good parsing and semantic analysis support
 for C and Objective-C right now, and bugs are usually quickly fixed
 once reported. C++ support is still very early, and we don't expect to
 have respectable C++ support for another 2 years or so.
