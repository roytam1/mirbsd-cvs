nwcc is a small C compiler for Unix systems that I wrote in my
freetime, for fun and to prove to myself that I could. I started
the project in August 2003, but because I had a job and a life and
a few other hobby code projects, it took me until autumn 2005 to
make it work with various constructs of the C language.

So what new things does nwcc bring to the table? Most importantly,
new code: I wrote everything from scratch - including the lexer,
parser and backend.

The code is written in C, is currently around 60.000 lines in
size, and I'm releasing it under the BSD license. It works with
Linux/FreeBSD/OpenBSD/Solaris on 80x86, Linux/FreeBSD/OpenBSD on
AMD64, Solaris/Linux on SPARC, AIX on PowerPC, and IRIX on MIPS
hardware. Cross-compilation and PIC code for shared libraries are
also supported.

The current release is not intended for serious use, but at least
nwcc is strong enough to compile itself (the result of which can
compile nwcc as well) and should thus be capable of dealing with
at least some small programs. There are still some things
missing/broken, but things are improving almost all the time (I
upload my changes to SF whenever I add/fix something of interest.)

Feature-wise, there is little interesting to be had in nwcc yet:
• Support for various C language features is incomplete or broken;
  Most notably support for floating point, bitfields and a few
  other things.
• There are few features a power developer used to established
  mainstream compilers would consider interesting, yet. Sorry.
  There is little beyond plain dumb (cross-)compilation;
  Especially symbolic debugging and profiling support are still
  missing
• There is absolutely no optimization, meaning the generated code
  is very slow compared to the output of established compilers. I
  will work on this soon, but you should understand that my
  primary concerns right now are code correctness and portability
  rather than speed (it's hard enough to make slow code work!)

It takes a lot of work to get even a subset of the C language to
compile, so the fact that something is missing or done wrong in
nwcc does not mean that I don't care about that particular area of
the C language or compiler design; It only means that I haven't
gotten around to doing it right, or indeed at all, yet.

The primary goals of nwcc currently are portability and correctness. Due to the amount of required work, many tradeoffs are necessary. As a result of many tradeoffs and compromises, neither nwcc's portability nor its correctness seem particularly impressive for the time being - But stay tuned, things will only get better!

• The currently supported architectures are x86, AMD64, SPARC,
  MIPS and PowerPC. ARM is going to join this list some time soon,
  possibly followed by other embedded architectures or PA-RISC
  within the next year
• Cross-compilation is supported (but not heavily tested!)
• nwcc implements most of C90 (ISO C), though various language
  constructs that are particularly obscure, rarely used and/or of
  dubious usefulness are not yet implemented, or implemented in a
  broken way - see the bugs page for details
• Various GNU C and C99 features are also supported, such as
• The long long type
• inline/restrict keywords (ignored)
• typeof()/alignof()
• computed gotos
• __func__/__PRETTY_FUNCTION__
• flexible array members
• compound literals and designated initializers
• (very incomplete single-dimensional) VLA support
• statements as expressions
• mixed declarations and code
• builtin stdarg functions
• builtin alloca()
• gcc style inline assembly (only on x86 and AMD64)
• The x86 and AMD64 backends support two assemblers; nasm/yasm and
  gas. This can be useful for side-by-side assembler syntax
  comparison
• nwcc can already generate many useful warnings, in some cases
  more so than gcc
• There is basic support for PIC (position-independent code) and
  TLS (thread-local storage)
