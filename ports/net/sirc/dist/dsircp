#!/usr/bin/env perl
# $MirOS: ports/net/sirc/dist/dsircp,v 1.33 2012/06/24 13:53:58 tg Exp $
#-
# dsircp: dumb-mode small irc client in perl
# by orabidoo <roger.espel.llima@pobox.com>
#
# Copyright (C) 1995-1997 Roger Espel Llima
# Copyright (c) 2002-2003 Hubert Feyrer
# Copyright (c) Phil Stracchino
# Copyright (c) 2001-2017 mirabilos
# Copyright (c) 2017 multiplexd
#
# This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
# the utmost extent permitted by applicable law, neither express nor
# implied; without malicious intent or gross negligence. In no event
# may a licensor, author or contributor be held liable for indirect,
# direct, other damage, loss, or other issues arising in any way out
# of dealing in the work, even if advised of the possibility of such
# damage or existence of a defect, except proven that it results out
# of said person's immediate fault when using the work as intended.
#-
# for a full-screen termcap interface, use this with ssfe
#
# use: dsircp [options] [nick [server[:port[:password]]]]
# options are:
#	-p = specify port number (start with s for SSL)
#	-i = specify IRCNAME
#	-u = specify username (quite useless as an option)
#	-n = specify nickname (quite useless as an option)
#	-s = specify server (quite useless as an option)
#	-l = specify file to be loaded instead of ~/.etc/sircrc.pl
#	-L = specify file to be loaded instead of ~/.etc/sircrc
#	-H = specify virtual host to bind to
#	-q = don't load ~/.etc/sircrc or ~/.etc/sircrc.pl
#	-Q = don't load system sircrc or sircrc.pl
#	-R = run in restricted (secure) mode
#	-r = raw mode (no control-char filtering)
#	-8 = 8-bit mode (enabled by default, use -7 to disable)
#	-7 = 7-bit (ISO_646.irv:1991) mode
#	-U = non-UTF-8 (Unicode) mode
#	-C = set local charset to optarg
#	-X = set local charset to UTF-8
#	-T = do not show timestamps on messages by default

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License, Version 2, as
# published by the Free Software Foundation.
#
# If you make improvements to sirc, please send me the modifications
# (unified diffs appreciated) and they might make it to the next release.
#
# For bug reports, comments, questions, email roger.espel.llima@pobox.com
# and miros-discuss@mirbsd.org but not junk@mirbsd.org ;)
#
# You can always find the latest version of sirc at the following URL:
# http://www.eleves.ens.fr:8080/home/espel/sirc/sirc.html
# This fork of sirc is maintained in the MirPorts Framework, though.

$version='2.211-MirPorts-@DIST_DATE@';
$date='01 Sep 2005';
$add_ons='';
$msgchannel = '';
$interactive = 1;
$has_capab = 0; $capab_cmd = ''; $capab_response = ''; $opportunistic_cmd = '';
$has_identifymsg = 0; $unverified = 1; $unverified_m = 0;

$libdir=$ENV{"SIRCLIB"} || "@PREFIX@/share/sirc/";
push(@INC, $libdir, $ENV{"HOME"}."/.etc/sirc");
@loadpath=($ENV{"HOME"}."/.etc/sirc", $libdir, ".");

$|=1;

if (!eval "require 'getopts.pl';") {
  print "\n\n\
Your perl interpreter is *really* screwed up: the getopts.pl library is not
even there! Have you even bothered to run 'install'?\n";
  exit;
}

BEGIN {
  $have_socket = 0;
  if ($] >= 5 && (eval "use Socket;", $@ eq '')) {
    $have_socket = 4;
    eval "use Socket6;";
    $have_socket = 6 if $@ eq '';
  }
}

if ($have_socket != 0) {
  ;
} elsif (-f "$libdir/sircsock.ph") {
  do "$libdir/sircsock.ph";
} elsif (-f $ENV{'HOME'}."/sircsock.ph") {
  do $ENV{'HOME'}."/sircsock.ph";
} elsif (!eval "require 'sys/socket.ph';") {
    print "\n\n\
Your perl installation is wrong somewhere, the sys/socket.ph include file
couldn't be found. Have you even bothered to run 'install'?\n";
    exit;
}
use Encode;
use POSIX ":sys_wait_h";
use BSD::arc4random;

sub NZATUpdate($$) {
	my ($h, $s) = @_;

	foreach my $c (unpack("C*", $s)) {
		$h = ($h + $c + 1) * 1025;
		$h %= 2**32;
		$h ^= $h >> 6;
	}
	return ($h);
}

sub NZAATFinish($) {
	my $h = shift;

	$h += $h << 10;
	$h %= 2**32;
	$h ^= $h >> 6;
	$h %= 2**32;
	$h += $h << 3;
	$h %= 2**32;
	$h ^= $h >> 11;
	$h %= 2**32;
	$h += $h << 15;
	$h %= 2**32;

	return ($h);
}

my $lrhash_v = 0;
sub lrhash_timer {
	my $v;

	$v = NZAATFinish($lrhash_v);
	$lrhash_v = NZATUpdate(0,
	    pack("w", BSD::arc4random::arc4random_pushb($v)));
	&timer(600, "&lrhash_timer;");
}
&lrhash_timer;

sub lrhash_add($$) {
	my ($direction, $s) = @_;

	$s = pack("w", time) . pack("w", BSD::arc4random::arc4random()) . $s;
	$lrhash_v = NZATUpdate($lrhash_v,
	    $direction . pack("w", length($s)) . $s);
}
sub arandom_add($) {
	my $s = shift;
	my $v;

	$v = NZAATFinish($lrhash_v);
	$lrhash_v = NZATUpdate($lrhash_v,
	    pack("w", BSD::arc4random::arc4random_pushb(pack("w", $v) . $s)));
}

sub parseserver {
  local $args = $_[0];
  if ($args =~ m/^\[([^\]]+)\](.*)$/) {
    ($server, $port, $pass) = split(/[\s:]+/, $2);
    $server = $1;
  } else {
    ($server, $port, $pass) = split(/[\s:]+/, $args);
  }
}

$AB = ''; $AC = ''; $BB = ''; $VB = '';
sub update_charset {
  $AB = Encode::encode($set{"CHARSET"}, "\x{AB}", 0);
  $AC = Encode::encode($set{"CHARSET"}, "\x{AC}", 0);
  $BB = Encode::encode($set{"CHARSET"}, "\x{BB}", 0);
  $VB = Encode::encode($set{"CHARSET"}, "\x{239C}", 0);
  if ($VB eq '?') {
    $VB = Encode::encode($set{"CHARSET"}, "\x{2502}", 0);
  }
  if ($VB eq '?') {
    $VB = '|';
  }
}

&Getopts('n:s:p:u:i:l:L:H:rqQR78UC:XT');

%set=("LOGFILE", "", "LOG", "off", "PRINTUH", "none", "PRINTCHAN", "off",
	"LOCALHOST", "", "CTCP", "no",
	"USERINFO", "", "FINGER", "", "IRCNAME", "", "EIGHT_BIT", "on",
	"LOADPATH", join(":", @loadpath), "CTRL_T", "/next", "UTF", "on",
	"CHARSET", "iso-8859-1", "SHOWTIME", "on", "HIGHLIGHT", "off");

$raw_mode=$opt_r || (!-t STDOUT);
$ansi=!$raw_mode && $ENV{"TERM"} =~ /^vt|^xterm|^ansi/i;
$ssl_args = $ENV{'SIRCSSL'} || '-CApath /etc/ssl/certs';
$server=$opt_s || $ARGV[1] || $ENV{"SIRCSERVER"} || $ENV{"IRCSERVER"} ||
		"chat.freenode.net";
$port0=$opt_p || $ENV{"SIRCPORT"} || $ENV{"IRCPORT"} || 6667;
$username=$opt_u || $ENV{"SIRCUSER"} || $ENV{"IRCUSER"} || (getpwuid($<))[0] ||
		$ENV{"USER"} || "blah";
$set{"IRCNAME"}=$opt_i || $ENV{"SIRCNAME"} || $ENV{"IRCNAME"} || "/whois your father?";
$nick=$opt_n || $ARGV[0] || $ENV{"SIRCNICK"} || $ENV{"IRCNICK"} || $username;
$set{"FINGER"}=$ENV{"IRCFINGER"} || "keep your fingers to yourself";
$set{"USERINFO"}=$ENV{"USERINFO"} || "yep, I'm a happy MirBSD user";
&parseserver($server);
$port || ($port=$port0);
$port0=$port;
$server0=$server1=$server;
$initfile=$opt_l || $ENV{"SIRCRCPL"} || $ENV{'HOME'}."/.etc/sircrc.pl"
  if $opt_l || !$opt_q;
$sysinit=$libdir."/sircrc.pl" if $libdir ne '.' && !$opt_Q;
$rcfile=$opt_L || $ENV{"SIRCRC"} || $ENV{'HOME'}."/.etc/sircrc"
  if $opt_L || !$opt_q;
$sysrc=$libdir."/sircrc" if $libdir ne '.' && !$opt_Q;
$set{"LOGFILE"}=$logfile=$ENV{'HOME'}."/sirc.log";
$opt_7 && ($set{"EIGHT_BIT"}="off");
$restrict=$opt_R;
$set{"LOCALHOST"}=$opt_H || $ENV{"SIRCHOST"} || $ENV{"IRCHOST"} ||
		$ENV{"LOCALHOST"} || "";
$opt_U && ($set{"UTF"}="off");
$opt_C && ($set{"CHARSET"}=$opt_C);
$opt_X && ($set{"CHARSET"}="utf8");
$opt_T && ($set{"SHOWTIME"}="off");
&update_charset();

if ($set{"LOCALHOST"}) {
  $bindaddr=&resolve($set{"LOCALHOST"}, 0);
}

@ARGV=();  # ignore any more arguments

if (open(H, "$libdir/sirc.help") || ((-f "$libdir/sirc.help.gz") &&
     open(H, "gzip -cd $libdir/sirc.help.gz |"))) {
  @help=<H>;
  close(H);
  foreach (@help) {
    chop;
    s/\$version/$version/g;
    s/\$date/$date/g;
  }
} else {
  print "*** Warning: help file ($libdir/sirc.help) not found!\n";
}

sub exit {
  arandom_add("exit");
  $logging && print LOG "*\cbL\cb* " . sprintf("Final entropy [%08X]",
    NZAATFinish($lrhash_v)) . ", terminating on " . &date(time) . "\n";
  close(LOG) if $logging;
  &ssl_cleanup;
  exit 0;
}

$SIG{'PIPE'}='IGNORE';
$SIG{'QUIT'}='IGNORE';
$SIG{'INT'}='exit';

sub eq {
  local($a, $b)=@_;
  $a =~ tr/A-Z[]\\~/a-z{}|^/;
  $b =~ tr/A-Z[]\\~/a-z{}|^/;
  return ($a eq $b);
}

sub tilde {
  $_[0] =~ s|^\~(\w+)|(getpwnam($1))[7]|e;
  $_[0] =~ s/^\~/$ENV{'HOME'}/;
  $_[0]="." if $_[0] eq '';
}

sub sigquit {
  # really ugly hack, but it works...
  close($trysock);
}

sub resolve {
  $use_ipv6 = 0;
  if ($_[0] =~ /^\d+$/) {
    return pack("N", $_[0]+0);
  } elsif ($_[0] =~ /^(\d+)\.(\d+)\.(\d+)\.(\d+)$/) {
    return pack("c4", $1, $2, $3, $4);
  } elsif (($have_socket == 6) && ($_[1] == 1)) {
    local $rc;

    $rc = (gethostbyname2($_[0], AF_INET6))[4];

    if ($rc) {
      $use_ipv6 = 1;
      return $rc;
    }
  }
  return (gethostbyname($_[0]))[4];
}

$nextfh="sircblah000";
sub newfh {
  return ++$nextfh;
}

sub REAPER {
  my $child;
  while (($child = waitpid(-1,WNOHANG)) > 0) {
    &tell("*\cb?\cb* Child $child exited with status $?");
  }
  # loathe sysV: it makes us not only reinstate
  # the handler, but place it after the wait
  $SIG{CHLD} = \&REAPER;
}
$SIG{CHLD} = \&REAPER;
$ssl_pid = 0;
$ssl_efd = '';

sub ssl_cleanup {
  if ($ssl_efd ne '') {
    while (&gl($ssl_efd)) {
      last if $_ eq '';
      chop;
      s/\x00//g;
      &tell("*\cbS\cb* TLS: $_");
    }
    close($ssl_efd);
    delete $buffer{$ssl_efd};
    $ssl_efd = '';
  }
  if ($ssl_pid) {
    kill TERM => $ssl_pid;
  }
  $ssl_pid = 0;
}

sub connect {
  $_[0]=&newfh;
  local($fh, $host, $port, $use_ssl)=@_;
  &ssl_cleanup;
  if ($use_ssl) {
    my $spfh = $fh;
    my $scfh = &newfh;
    my $spe = &newfh;
    my $sce = &newfh;
    my $pid;

    if (!socketpair($scfh, $spfh, &AF_UNIX, &SOCK_STREAM, &PF_UNSPEC)) {
      &tell("*\cbE\cb* Cannot create a socket pair: $!");
      return 0;
    }
    if (!socketpair($sce, $spe, &AF_UNIX, &SOCK_STREAM, &PF_UNSPEC)) {
      &tell("*\cbE\cb* Cannot create a second socket pair: $!");
      close($scfh);
      close($spfh);
      return 0;
    }
    if ($pid = fork) {
      my $cmd = "openssl s_client -quiet -connect ${host}:${port} $ssl_args";
      &tell("*\cbS\cb* Spawning: $cmd");
      close($spfh);
      close($spe);
      shutdown($sce, 0);
      open(STDIN, "<&$scfh");
      open(STDOUT, ">&$scfh");
      open(STDERR, ">&$sce");
      select(STDERR); $| = 1;
      select(STDOUT); $| = 1;
      exec $cmd;
    }
    if (!defined $pid) {
      &tell("*\cbE\cb* Cannot fork: $!");
      close($scfh);
      close($spfh);
      close($sce);
      close($spe);
      return 0;
    }
    close($scfh);
    close($sce);
    select($spe); $|=1; select(STDOUT);
    shutdown($spe, 1);
    $ssl_pid = $pid;
    $ssl_efd = $spe;
  } else {
    local $try_ipv6_if_available = 2;
 retry_resolve:
    local($adr, $otherend)=&resolve($host, --$try_ipv6_if_available);
    &tell("*\cbE\cb* Hostname '$host' not found"), return 0 unless $adr;
    if ($use_ipv6) {
      $otherend=pack_sockaddr_in6($port, $adr);
      &print("*\cbE\cb* Out of file descriptors"), return 0
       unless socket($fh, &PF_INET6, &SOCK_STREAM, 0);
    } else {
      $otherend=pack_sockaddr_in($port, $adr);
      &print("*\cbE\cb* Out of file descriptors"), return 0
       unless socket($fh, &PF_INET, &SOCK_STREAM, 0);
    }
    if (!$use_ipv6) {
      if ($set{"LOCALHOST"}) {
        bind($fh, pack("S n a4 x8", &AF_INET, 0, $bindaddr)) ||
         &tell("*\cbE\cb* Warning: can't bind to sirc host ".$set{'LOCALHOST'});
      }
    }
    $trysock=$fh;
    $SIG{'QUIT'}='sigquit';
    unless (connect($fh, $otherend)) {
      &print("*\cbE\cb* Can't connect to host: $!");
      $SIG{'QUIT'}='IGNORE', &print("*** Retrying with Legacy IP"),
        goto retry_resolve if ($use_ipv6);
      close($fh);
      $SIG{'QUIT'}='IGNORE';
      return 0;
    }
    $SIG{'QUIT'}='IGNORE';
    if ($use_ipv6) {
        $bindaddr=(unpack_sockaddr_in6(getsockname($fh)))[2] if !$bindaddr;
    } else {
        $bindaddr=(unpack_sockaddr_in(getsockname($fh)))[2] if !$bindaddr;
    }
  }
  select($fh); $|=1; select(STDOUT);
  return 1;
}

sub listen {
  $_[0]=&newfh;
  local($fh, $port)=@_;
  local($thisend);
  if ($use_ipv6) {
      $bindaddr=pack_sockaddr_in6(0, 0) unless $bindaddr;
      $thisend=pack_sockaddr_in6($port+0, $bindaddr);
      &tell("*\cbE\cb* Out of file descriptors"), return 0
       unless socket($fh, &PF_INET6, &SOCK_STREAM, 0);
  } else {
      $bindaddr=pack_sockaddr_in(0, 0) unless $bindaddr;
      $thisend=pack_sockaddr_in($port+0, $bindaddr);
      &tell("*\cbE\cb* Out of file descriptors"), return 0
       unless socket($fh, &PF_INET, &SOCK_STREAM, 0);
  }
  &tell("*\cbE\cb* Can't bind local socket!"), close($fh), return 0
    unless bind($fh, $thisend);
  &tell("*\cbE\cb* Can't listen to socket!"), close($fh), return
    unless listen($fh, 5);
  if ($use_ipv6) {
      return (unpack_sockaddr_in6(getsockname($fh)))[1];
  } else {
      return (unpack_sockaddr_in(getsockname($fh)))[1];
  }
}

sub accept {
  $_[0]=&newfh;
  return (accept($_[0], $_[1]), close($_[1]))[0];
}

sub bindtoserver {
  my $xport = $port;
  my $xssl = 0;

  @channels=(); $talkchannel=''; $talkserver = ''; $use_ipv6=0;
  %mode=(); $umode=''; %limit=(); %haveops=(); %chankey=(); $away='';
  $listmin=0; $listmax=100000; $listpat='';
  @waituh=(); @douh=(); @erruh=(); $invited='';
  &dostatus;
  if ($xport =~ s/^(s|S)//) {
    $xssl = 1;
  }
  &tell("*** Connecting to $server, port $xport" .
    ($xssl ? " (using OpenSSL)" : "") . "...");
  &connect($S, $server, $xport, $xssl) || return;
  $connected=1;
  $talkserver=$server1=$server;
  &sl("PASS $pass") if $pass;
  &sl("USER $username blah blah :".$set{'IRCNAME'});
  &sl("NICK $nick");
  @channels=(); $talkchannel=''; %mode=(); $umode=''; %limit=();
  %haveops=(); %chankey=();
  %awaymsgs=(); %awaytimes=();
}

sub gl {
  if ((defined $buffer{$_[0]}) &&
   ($buffer{$_[0]} =~ /^([^\n\r]*)\r?\n\r?/)) {
    $buffer{$_[0]}=$';
    $_=$1."\n";
    return 1;
  }
  local($buf)='';
  local($buf2)='';
  if (sysread($_[0], $buf, 4096)) {
    if ($_[0] eq $S) {
      lrhash_add("I", $buf);
      $buf =~ s/\ca([<>])\ca/\cb$1\cb/g;
      $buf =~ s/\cc((99|1[0-5]|0?[0-9])(,(99|1[0-5]|0?[0-9]))?)?//g;
      $buf2 .= Encode::decode("utf8", $buf, Encode::FB_QUIET);
      $buf2 .= Encode::decode("windows-1252", $buf, Encode::FB_QUIET);
      $buffer{$_[0]} .= Encode::encode($set{"CHARSET"}, $buf2, 0);
    } else {
      my $ioport = "U";
      $ioport = "S" if (($ssl_efd ne '') && ($_[0] eq $ssl_efd));
      $ioport = "K" if ($_[0] eq 'STDIN');
      lrhash_add($ioport, $buf);
      $buffer{$_[0]} .= $buf;
    }
    if ($buffer{$_[0]} =~ /^([^\n\r]*)\r?\n\r?/) {
      $buffer{$_[0]}=$';
      $_=$1."\n";
      return 1;
    }
    return '';
  }
  $_='';
  return 1;
}

sub sl {
  local($buf)=$_[0];
  local($buf2)='';
  local($buf3)='';
  $buf2 .= Encode::decode($set{"CHARSET"}, $buf, Encode::FB_QUIET);
  $buf2 .= Encode::decode("utf8", $buf, Encode::FB_QUIET);
  $buf2 .= Encode::decode("windows-1252", $buf, 0);
  if ($set{"UTF"} ne 'off') {
    $buf3 = Encode::encode("utf8", $buf2, 0);
  } else {
    $buf3 = Encode::encode("windows-1252", $buf2, 0);
  }
  lrhash_add("O", $buf3);
  &print("*\cbE\cb* Error writing to server: $!") unless print $S $buf3."\n";
}

sub dostatus {
  return unless $ssfe;
  local($t, $s)=($talkchannel, " [sirc]  ");
  $t =~ tr/A-Z[]\\~/a-z{}|^/;
  $s.="*" if $umode =~ /o/;
  if ($t) {
    $s .= $haveops{$t} if $haveops{$t};
  }
  $s.=$nick;
  $s.=" (+$umode)" if $umode;
  $s.=" [query: ${query}]" if $query;
  $s.=" (away)" if $away;
  if ($talkchannel ne '') {
    $s.=" on $talkchannel (+$mode{$t})";
    $s.=" <key: $chankey{$t}>" if $chankey{$t};
    $s.=" <limit: $limit{$t}>" if $limit{$t};
  }
  &dohooks("status", $s);
  $laststatus=$s, print "`#ssfe#s$s\n" if $laststatus ne $s;
}

$bold="\c[[1m";
$underline="\c[[4m";
$reverse="\c[[7m";
$normal="\c[[m";
$cls="\c[[H\c[[2J";

sub enhance {
  local($what)=@_;
  $what =~ tr/\c@-\c_\x7F/@-_?/;
  return "\cv${what}\cv";
}

sub print {
  local($skip, $what)=(0, @_);
  &dohooks("print", $what);
  return if $skip;
  $what =~ s/\s+$//;
  if ($unverified_m) {
    if ($what =~ /^\*/) {
      $what =~ s/</$AB/;
      $what =~ s/>/$BB/;
    } elsif ($what =~ /^(\<|\[|\-)(\S+)(\>|\]|\-)\s/) {
      $what =~ s/^<(\S+)> /$AB$1$BB /;
      $what =~ s/^\[(\S+)\] /[[$1]] /;
      $what =~ s/^-(\S+)- /$AC$1$AC /;
    }
    $unverified_m = 0;
  }
  # thanks to Toy (wacren@obspm.fr) for this translation
  $what =~ tr/\x80-\xff/e ,f,.tT\^*S<o Z  ''"".\-\-\~Ts>o zy !cLxY|$_ca<\-\-R_o+23\'mp.,1o>123?AAAAAAACEEEEIIIIDNOOOOO*0UUUUYPBaaaaaaaceeeeiiiidnooooo:0uuuuypy/
    if $set{"EIGHT_BIT"} ne 'on';
  $what = &sortnames($what) if ($what =~ /Users on [&#+!][^\x00\x07\x0A\x0D ,]+:/);
  $tstamp = sprintf("%02d:%02d:%02d", (localtime)[2], (localtime)[1], (localtime)[0]);
  $logging && print LOG "[" . $tstamp . "] " . $what . "\n";
  $tstamp =~ s/:[^:]*$//;
  if ($raw_mode) {
    $tstamp .= $VB;
    if ($set{"SHOWTIME"} eq 'off') {
      $tstamp = "";
    }
    print($tstamp . $what, "\n") || &exit;
  } elsif ($ansi) {
    $tstamp = "\cv" . $tstamp . "\cv ";
    if ($set{"SHOWTIME"} eq 'off') {
      $tstamp = "";
    }
    $what =~ s/([\ca\cc-\ch\cj-\cu\cw-\c^\x7F])/&enhance($1)/eg;
    # this should be better
    my ($is_bold,$is_ul,$is_rev) = (0,0,0);
    my $ansi_code = [[["\c[[m","\c[[7m"],
		      ["\c[[4m","\c[[4;7m"]],
		     [["\c[[1m","\c[[1;7m"],
		      ["\c[[1;4m","\c[[1;4;7m"]]];

    while ($what =~ /(\c[bv_])/) {
      if ($1 == "\cb") {
	$is_bold = $is_bold ? 0 : 1;
      } elsif ($1 == "\c_") {
	$is_ul = $is_ul ? 0 : 1;
      } elsif ($1 == "\cv") {
	$is_rev = $is_rev ? 0 : 1;
       }
      my $code = $ansi_code->[$is_bold][$is_ul][$is_rev];
      $what =~ s/\c[bv_]/$code/;
    }
    print($tstamp . $what, $normal, "\n") || &exit;
  } else {
    $tstamp .= "| ";
    if ($set{"SHOWTIME"} eq 'off') {
      $tstamp = "";
    }
    $what =~ tr/\ca-\ch\cj-\c_\x7F//d;
    print($tstamp . $what, "\n") || &exit;
  }
}

sub nocase {
  uc($a) cmp uc($b);
}

sub sortnames {
  my ($what) = @_;
  my ($head,$tail) = split(/:\s+/,$what,2);
  $what = join(': ', $head, join(' ',sort nocase (split(/\s+/,$tail))));
  return ($what);
}

sub tell {
  $silent || &print;
}

sub tell_i {
  if (!$has_identifymsg) {
    $unverified_m = 0;
  } elsif ($unverified) {
    $unverified_m = 0;
  } else {
    $unverified_m = 1;
  }
  $silent || &print;
}

sub strip_idmsg {
  $unverified = 1;
  if ($args =~ /^([-+])/) {
    $unverified = 0 if ($1 ne '-');
    $vwho = "(" . $1 . "id) " . $who;
    $args =~ s/^[-+]//;
  }
  $args =~ s/\s+$//;
}

sub dohooks {
  $hooktype=shift;
  local(@hl);
  eval "\@hl=\@${hooktype}_hooks;";
  foreach $h (@hl) {
    eval { &$h(@_); };
    $@ =~ s/\n$//, &tell("*\cbE\cb* error in $hooktype hook &$h: $@")
	if $@ ne '';
  }
}

sub msg {
  local($towho, $what)=@_;
  $what =~ s/\s+$//;
  if ($ssfe) {
    local($x)=0;
    if ($query) {
      $x=1;
    } elsif (!&eq($towho, $talkchannel)) {
      $x=1;
    }
    if ($x) {
      print "`#ssfe#t/m $towho \n";
    }
  }
  if ($connected>1) {
    &dohooks("send_text", $towho, $what);
    foreach my $output (&splitoutl($what)) {
      if (&eq($towho, $talkchannel) && !$printchan) {
	&tell("<\c_${nick}\c_> $output");
      } elsif ($towho =~ /^[\&\#\+]/) {
	&tell("<\c_$nick\c_:$towho> $output");
      } else {
	&tell(">\cb${towho}\cb< $output");
      }
      &sl("PRIVMSG $towho :$output");
    }
  } else {
    &tell("*** You're not connected to a server");
  }
}

sub splitoutl {
  my ($line) = @_;
  my $width = 448;
  my ($p, @split);

  while (length($line) > $width) {
    $p = rindex($line, ' ', $width);
    if ($p == $width) {
      push (@split, substr($line, 0, $p));
      $line = substr($line, $p+1);
    } elsif ($p > 0) {
      push (@split, substr($line, 0, $p));
      $line = substr($line, $p+1);
    } else {
      push (@split, substr($line, 0, $width-2) . '-');
      $line = substr($line, $width-1);
    }
  }
  push (@split, $line) if (length($line));

  return (@split);
}

sub say {
  if ($talkchannel) {
    &msg($talkchannel, @_);
  } else {
    &tell("*\cbE\cb* Not on a channel");
  }
}

sub notice {
  local($towho, $what)=@_;
  $what=substr($what, 0, 485);
  &dohooks("send_notice", $towho, $what);
  &tell("-> -\cb${towho}\cb- $what");
  &sl("NOTICE $towho :$what");
}

sub describe {
  local($towho, $what)=@_;
  $msgchannel = $towho;
  $what=substr($what, 0, 480);
  &dohooks("send_action", $towho, $what);
  if (&eq($towho, $talkchannel) && !$printchan) {
    &tell("* $nick $what");
  } elsif ($towho =~ /^[\#\&\+]/) {
    &tell("* ${nick}:${towho} $what");
  } else {
    &tell("*-> \cb${towho}\cb: $nick $what");
  }
  &sl("PRIVMSG $towho :\caACTION".($what eq "" ? "" : " ").$what."\ca");
}

sub me {
  if ($talkchannel) {
    &describe($talkchannel, @_);
  } else {
    &tell("*\cbE\cb* Not on a channel");
  }
}

sub yetonearg {
  ($newarg, $args)=split(/ +/, $args, 2);
  $args =~ s/^://;
}

sub getarg {
  ($newarg, $args)=split(/ +/, $args, 2);
}

@weekdays=("Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat");
@months=("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct",
  "Nov", "Dec");

sub date {
  local($sec, $min, $hour, $mday, $mon, $year, $wday)=localtime($_[0]);
  return sprintf("$weekdays[$wday] $months[$mon] $mday %.2d:%.2d:%.2d %d",
		 $hour, $min, $sec, $year+1900);
}

sub reply {
  return if $set{"CTCP"} eq 'noreply';
  if ($lastrep<time-10) {
    $lastrep=time;
    $nreps=1;
  } else {
    return if $nreps++>=2 && $set{"CTCP"} eq 'noflood';
  }
  &sl("NOTICE $who :\ca$_[0]\ca");
}

sub ctcp {
  local($towho, $to, $what)=$_[0];
  $msgchannel = $towho;
  ($what, $args)=split(/ +/, $_[1], 2);
  $what =~ tr/a-z/A-Z/;
  &dohooks("ctcp", $towho, $what, $args);
  return if $skip;
  local($a)=$args;
  $a && ($a=' '.$a);
  $to = (&eq($towho, $nick) ? "you" : $towho);
  &tell("*** $vwho$puh1 did a CTCP $what$a to $to")
    unless $what =~ /^(ACTION|ENTROPY|PING|RANDOM)$/;
  if ($what eq 'ACTION') {
    &dohooks("action", $towho, $args);
    if (&eq($towho, $nick)) {
      &tell_i("[*] \cb${who}\cb$puh1 $args");
    } elsif (&eq($towho, $talkchannel) && !$printchan) {
      &tell($unverified
	? "* $who $args"
	: "# $who $args"
      );
    } else {
      &tell($unverified
	? "* $who$puh2:$towho $args"
	: "# $who$puh2:$towho $args"
      );
    }
  } elsif ($what eq 'TIME') {
    &reply("TIME ".&date(time));
  } elsif ($what eq 'CLIENTINFO') {
    &reply("CLIENTINFO ACTION, CLIENTINFO, ECHO, ENTROPY, ERRMSG, FINGER, PING, RANDOM, TIME, USERINFO, VERSION");
  } elsif ($what eq 'FINGER') {
    &reply("FINGER ".$set{"FINGER"});
  } elsif ($what eq 'USERINFO') {
    &reply("USERINFO ".$set{"USERINFO"});
  } elsif ($what eq 'VERSION') {
    local($u)=$add_ons;
    $u =~ s/^\+//;
    $u =~ s/\+/ + /g;
    $u=" -- using $u" if $u;
    &reply("VERSION sirc $version (RANDOM=${BSD::arc4random::RANDOM}), a \cbperl\cb client$u");
  } elsif ($what eq 'PING') {
    &reply("PING $args");
    &tell("*** $vwho$puh1 did a CTCP PING to $to");
  } elsif ($what eq 'ECHO' || $what eq 'ERRMSG') {
    &reply("$what $args");
  } elsif ($what eq 'ENTROPY') {
    arandom_add("init $vwho,$puh1;$towho,$args");
    my $evalue = pack("u", BSD::arc4random::arc4random_bytes(32));
    chop($evalue);
    &tell("*** $vwho$puh1 initiated the RANDEX protocol with $to");
    &reply("RANDOM $evalue");
  } elsif ($what eq 'RANDOM') {
    arandom_add("info $vwho,$puh1;$towho,$args");
    &tell("*** $vwho$puh1 queried RANDEX protocol information from $to");
    if ($set{"CTCP"} ne 'noreply') {
      my $papi = (BSD::arc4random::have_kintf() ? "Perl" : "none");
      my $skip_r = 0;
      if ($lastrep<time-10) {
        $lastrep=time;
        $nreps=1;
      } elsif ($nreps++>=2 && $set{"CTCP"} eq 'noflood') {
        $skip_r = 1;
      }
      &sl("PRIVMSG $who :\caACTION uses MirSirc $version$add_ons with built-in support for the RANDEX protocol, push API: ${papi}\ca") unless $skip_r;
    }
  }
}

sub doset {
  local($var, $val)=@_;
  $var =~ tr/a-z/A-Z/;
  $val="" unless defined($val);
  if ($var eq 'PRINTUH') {
    $set{$var}="all" if $val =~ /^(on|all)$/i;
    $set{$var}="some" if $val =~ /^some$/i;
    $set{$var}="none" if $val =~ /^(off|none)$/i;
  } elsif ($var eq 'PRINTCHAN') {
    $set{$var}="on", $printchan=1 if $val =~ /^on$/i;
    $set{$var}="off", $printchan=0 if $val =~ /^off$/i;
  } elsif ($var eq 'UTF' || $var eq 'SHOWTIME') {
    $set{$var}="on" if $val =~ /^on/i;
    $set{$var}="off" if $val =~ /^of/i;
  } elsif ($var eq 'CHARSET') {
    $set{$var}=$val;
    &update_charset();
  } elsif ($var eq 'CTCP') {
    $val =~ tr/A-Z[]\\~/a-z{}|^/;
    $set{$var}=$val if $val =~ /^(none|all)$/;
    $set{$var}="noreply" if $val =~ /^(noreply|off)$/;
    $set{$var}="noflood" if $val =~ /^(noflood|on)$/;
  } elsif ($var eq 'USERINFO') {
    $set{$var}=$val;
  } elsif ($var eq 'FINGER') {
    $set{$var}=$val;
  } elsif ($var eq 'IRCNAME') {
    $set{$var}=$val;
  } elsif ($var eq 'EIGHT_BIT') {
    $val =~ tr/A-Z[]\\~/a-z{}|^/;
    $set{$var}=$val if $val =~ /^(on|off)$/;
  } elsif ($var eq 'LOCALHOST') {
    &restrict || return;
    local($ad)=&resolve($val, 0);
    $set{$var}=$val, $bindaddr=$ad if $ad;
  } elsif ($var eq 'LOADPATH') {
    @loadpath=split(/:/, $val);
    foreach (@loadpath) {
      &tilde($_);
    }
    $set{$var}=join(":", @loadpath);
  } elsif ($var eq 'CTRL_T') {
    $set{$var}=$val;
    print "`#ssfe#T$val\n" if $ssfe;
  } elsif ($var eq 'LOGFILE') {
    &restrict || return;
    &tilde($val);
    $logfile=$set{$var}=$val;
  } elsif ($var eq 'LOG') {
    &restrict || return;
    if ($val =~ /^(off|restart)$/i) {
      if ($logging) {
        print LOG "*\cbL\cb* Log ended on ".&date(time)."\n";
        close(LOG);
      }
      $logging='';
      $set{$var}="off";
    }
    if ($val =~ /^(on|restart)$/i) {
      $logging && close(LOG);
      if (open(LOG,
	  ($logfile =~ /\.gz$/ ? "| gzip >> $logfile" : ">> $logfile"))) {
	$logging=1;
	$set{$var}="on";
	select(LOG); $|=1; select(STDOUT);
	print LOG "*\cbL\cb* IRC log started on ".&date(time)."\n";
      } else {
	$logging='';
	$set{$var}="off";
	&tell("*\cbE\cb* Can't write to logfile $logfile");
      }
    }
  } elsif ($var eq 'HIGHLIGHT') {
    $val =~ tr/A-Z[]\\~/a-z{}|^/;
    $set{$var}=$val if $val =~ /^(on|off)$/;
  } elsif (defined($sets{$var})) {
    local($f)=$sets{$var};
    eval { &$f($val); };
    $@ =~ s/\n$//, &tell("*\cbE\cb* error in SET $var hook: $@") if $@ ne '';
  }
}

sub ctcpreply {
  local($ctcp, $rest)=split(/ +/, $_[1], 2);
  local $vis = 1;
  local $towho = $_[0];
  $ctcp =~ tr/a-z/A-Z/;
  &dohooks("ctcp_reply", $towho, $ctcp, $rest);
  if ($ctcp eq 'PING') {
    $rest = (time-$rest);
    $rest .= ($rest == 1) ? " second" : " seconds";
  } elsif ($ctcp eq 'RANDOM') {
    my $t = (BSD::arc4random::have_kintf() ? "" : "not ") . "pushing to kernel";
    arandom_add("recv $vwho,$puh1;$towho,$rest");
    &tell("*** RANDEX protocol reply from $vwho$puh1 to $towho, ${t}");
    $vis = 0;
  }
  return unless $vis;
  if (&eq($towho, $nick)) {
    &tell("*** CTCP $ctcp reply from $vwho$puh1: $rest");
  } else {
    &tell("*** CTCP $ctcp reply to $towho from $vwho$puh2: $rest");
  }
}

sub load {
  local($f)=@_;
  &tilde($f);
  if ($f !~ /\//) {
    foreach (@loadpath) {
      $f="$_/$f", last if -f "$_/$f";
      $f="$_/${f}.pl", last if $f !~ /\.pl$/ && -f "$_/${f}.pl";
    }
  } else {
    $f.=".pl" if -f "${f}.pl" && !-f $f;
  }
  if ($f =~ /\// && -f $f) {
    do $f;
    $@ =~ s/\n$//, &tell("*\cbE\cb* Load error in $f: $@") if $@ ne '';
  } else {
    &tell("*\cbE\cb* $f: File not found");
  }
}

sub restrict {
  &tell("*\cbE\cb* Command not available"), return 0 if $restrict;
  1;
}

sub dosplat {
  $args =~ s/^\s*\*($|\s)/${talkchannel}${1}/ if $talkchannel;
}

sub expand {
  if ($_[0] eq '$') {
    return '$';
  } elsif ($_[0] =~ /^(\d+)$/) {
    return (split(/ +/, $args))[$1];
  } elsif ($_[0] =~ /^(\d+)-$/) {
    return (split(/ +/, $args, 1+$1))[$1];
  } else {
    return eval "\$$_[0]";
  }
}

$recdepth=0;
$maxrecursion=20;

sub docommand {
  local($line)=@_;
  local($recdepth)=$recdepth+1;
  &print("*\cbE\cb* Max recursion exceeded!"), return
    if $recdepth > $maxrecursion;
  local($noalias)=($line =~ s/^\///);
  local($silent)=1 if $line =~ s/^\^//;
  local($cmd, $args)=split(/ +/, $line, 2);
  $cmd =~ tr/a-z/A-Z/;
  if (!$noalias && defined($aliases{$cmd})) {
    $line=$aliases{$cmd};
    $line.=($args ne '' ? " ".$args : "")
      unless ($line =~ s/\$(\$|\d+-?|\w+)/&expand($1)/eg);
    $line =~ s/^\///;
    $noalias=1 if $line =~ s/^\///;
    $silent=1 if $line =~ s/^\^//;
    ($cmd, $args)=split(/ +/, $line, 2);
    $cmd =~ tr/a-z/A-Z/;
  }
  if (!$noalias && defined($cmds{$cmd})) {
    eval $cmds{$cmd};
    $@ =~ s/\n$//, &tell("*\cbE\cb* error in command $cmd: $@") if $@ ne '';
  } elsif ($cmd eq 'ALIAS') {
    &getarg;
    if ($newarg =~ /^-/) {
      local($a)=$';
      if ($a eq '') {
	%aliases=();
	&tell("*** All aliases removed");
      } else {
	$a =~ tr/a-z/A-Z/;
	delete $aliases{$a};
	&tell("*** Alias $a removed");
      }
    } elsif ($newarg ne '') {
      $newarg =~ tr/a-z/A-Z/;
      if ($args ne '') {
	$aliases{$newarg}=$args;
	&tell("*** $newarg aliased to $args");
      } else {
	if (defined($aliases{$newarg})) {
	  &tell("*** $newarg is aliased to: $aliases{$newarg}");
	} else {
	  &tell("*** $newarg: no such alias");
	}
      }
    } else {
      foreach $a (sort(keys(%aliases))) {
	&tell("*** $a is aliased to $aliases{$a}");
      }
    }
  } elsif ($cmd eq 'SET') {
    &getarg;
    local($s)=$newarg;
    $s =~ tr/a-z/A-Z/;
    if ($s =~ s/^-//) {
      &tell("*** No such variable $s"), return unless defined($set{$s});
      &doset($s, "");
      &tell("*** $s is ".($set{$s} ne '' ? "set to $set{$s}" : "unset"));
    } elsif ($s ne '') {
      &tell("*** No such variable $s"), return unless defined($set{$s});
      &doset($s, $args) if $args ne '';
      &tell("*** $s is ".($set{$s} ne '' ? "set to $set{$s}" : "unset"));
    } else {
      foreach $s (sort(keys (%set))) {
	&tell("*** $s is ".($set{$s} ne '' ? "set to $set{$s}" : "unset"));
      }
    }
  } elsif ($cmd eq 'NOTIFY' || $cmd eq 'NO') {
    if ($args eq '-') {
      &tell("*** Notify list cleared");
      %notify=();
    } elsif ($args eq '') {
      local($l)='';
      foreach (grep($notify{$_}, keys %notify)) {
	&tell("*** Currently present: $l"), $l='' if length($l)>450;
	$l.=$_." ";
      }
      $l && &tell("*** Currently present: $l");
      $l='';
      foreach (grep(!$notify{$_}, keys %notify)) {
	&tell("*** Currently absent: $l"), $l='' if length($l)>450;
	$l.=$_." ";
      }
      $l && &tell("*** Currently absent: $l");
    } else {
      local($w, $n);
      foreach $w (split(/ +/, $args)) {
	if ($w =~ s/^-//) {
	  ($n)=(grep(&eq($_, $w), keys(%notify)), '');
	  $n ne '' && delete $notify{$n};
	  &tell("*** $w removed from notify list");
	} else {
	  $notify{$w}='0';
	  &tell("*** $w added to notify list");
	  $newisons=1;
	}
      }
    }
  } elsif ($cmd eq 'IGNORE' || $cmd eq 'IG') {
    &getarg;
    if ($newarg eq '-') {
      @ignore=();
      &tell("*** Ignore list cleared");
    } elsif ($newarg eq '') {
      local($p);
      &tell("*** You're ignoring:");
      foreach (@ignore) {
	$p=$_;
	$p =~ s/\\//g;
	$p =~ s/\.\*/*/g;
	&tell("*** $p");
      }
    } else {
      local($d, $p)=('');
      $d=1 if $newarg =~ s/^-//;
      if ($newarg =~ /\!.*\@/) {
      } elsif ($newarg !~ /[\@\!]/) {
	$newarg.="!*";
      } elsif ($newarg =~ /\@/) {
	$newarg="*!".$newarg;
      } else {
	$newarg.="\@*";
      }
      $p=$newarg;
      $newarg =~ s/([^\\])\./$1\\./g;
      $newarg =~ s/\*/\.\*/g;
      $newarg =~ s/([^\.\*\\\w])/\\$1/g;
      if ($d) {
	&tell("*** Removing $p from the ignore list");
	@ignore=grep(!&eq($_, $newarg), @ignore);
      } else {
	&tell("*** Ignoring $p ... what a relief!");
	push(@ignore, $newarg);
      }
    }
  } elsif ($cmd eq 'ECHO') {
    &print($args);
  } elsif ($cmd eq 'CLEAR' || $cmd eq 'CL') {
    print $cls if $ansi;
    print "`#ssfe#l\n" if $ssfe;
  } elsif ($cmd eq 'EVAL') {
    &restrict || return;
    eval ($args);
    $@ =~ s/\n$//, &tell("*\cbE\cb* eval error: $@") if $@ ne '';
  } elsif ($cmd eq 'HELP') {
    &tell("*\cbH\cb* Help not available"), return unless @help;
    $args='main' if $args =~ /^\s*$/;
    $args =~ s/ *$//;
    local($found)='';
    foreach (@help) {
      if (/^\@/) {
	last if $found;
	if (&eq($_, "\@$args")) {
	  $found=1;
	  &tell("*\cbH\cb* Help on $args") if $args ne 'main';
	}
      } else {
	&tell("*\cbH\cb* $_") if $found;
      }
    }
    &tell("*\cbH\cb* Unknown help topic; try /help") unless $found;
  } elsif ($cmd eq 'LOAD') {
    &restrict || return;
    &getarg;
    &tell("*\cbE\cb* Yeah, but what?"), return if $newarg eq '';
    &load($newarg);
  } elsif ($cmd eq 'VERSION') {
    &tell("*** \cbsirc\cb version $version (RANDOM=${BSD::arc4random::RANDOM}), written in \cbperl\cb by \cborabidoo\cb");
    $_=$add_ons;
    s/^\+//;
    s/\+/, /g;
    &tell("*** add-ons: $_") if $_;
    $connected==2 && &sl("VERSION $args");
  } elsif ($cmd eq 'CD') {
    &restrict || return;
    &getarg;
    if ($newarg ne '') {
      &tilde($newarg);
      chdir($newarg) || &tell("*\cbE\cb* Can't chdir to $newarg");
    }
    local($cwd); chop($cwd=qx/pwd/);
    &tell("*** Current directory is $cwd");
  } elsif ($cmd eq 'SYSTEM') {
    &restrict || return;
    system($args);
  } elsif ($cmd eq 'BYE' || $cmd eq 'QUIT' || $cmd eq 'EXIT' ||
		$cmd eq 'SIGNOFF') {
    $args || ($args="using \cbsirc\cb version $version$add_ons (RANDOM=${BSD::arc4random::RANDOM})");
    &sl("QUIT :$args") if $connected;
    &exit;
  } elsif ($cmd eq 'SERVER') {
    $args=$1 if $args =~ /^\s*(.*)\s*$/;
    $args=$server0 if $args eq '0';
    $args=$server1 if $args eq '1';
    if ($args eq '') {
      &tell($connected ? "*** Your current server is $server" :
			 "*** You're not connected to a server");
    } else {
      &parseserver($args);
      $server=$', $nick=$1 if $server =~ /^([^\@]+)\@/;
      $port || ($port=$port0);
      if ($connected) {
	&sl("QUIT :changing servers");
	&ssl_cleanup;
	close($S);
	delete $buffer{$S};
      }
      $connected=0;
      &bindtoserver;
    }
  } elsif ($cmd eq 'MSG' || $cmd eq 'M') {
    &dosplat;
    if ($args) {
      ($newarg, $args)=split(/ /, $args, 2);
      &msg($newarg, $args);
    } else {
      &tell("*\cbE\cb* You must specify a nick or channel!");
    }
  } elsif ($cmd eq 'QUERY') {
    if ($args) {
      $args =~ s/\s+$//;
      $query=$args;
      &tell("*** Starting conversation with $query");
      &dostatus;
    } elsif ($query) {
      &tell("*** Ending conversation with $query");
      $query='';
      &dostatus;
    } else {
      &tell("*** You aren't querying anyone :p");
    }
  } elsif ($connected<2) {
    &tell("*** You're not connected to a server");
  } elsif ($cmd eq 'AWAY') {
      &sl($args ? "AWAY :$args" : "AWAY");
  } elsif ($cmd eq 'NEXT') {
    if ($#channels>0) {
      $talkchannel=shift(@channels);
      push(@channels, $talkchannel);
      !$ssfe && &tell("*** Talking to $talkchannel now");
      &dostatus;
    }
  } elsif ($cmd eq 'SAY' || $cmd eq '') {
    &say($args);
  } elsif ($cmd eq 'NOTICE' || $cmd eq 'N') {
    &dosplat;
    if ($args) {
      ($newarg, $args)=split(/ /, $args, 2);
      &notice($newarg, $args);
    } else {
      &tell("*\cbE\cb* You must specify a nick or channel!");
    }
  } elsif ($cmd eq 'DESCRIBE' || $cmd eq 'DE') {
    &dosplat;
    if ($args) {
      ($newarg, $args)=split(/ /, $args, 2);
      &describe($newarg, $args);
    } else {
      &tell("*\cbE\cb* You must specify a nick or channel!");
    }
  } elsif ($cmd eq 'KICK' || $cmd eq 'K') {
    &dosplat;
    &getarg;
    local($c)=$talkchannel;
    if ($newarg =~ /^[\#\&\+]/) {
      $c=$newarg;
      &getarg;
    }
    if ($newarg) {
      $args || ($args=$nick);
      &sl("KICK $c $newarg :$args");
    } else {
      &tell("*\cbE\cb* You must specify a nick!");
    }
  } elsif ($cmd eq 'DISCONNECT' || $cmd eq 'DIS') {
    &ssl_cleanup;
    &tell("*** Disconnecting from $server");
    close($S);
    delete $buffer{$S};
    $connected=0;
    &dohooks("disconnect");
  } elsif ($cmd eq 'INVITE' || $cmd eq 'INV' || $cmd eq 'I') {
    local(@ns)=split(/ +/, $args);
    local($l, $c)=(pop(@ns), $talkchannel);
    if ($l =~ /^[\#\&\+]/) {
      $c=$l;
    } else {
      $l && push(@ns, $l);
    }
    foreach (@ns) {
      &sl("INVITE $_ $c");
    }
  } elsif ($cmd eq 'CTCP') {
    &dosplat;
    if ($args) {
      &getarg;
      local($towho)=$newarg;
      &getarg;
      $newarg =~ tr/a-z/A-Z/;
      $args=" ".$args if $args ne '';
      &sl("PRIVMSG $towho :\ca$newarg$args\ca");
      &dohooks("send_ctcp", $towho, $newarg.$args);
      &tell("*** Sending a CTCP $newarg$args to $towho");
    } else {
      &tell("*\cbE\cb* You must specify a nick or channel!");
    }
  } elsif ($cmd eq 'PING') {
    &dosplat;
    if ($args) {
      &getarg;
      local($t)=time;
      &sl("PRIVMSG $newarg :\caPING $t\ca");
      &dohooks("send_ctcp", $newarg, "PING $t");
      &tell("*** Sending a CTCP PING to $newarg");
    } else {
      &tell("*\cbE\cb* You must specify a nick or channel!");
    }
  } elsif ($cmd eq 'RANDEX') {
    &dosplat;
    if ($args) {
      arandom_add("send $args");
      local($t) = pack("u", BSD::arc4random::arc4random_bytes(32));
      chop($t);
      &getarg;
      &sl("PRIVMSG $newarg :\caENTROPY $t\ca");
      &tell("*** Initiating the RANDEX protocol with $newarg");
    } else {
      &tell("*\cbE\cb* You must specify a nick or channel!");
    }
  } elsif ($cmd eq 'ME' || $cmd eq 'D') {
    if ($talkchannel) {
      &describe($talkchannel, $args);
    } else {
      &tell("*\cbE\cb* Not on a channel");
    }
  } elsif ($cmd eq 'TOPIC' || $cmd eq 'T') {
    &dosplat;
    local($c)=$talkchannel;
    if ($args =~ /^[\#\&\+]/) {
      &getarg;
      $c=$newarg;
    }
    if ($args) {
      &sl("TOPIC $c :$args");
    } else {
      &sl("TOPIC $c");
    }
  } elsif ($cmd eq 'PART' || $cmd eq 'P') {
    &dosplat;
    $args=$talkchannel if $args eq '';
    &sl("PART $args");
  } elsif ($cmd eq 'LL') {
    if ($talkchannel) {
      &sl("WHO $talkchannel");
    } else {
      &tell("*\cbE\cb* Not on a channel");
    }
  } elsif ($cmd eq 'OP') {
    local($c, $n, $l)=($talkchannel, 0, '');
    &getarg, $c=$newarg if ($args =~ /^[\#\&\+]/);
    local(@ppl)=split(/ +/, $args);
    foreach (@ppl) {
      if ($n<4) {
	$l .= " ".$_;
	$n++;
      } else {
	&sl("MODE $c +oooo $l");
	$l=$_;
	$n=1;
      }
    }
    $l && &sl("MODE $c +oooo $l");
  } elsif ($cmd eq 'DEOP') {
    local($c, $n, $l)=($talkchannel, 0, '');
    &getarg, $c=$newarg if ($args =~ /^[\#\&\+]/);
    local(@ppl)=split(/ +/, $args);
    foreach (@ppl) {
      if ($n<4) {
	$l .= " ".$_;
	$n++;
      } else {
	&sl("MODE $c -oooo $l");
	$l=$_;
	$n=1;
      }
    }
    $l && &sl("MODE $c -oooo $l");
  } elsif ($cmd eq 'WI' || $cmd eq 'WHOIS') {
    &sl($args eq '' ? "WHOIS $nick" : "WHOIS $args");
  } elsif ($cmd eq 'W') {
    &getarg;
    $newarg=$nick if $newarg eq '';
    &sl("WHOIS $newarg $newarg");
  } elsif ($cmd eq 'WHO') {
    &dosplat;
    if ($args =~ /^[\s\*]*$/) {
      &tell("*** Uhm, better not");
    } else {
      &sl("WHO $args");
    }
  } elsif ($cmd eq 'JOIN' || $cmd eq 'J') {
    $args=$invited if $args eq '';
    unless ($args =~ /^[\#\&\+]/) {
      $args='#'.$args;
    }
    if (grep(&eq($_, $args), @channels)) {
      &tell("*** Talking to $args now");
      $talkchannel=$args;
      &dostatus;
    } else {
      &sl("JOIN $args");
    }
  } elsif ($cmd eq 'QUOTE' || $cmd eq 'Q') {
    $args ne '' && &sl($args);
  } elsif ($cmd eq 'UMODE') {
    &sl("MODE $nick $args");
  } elsif ($cmd eq 'NS') {
    if ($args =~ /%s/) {
      &getuserpass("NickServ Password? ", "Passwd: ");
      $args =~ s/%s/$_/g;
    }
    &sl("NS $args");
  } elsif ($cmd eq 'MO' || $cmd eq 'MODE') {
    &dosplat;
    $args=$talkchannel if $args eq '';
    if ($args) {
      &sl("MODE $args");
    } else {
      &tell("*\cbE\cb* Not on a channel");
    }
  } elsif ($cmd eq 'NA' || $cmd eq 'NAMES') {
    &dosplat;
    $args=$talkchannel if $args eq '';
    if ($args) {
      &sl("NAMES $args");
    } else {
      &tell("*\cbE\cb* Not on a channel");
    }
  } elsif ($cmd eq 'LIST') {
    &dosplat;
    $listmin=0;
    $listmax=100000;
    $listpat='';
    if ($args =~ /\*/ || $args =~ /-m[ia][nx]\s/i) {
      while (&getarg, $newarg ne '') {
	if ($newarg =~ /^-min$/i) {
	  &getarg;
	  $listmin=$newarg if $newarg>0;
	} elsif ($newarg =~ /^-max$/i) {
	  &getarg;
	  $listmax=$newarg if $newarg>0;
	} else {
	  $newarg =~ s/([^\\])\./$1\\./g;
	  $newarg =~ s/\*/\.\*/g;
	  $newarg =~ s/([^\.\*\\\w])/\\$1/g;
	  $listpat=$newarg;
	}
      }
      &sl("LIST");
    } else {
      &sl($line);
    }
  } elsif ($cmd eq 'RPING') {
    &getarg;
    &sl("RPING $newarg ".time);
  } elsif ($cmd eq 'KILL') {
    &getarg;
    if ($newarg) {
      $args || ($args=$nick);
      &sl("KILL $newarg :$args");
    } else {
      &tell("*\cbE\cb* You must specify a nick!");
    }
  } elsif ($cmd eq 'OPER') {
    &getarg;
    $newarg=$nick unless $newarg;
    &getuserpass("Oper password? ", "Passwd: "), $args=$_ unless $args;
    &sl("OPER $newarg $args");
  } elsif ($cmd eq 'CONNECT') {
    &getarg;
    local($srv)=$newarg;
    &getarg;
    if ($args) {
      &sl("CONNECT $srv $newarg $args");
    } else {
      &sl("CONNECT $srv 6667 $newarg");
    }
  } elsif ($cmd eq 'SQUIT') {
    &getarg;
    &sl("SQUIT $newarg :$args");
  } elsif ($cmd eq 'WHOWAS' || $cmd eq 'ADMIN' || $cmd eq 'STATS' ||
	   $cmd eq 'INFO' || $cmd eq 'LUSERS' || $cmd eq 'SQUIT' ||
	   $cmd eq 'REHASH' || $cmd eq 'DIE' || $cmd eq 'LINKS' ||
	   $cmd eq 'NOTE' || $cmd eq 'WALLOPS' || $cmd eq 'NICK' ||
	   $cmd eq 'MOTD' || $cmd eq 'TIME' || $cmd eq 'TRACE' ||
	   $cmd eq 'USERS' || $cmd eq 'SILENCE' || $cmd eq 'MAP' ||
	   $cmd eq 'UPING') {
    &sl($line);
  } elsif ($cmd eq 'ACCEPT') {
    if ($args eq '') {
      $args = '*';
    }
    $args =~ s/ /,/g;
    &sl("ACCEPT $args");
  } else {
    &tell("*\cbE\cb* Unknown command: $cmd");
  }
}

sub douserline {
  local($skip, $line)=(0, @_);
  if ($line =~ /^\@ssfe\@/) {
    $ssfe=$raw_mode=1;
    $add_ons.="+ssfe";
    &dostatus;
  } else {
    &dohooks("command", $line);
    return if $skip;
    if ($line =~ s/^\///) {
      &docommand($line);
    } elsif ($query ne '') {
      &msg($query, $line);
    } else {
      &say($line);
    }
  }
}

$ssfe_getline="`#ssfe#p";
sub getuserline {
  local($skip)='';
  &dohooks("input", $_[0], $_[1]);
  return if $skip;
  print $_[0];
  print "\n" if $raw_mode;
  print $ssfe_getline.$_[1]."\n" if $ssfe;
  while (($_=<STDIN>) ne '') {
    if (/^\@ssfe\@/) {
      $ssfe || ($add_ons.="+ssfe");
      $ssfe=$raw_mode=1;
      &dostatus;
    } else {
      &exit if $_ eq '';
      chop;
      return;
    }
  }
  &exit;
}

sub getuserpass {
  local($ssfe_getline)="`#ssfe#P";
  &getuserline;
}

%cmds=();
sub addcmd {
  local($cmd)=$_[0];
  $cmd =~ tr/a-z/A-Z/;
  $cmds{$cmd}="&cmd_".$_[0].";";
}

sub addhelp {
  local($cmd, $txt)=@_;
  $cmd =~ tr/A-Z/a-z/;
  push(@help, "\@".$cmd);
  foreach (split(/\n/, $txt)) {
    s/\$v/$version/g;
    s/\$d/$date/g;
    push (@help, $_);
  }
}

sub addset {
  local($var)=$_[0];
  $var =~ tr/a-z/A-Z/;
  $sets{$var}="set_".$_[0];
}

sub addsel {
  $buf_fds{$_[0]}="sel_".$_[1] if $_[2];
  $sel_fds{$_[0]}="sel_".$_[1] unless $_[2];
}

sub remsel {
  delete $buf_fds{$_[0]};
  delete $sel_fds{$_[0]};
}

@hooks=("action", "ctcp", "ctcp_reply", "input", "invite", "join", "kick",
	"leave", "mode", "msg", "nick", "notice", "server_notice",
	"notify_signoff", "notify_signon", "public", "raw_irc",
	"send_action", "send_text", "send_notice", "signoff", "topic",
	"disconnect", "status", "print", "command", "send_ctcp", "capab");

sub addhook {
  local($type, $name)=@_;
  $type =~ tr/A-Z/a-z/;
  $name="hook_".$name;
  if ($type =~ /^\d\d\d$/ || grep(($_ eq $type), @hooks)) {
    ($type =~ /^\d\d\d$/) && ($type="num_".$type);
    eval "*ugly_hack_hooks=*${type}_hooks;";
    unless (grep(($_ eq $name), @ugly_hack_hooks)) {
      push(@ugly_hack_hooks, $name);
    }
  } else {
    &tell("*\cbE\cb* $type: no such hook");
  }
}

sub remhook {
  local($type, $name)=@_;
  $type =~ tr/A-Z/a-z/;
  $name="hook_".$name;
  if ($type =~ /^\d\d\d$/ || grep(($_ eq $type), @hooks)) {
    ($type =~ /^\d\d\d$/) && ($type="num_".$type);
    eval "*ugly_hack_hooks=*${type}_hooks;";
    @ugly_hack_hooks=grep(($_ ne $name), @ugly_hack_hooks);
  } else {
    &tell("*\cbE\cb* $type: no such hook");
  }
}

sub userhost {
  push (@waituh, $_[0]);
  push (@douh, $_[1]);
  push (@erruh, $_[2]);
  &sl("USERHOST $_[0]");
}

sub deltimer {
  local($ref)=$_[0];
  local($i);
  if ($#trefs>=0 && $ref!=0) {
    # delete the timer if it exists
    for ($i=0; $i<=$#trefs; $i++) {
      if ($trefs[$i]==$ref) {
	splice(@trefs,$i,1);
	splice(@timers,$i,1);
	splice(@timeactions,$i,1);
	last;
      }
    }
  }
}

sub timer {
  local(@r, @t, @a)=();
  local($t)=$_[0]+time;
  local($ref)=$_[2] || 0;
  &deltimer($ref) if $ref;
  while ($#timers>=0 && $timers[0]<=$t) {
    push (@r, shift(@trefs));
    push (@t, shift(@timers));
    push (@a, shift(@timeactions));
  }
  @trefs=(@r, $ref, @trefs);
  @timers=(@t, $t, @timers);
  @timeactions=(@a, $_[1], @timeactions);
}

sub disappeared {
  local($n)=(grep(&eq($_, $_[0]), keys(%notify)));
  if ($n ne '' && $notify{$n}>0) {
    local($silent)=0;
    &dohooks("notify_signoff", $_[0]);
    &tell("*\cb(\cb* Signoff by $_[0] detected");
    $notify{$n}=0;
  }
}

sub appeared {
  local($t, $n)=(time, grep(&eq($_, $_[0]), keys(%notify)));
  if ($n ne '') {
    if ($notify{$n}==0) {
      local($silent)=0;
      &dohooks("notify_signon", $_[0]);
      &tell("*\cb)\cb* Signon by $_[0] detected!");
    }
    $notify{$n}=$t;
  }
}

$lastsendison=0;
sub send_isons {
  local($l)='';
  foreach (keys %notify) {
    &sl("ISON : $l"), $l='' if (length($l)>500);
    $l.=$_." ";
  }
  &sl("ISON :$l") if $l;
  $lastsendison=time;
  $newisons='';
  $checkisons=1;
}

sub signoffs {
  foreach (keys %notify) {
    if ($notify{$_}>0 && $notify{$_}<$lastsendison) {
      $notify{$_}=0;
      local($silent)=0;
      &dohooks("notify_signoff", $_);
      &tell("*\cb(\cb* Signoff by $_ detected");
    }
  }
  $checkisons='';
}

sub modestripper {
  local($chnl, $what)=@_;
  $chnl =~ tr/A-Z[]\\~/a-z{}|^/;
  local($how, $modes, @args)=('+', split(/ +/, $what));
  foreach $m (split(//, $modes)) {
    if ($m =~ /[\-\+]/) {
      $how=$m;
    } elsif ($m =~ /[vb]/) {
      shift(@args);
    } elsif ($m eq 'k') {
      $how eq '+' ? ($chankey{$chnl}=$args[0]) : delete $chankey{$chnl};
      shift(@args);
    } elsif ($m eq 'l') {
      $how eq '+' ? ($limit{$chnl}=shift(@args)) : delete $limit{$chnl};
    } elsif ($m eq 'o') {
      $haveops{$chnl}=($how eq '+') ? "@" : "" if (&eq(shift(@args), $nick));
    } elsif ($m eq 'h') {
      $haveops{$chnl}=($how eq '+') ? "%" : "" if (&eq(shift(@args), $nick));
    } else {
      $mode{$chnl} =~ s/$m//g;
      $mode{$chnl}.=$m if $how eq '+';
    }
  }
}

sub umodechange {
  local($what)=@_;
  local($how)='+';
  foreach $m (split(//, $what)) {
    if ($m =~ /[\-\+]/) {
      $how=$m;
    } else {
      $umode =~ s/$m//g;
      $umode.=$m if ($how eq '+' && $m !~ /\s/);
    }
  }
}

sub ignored {
  foreach (@ignore) {
    return 1 if $_[0] =~ /^${_}$/;
  }
  return '';
}

sub dorcfile {
  return if !open(RCFILE, "<$_[0]");
  while (<RCFILE>) {
    chop;
    s/^\///;
    next if /^\#/;
    &docommand($_) if $_;
    $silent=$skip='';
  }
  close(RCFILE);
}

sub loadrc {
  $rcloaded=1;
  $sysrc && &dorcfile($sysrc);
  $rcfile && &dorcfile($rcfile);
}

sub selline {
  $leftover=0;
  $rin=$rout="\0" x 32;
  foreach ($S, 'STDIN', keys(%buf_fds)) {
    next unless defined $buffer{$_};
    $leftover=1, return $_ if $buffer{$_} =~ /\n/;
  }
  if (($ssl_efd ne '') && (defined $buffer{$ssl_efd})) {
    $leftover=1, return $ssl_efd if $buffer{$ssl_efd} =~ /\n/;
  }
  foreach (keys(%sel_fds), keys(%buf_fds)) {
    vec($rin, fileno($_), 1)=1;
  }
  vec($rin, fileno('STDIN'), 1)=1 if $interactive;
  vec($rin, fileno($S), 1)=1 if $connected;
  vec($rin, fileno($ssl_efd), 1)=1 if ($ssl_efd ne '');
  if ($#timers<0 || $timers[0]>time+30) {
    select($rout=$rin, undef, undef, 30);
  } elsif ($timers[0]<=time) {
    select($rout=$rin, undef, undef, 0);
  } else {
    select($rout=$rin, undef, undef, $timers[0]-time);
  }
}

sub getnick {
  &getuserline("Pick a nick: ", "Nick: ");
  $nick=$_;
  &sl("NICK $_");
  &dostatus;
}

sub parse_capab {
  local $skip=0;
  &dohooks("capab", $capab_cmd, $capab_response);
  if (!$skip) {
    if ($capab_response eq '') {
      &tell("*\cbE\cb* Unknown capability $capab_cmd");
    } elsif ($capab_response ne $capab_cmd) {
      &tell("*\cbE\cb* Expected reply for capability $capab_cmd");
      &tell("*\cbE\cb* Processing capability $capab_response instead");
    }
    if ($capab_response eq 'IDENTIFY-MSG') {
      $has_identifymsg = 1;
      &tell("*** Messages by identified users will be marked specially");
    }
  }
}

sub send_capab {
  $capab_cmd = $_[0];
  &sl("CAPAB $capab_cmd");
}

sub login_cmds {
  if ($has_capab) {
    &send_capab('IDENTIFY-MSG');
  } else {
    $opportunistic_cmd = "CAP";
    &sl("CAP REQ :identify-msg");
  }
  &timer(30, '$opportunistic_cmd = "";');
}

sub parse_cap {
  local $skip=0;
  &dohooks("cap", $args);
  return if $skip;
  &yetonearg;
  &yetonearg;
  if ($newarg eq 'ACK') {
    if ($args =~ /\bidentify-msg\b/) {
      $has_identifymsg = 1;
      &tell("*** Messages by identified users will be marked specially");
    }
  }
}

sub donumeric {
  local($from)=($who eq $myserver ? '' : " (from ${who})");
  if ($cmd eq '401') {
    &yetonearg;
    &yetonearg;
    &tell("*\cb?\cb* Cannot find $newarg on irc$from");
  } elsif ($cmd eq '402') {
    &yetonearg;
    &yetonearg;
    &tell("*\cb?\cb* $newarg: no such server$from");
  } elsif ($cmd eq '403') {
    &yetonearg;
    &yetonearg;
    &tell("*\cb?\cb* $newarg: no such channel$from");
  } elsif ($cmd eq '406') {
    &yetonearg;
    &yetonearg;
    &tell("*\cb?\cb* $newarg: there was no such nickname$from");
  } elsif ($cmd eq '421') {
    &yetonearg;
    &yetonearg;
    if ($opportunistic_cmd eq $newarg) {
      $opportunistic_cmd = '';
    } else {
      &tell("*\cb?\cb* $newarg: unknown command$from");
    }
  } elsif ($cmd =~ /^4[012]/) {
    $args =~ s/^[^:]*://;
    &tell("*** $args$from");
  } elsif ($cmd eq '431') {
    &tell("*** Was expecting a nickname somewhere...");
    &getnick if $connected<2;
  } elsif ($cmd eq '432') {
    if ($connected==2) {
      &tell("*\cbN\cb* Invalid nickname, you're still \"$nick\"");
    } else {
      &tell("*\cbN\cb* Invalid nickname!");
      &getnick;
    }
  } elsif ($cmd eq '433') {
    if ($connected==2) {
      &tell("*\cbN\cb* Nick already taken, you're still \"$nick\"");
    } else {
      &tell("*\cbN\cb* Nick already taken!");
      &getnick;
    }
  } elsif ($cmd eq '441') {
    local($g, $w, $c)=split(/ +/, $args);
    &tell("*\cbE\cb* $w is not on channel $c$from");
  } elsif ($cmd eq '442') {
    local($w, $c)=split(/ +/, $args);
    &tell("*\cbE\cb* You're not on channel $c$from");
  } elsif ($cmd eq '443') {
    local($w, $o, $c)=split(/ +/, $args);
    &tell("*\cbE\cb* $o is already on channel $c$from");
  } elsif ($cmd eq '465') {
    &tell("*\cbE\cb* You are banned from this server$from");
  } elsif ($cmd eq '461') {
    &yetonearg;
    &yetonearg;
    &tell("*\cbE\cb* The command $newarg needs more arguments than that$from");
  } elsif ($cmd =~ /^47[1345]$/) {
    &yetonearg;
    &yetonearg;
    local($r);
    if ($cmd eq '471') {
      $r="channel is full";
    } elsif ($cmd eq '473') {
      $r="channel is invite-only";
    } elsif ($cmd eq '474') {
      $r="banned from channel";
    } else {
      $r="bad channel key";
    }
    &tell("*\cbE\cb* Can't join $newarg: ${r}$from");
  } elsif ($cmd eq '301') {
    &yetonearg;
    &yetonearg;
    my $skipawaytell = 0;
    my $awaytime = time;
    if (($awaytimes{$newarg}) &&
	(($awaytime - $awaytimes{$newarg}) < 300) &&
	($awaymsgs{$newarg} eq $args)) {
      $skipawaytell = 1;
    }
    $awaytimes{$newarg} = $awaytime;
    $awaymsgs{$newarg} = $args;
    &tell("*** $newarg is away: $args") unless $skipawaytell;
  } elsif ($cmd eq '302') {
    &yetonearg;
    &yetonearg;
    local($n, $do, $err)=(shift(@waituh), shift(@douh), shift(@erruh));
    if ($newarg =~ /^([^\s\*=]+)[\*]?=([\-+])/) {
      $who=$1;
      local($adr)=$';
      if ($adr =~ /\@/) {
	$user=$`;
	$host=$';
      } else {
	$user=$host='';
      }
      if (&eq($who, $n)) {
	eval $do;
	$@ =~ s/\n$//, &tell("*\cbE\cb* error in userhost: $@") if $@ ne '';
      } else {
	&tell("*\cbE\cb* userhost returned for unexpected nick $who");
      }
    } else {
      if (defined($err)) {
	eval $err;
	$@ =~ s/\n$//, &tell("*\cbE\cb* error in userhost: $@") if $@ ne '';
      } else {
	&tell("*\cb?\cb* Cannot find $n on irc");
      }
    }
  } elsif ($cmd eq '303') {
    &yetonearg;
    local($n);
    foreach $n (split(/ +/, $args)) {
      &appeared($n);
    }
  } elsif ($cmd eq '305') {
    &tell("*** You are no longer marked as away");
    $away='';
    &dostatus;
  } elsif ($cmd eq '306') {
    &tell("*** You are marked as being away");
    $away=1;
    &dostatus;
  } elsif ($cmd eq '311') {
    local($g, $n, $u, $m, $g, $r)=split(/ +/, $args, 6);
    $r =~ s/^://;
    &tell("*** $n is $u\@$m ($r)");
  } elsif ($cmd eq '312') {
    &yetonearg;
    &yetonearg;
    &yetonearg;
    local($s)=$newarg;
    &tell("*** on IRC via server $s ($args)");
  } elsif ($cmd eq '313') {
    &yetonearg;
    &yetonearg;
    &tell("*** $newarg is an IRC Operator");
  } elsif ($cmd eq '314') {
    local($g, $n, $u, $m, $g, $r)=split(/ +/, $args, 6);
    $r =~ s/^://;
    &tell("*** $n was $u\@$m ($r)");
  } elsif ($cmd eq '317') {
    &yetonearg;
    &yetonearg;
    local($n)=$newarg;
    &yetonearg;
    if ($newarg>=3600) {
      &tell("*** $n has been ".int($newarg/3600)." hours, ".
	  int(($newarg%3600)/60)." minutes and ".
	  ($newarg%60)." seconds idle");
    } elsif ($newarg>=60) {
      &tell("*** $n has been ".int($newarg/60)." minutes and ".
	    ($newarg%60)." seconds idle");
    } elsif ($newarg==1) {
      &tell("*** $n has been $newarg second idle");
    } else {
      &tell("*** $n has been $newarg seconds idle");
    }
    delete $awaytimes{$n};
    delete $awaymsgs{$n};
  } elsif ($cmd eq '319') {
    local($g, $g, $c)=split(/ +/, $args, 3);
    $c =~ s/^://;
    &tell("*** on channels: $c");
  } elsif ($cmd eq '322') {
    local($g, $c, $n, $r)=split(/ +/, $args, 4);
    $r =~ s/^://;
    $n>=$listmin && $n <=$listmax && (!$listpat || $c =~ /^${listpat}$/i)
      && &tell(sprintf("*** %-10s %-5s %s", $c, $n, $r));
  } elsif ($cmd eq '323') {
    $listmin=0;
    $listmax=100000;
    $listpat='';
  } elsif ($cmd eq '324') {
    local($g, $c, $m)=split(/ +/, $args, 3);
    $m =~ s/^://;
    $m =~ s/ $//;
    $c =~ tr/A-Z[]\\~/a-z{}|^/;
    if (grep(&eq($_, $c), @channels)) {
      if (defined($mode{$c})) {
	&tell("*\cb+\cb* Mode for channel $c is \"$m\"");
      } else {
	$mode{$c}='';
      }
      &modestripper($c, $m);
      &dostatus;
    } else {
      &tell("*\cb+\cb* Mode for channel $c is \"$m\"");
    }
  } elsif ($cmd eq '329') {
    &yetonearg;
    &yetonearg;
    local($c)=$newarg;
    &yetonearg;
    local($t)=($newarg ? ("created " . &date($newarg)) : "0 TS");
    &tell("*** $c : $t");
  } elsif ($cmd eq '331') {
    &yetonearg;
    &yetonearg;
    &tell("*\cbT\cb* No topic is set on channel $newarg");
  } elsif ($cmd eq '332') {
    &yetonearg;
    &yetonearg;
    &tell("*\cbT\cb* Topic for $newarg: $args");
  } elsif ($cmd eq '333') {
    local($g, $c, $n, $t)=split(/ +/, $args, 4);
    local($d)=&date($t);
    &tell("*\cbT\cb* Topic for $c set by $n on $d");
  } elsif ($cmd eq '318' || $cmd eq '315' || $cmd eq '369' ||
	   $cmd eq '321' || $cmd eq '366' ||
	   $cmd eq '365' || $cmd eq '368' || $cmd eq '374' ||
	   $cmd eq '219' || $cmd eq '007') {
    #nothing!
  } elsif ($cmd eq '341') {
    local($g, $n, $c)=split(/ +/, $args, 3);
    &tell("*\cbI\cb* Inviting $n to channel $c");
  } elsif ($cmd eq '352') {
    local($g, $c, $u, $m, $s, $n, $st, $g, $i)=split(/ +/, $args, 9);
    &tell(sprintf("%-10s %-9s %4s %s\@%s (%s)", $c, $n, $st, $u, $m, $i));
  } elsif ($cmd eq '353') {
    local($g, $m, $c, $r)=split(/ +/, $args, 4);
    local($n)=$nick;
    $n =~ s/(\W)/\\$1/g;
    $r =~ s/^://;
    &tell("*\cb#\cb* Users on $c: $r");
    $c =~ tr/A-Z[]\\~/a-z{}|^/;
    $haveops{$c}="@" if ($r =~ /\@${n}( |$)/i);
    &dostatus if &eq($c, $talkchannel);
  } elsif ($cmd eq '221') {
    &yetonearg;
    &tell("*\cb+\cb* Your user mode is \"$args\"");
  } elsif ($cmd eq '200') {
    local($b, $l, $v, $n, $s)=split(/ +/, $args);
    $s =~ s/^://;
    &tell("*** $l $who ($v) ==> $n $s");
  } elsif ($cmd eq '205') {
    local($b, $u, $h, $n)=split(/ +/, $args);
    $n =~ s/^://;
    &tell("*** $u [$h] ==> $n");
  } elsif ($cmd =~ /^20/) {
    local($b, $t, $n, $r)=split(/ +/, $args, 4);
    &tell("*** $t [$n] ==> $r");
  } elsif ($cmd eq '375' || $cmd eq '372' || $cmd =~ /^25/) {
    &yetonearg;
    &tell("*** $args");
  } elsif ($cmd eq '005') {
    &yetonearg;
    if ($args =~ /\bCAPAB\b/) {
      $has_capab = 1;
    }
    &tell("*** $args");
  } elsif ($cmd eq '290') {
    &yetonearg;
    $capab_response = $args;
    &parse_capab;
  } elsif ($cmd eq '376') {
    &login_cmds;
  } elsif ($cmd eq '281') {
    &yetonearg;
    &tell("*** Accept list is: $args");
  } else {
    &yetonearg;
    #$args =~ s/ :/ /;
    &tell("*** $args$from");
  }
}

# main prog

print "`#ssfe#i\n" unless (-t STDOUT);
&tell("*** Welcome to \cbsirc\cb version $version (RANDOM=${BSD::arc4random::RANDOM}); type /help for help");

&load($sysinit) if $sysinit ne '' && -f $sysinit;
&load($initfile) if !$restrict && $initfile ne '' && -f $initfile;

&bindtoserver;
while (1) {
  $silent=$skip='';
  if ($connected==2) {
    $time=time;
    &loadrc unless $rcloaded;
    &send_isons
      if $time>=$lastsendison+90 || ($newisons && $time>=$lastsendison+10);
    &signoffs if $checkisons && ($time>=$lastsendison+30);
  }
  $fh=&selline;
  foreach $rfh (keys (%buf_fds)) {
    if (vec($rout, fileno($rfh), 1) || ($leftover && $fh eq $rfh)) {
      &gl($rfh) || next;
      local($line, $h)=($_, $buf_fds{$rfh});
      delete $buf_fds{$rfh}, delete $buffer{$rfh}, close($rfh) if $_ eq '';
      eval { &$h($line); };
      $@ =~ s/\n$//, &tell("*\cbE\cb* error in buffered fd hook &$h: $@")
	if $@ ne '';
    }
  }
  foreach $rfh (keys (%sel_fds)) {
    if (vec($rout, fileno($rfh), 1)) {
      local($h)=$sel_fds{$rfh};
      eval { &$h(); };
      $@ =~ s/\n$//, &tell("*\cbE\cb* error in unbuffered fd hook &$h: $@")
	if $@ ne '';
    }
  }
  while ($#timers>=0 && $timers[0]<=time) {
    shift (@timers);
    shift (@trefs);
    eval shift (@timeactions);
    $@ =~ s/\n$//, &tell("*\cbE\cb* error in timer: $@") if $@ ne '';
  }
  if (($ssl_efd ne '') &&
   (($leftover && $fh eq $ssl_efd) || vec($rout, fileno($ssl_efd), 1))) {
    &gl($ssl_efd) || next;
    if ($_ eq '') {
      &ssl_cleanup;
      &tell("*\cbS\cb* Connection to TLS stderr lost");
      next;
    }
    chop;
    s/\x00//g;
    &tell("*\cbS\cb* TLS: $_");
  }
  if (vec($rout, fileno(STDIN), 1) || ($leftover && $fh eq 'STDIN')) {
    &gl('STDIN') || next;
    &exit if $_ eq '';
    chop;
    s/\x00//g;
    &douserline($_) if $_ ne '';
  }
  if ($connected && (($leftover && $fh eq $S) || vec($rout, fileno($S), 1))) {
    &gl($S) || next;
    if ($_ eq '') {
      &ssl_cleanup;
      &tell("*\cbE\cb* Connection to server lost");
      close($S);
      delete $buffer{$S};
      $connected=0;
      &dohooks("disconnect");
      next;
    }
    chop;
    s/\x00//g;
    $serverline=$_;
    $_=$server." ".$_ unless /^:/;
    ($who, $cmd, $args)=split(/ /, $_, 3);
    $cmd =~ tr/a-z/A-Z/;
    $who =~ s/^://;
    $args =~ s/^:// if defined $args;
    $user=$host=$puh1=$puh2='';
    if ($who =~ /^([^!@ ]+)!([^@ ]+)@([^ ]+)$/) {
      ($who, $user, $host) = ($1, $2, $3);
      $puh1="!$user\@$host" if $set{"PRINTUH"} ne 'none';
      $puh2=$puh1 if $set{"PRINTUH"} eq 'all';
    }
    $vwho = $who;
    &dohooks("raw_irc", $cmd, $args);
    next if $skip;
    if (($cmd eq 'PRIVMSG' || $cmd eq 'NOTICE') &&
     &ignored("$who!$user\@$host")) {
      $logging && print LOG "[" . sprintf("%02d:%02d:%02d", (localtime)[2],
       (localtime)[1], (localtime)[0]) . "] ignored: " . $serverline . "\n";
      next;
    }
    if ($cmd eq '001') {
      $connected=2;
      $myserver=$who;
      ($nick)=split(/ /, $args, 2);
    }
    if ($cmd =~ /^\d\d\d$/) {
      &dohooks("num_".$cmd, $args);
      next if $skip;
      &donumeric;
    } elsif ($cmd eq 'CAP') {
      &parse_cap;
    } elsif ($cmd eq 'PING') {
      &sl("PONG $args");
    } elsif ($cmd eq 'PRIVMSG') {
      &yetonearg;
      $msgchannel = $newarg;
      &strip_idmsg if $has_identifymsg;
      if ($args =~ /^\001([^\001]*)\001$/ && $set{'CTCP'} ne 'none') {
	&ctcp($newarg, $1);
      } elsif (!$printchan && &eq($newarg, $talkchannel)) {
	&dohooks("public", $newarg, $args);
	$args =~ s/\Q$nick\E/\cv$&\cv/ig if $set{"HIGHLIGHT"} eq 'on';
	&tell_i("<${who}> $args");
      } elsif ($newarg =~ /^[\#\&\+]/) {
	&dohooks("public", $newarg, $args);
	$args =~ s/\Q$nick\E/\cv$&\cv/ig if $set{"HIGHLIGHT"} eq 'on';
	&tell_i("<${who}:${newarg}> $args");
      } elsif (&eq ($newarg, $nick)) {
	print "`#ssfe#t/m $who \n" if $ssfe;
	print "`#ssfe#o[$who$puh1] $args\n" if $ssfe;
	&dohooks("msg", $args);
	$args =~ s/\Q$nick\E/\cv$&\cv/ig if $set{"HIGHLIGHT"} eq 'on';
	&tell_i("[\cb${who}\cb${puh1}] $args");
      } else {
	$args =~ s/\Q$nick\E/\cv$&\cv/ig if $set{"HIGHLIGHT"} eq 'on';
	&tell_i("[\cb${who}\cb${puh1}:${newarg}\cb] $args");
      }
    } elsif ($cmd eq 'NOTICE') {
      &yetonearg;
      &strip_idmsg if $has_identifymsg;
      if ($args =~ /^\001([^\001]*)\001$/) {
	&ctcpreply($newarg, $1);
      } elsif ($newarg =~ /^[\#\&\+]/) {
	&dohooks("notice", $newarg, $args);
	$msgchannel = $newarg;
	&tell_i("-${who}/${newarg}- $args");
      } elsif ($who =~ /\./) {
	&dohooks("server_notice", $args);
	$args="*** ".$args unless ($args =~ /^\*/);
	&tell($args);
      } elsif (&eq($newarg, $nick)) {
	&dohooks("notice", $newarg, $args);
	&tell_i("-\cb${who}\cb${puh1}- $args");
      } else {
	&dohooks("notice", $newarg, $args);
	&tell_i("-\cb$who$puh1:${newarg}\cb- $args");
      }
    } elsif ($cmd eq 'KICK') {
      &yetonearg;
      local($channel)=$newarg;
      &yetonearg;
      $args=$who unless $args;
      if (&eq($nick, $newarg)) {
	&tell("*\cb<\cb* You have been kicked off channel $channel by $who$puh2 ($args)");
	@channels=grep(!&eq($_, $channel), @channels);
	if (@channels) {
	  $talkchannel=$channels[$#channels];
	} else {
	  $talkchannel='';
	}
	$channel =~ tr/A-Z[]\\~/a-z{}|^/;
	&dohooks("kick", $newarg, $channel, $args);
	delete $mode{$channel};
	delete $limit{$channel};
	delete $haveops{$channel};
	delete $chankey{$channel};
	$talkchannel && !$ssfe && &tell("*** Talking to $talkchannel now");
	&dostatus;
      } else {
	&dohooks("kick", $newarg, $channel, $args);
	&tell("*\cb<\cb* $newarg has been kicked off channel $channel by $who$puh2 ($args)");
      }
    } elsif ($cmd eq 'PART') {
      &yetonearg;
      if (&eq($who, $nick)) {
	&tell("*\cb<\cb* You have left channel $newarg");
	@channels=grep(!&eq($_, $newarg), @channels);
	if (@channels) {
	  $talkchannel=$channels[$#channels];
	} else {
	  $talkchannel='';
	}
	$newarg =~ tr/A-Z[]\\~/a-z{}|^/;
	delete $mode{$newarg};
	delete $limit{$newarg};
	delete $haveops{$newarg};
	delete $chankey{$newarg};
	&dohooks("leave", $newarg);
	$talkchannel && !$ssfe && &tell("*** Talking to $talkchannel now");
	&dostatus;
      } else {
	&dohooks("leave", $newarg, $args);
	&tell("*\cb<\cb* $who$puh2 has left channel $newarg ($args)");
      }
    } elsif ($cmd eq 'JOIN') {
      &yetonearg;
      $newarg =~ s/\cg.*//;	# ircnet kludge
      if (&eq($nick, $who)) {
	push(@channels, $newarg);
	$talkchannel=$newarg;
	&dohooks("join", $newarg);
	&dostatus;
	&tell("*\cb>\cb* You have joined channel $newarg");
	&sl("MODE $newarg");
      } else {
	&dohooks("join", $newarg);
	&tell("*\cb>\cb* $who ($user\@$host) has joined channel $newarg");
      }
      &appeared($who);
    } elsif ($cmd eq 'NICK') {
      &yetonearg;
      if (&eq($nick, $who)) {
	$nick=$newarg;
	&dohooks("nick", $newarg);
	$who=$newarg;
	&dostatus;
	&tell("*\cbN\cb* You are now known as $newarg");
      } else {
	&dohooks("nick", $newarg);
	&tell("*\cbN\cb* $who$puh2 is now known as $newarg");
	delete $awaytimes{$who};
	delete $awaymsgs{$who};
      }
    } elsif ($cmd eq 'MODE') {
      &yetonearg;
      $args =~ s/ $//;
      if ($newarg =~ /^[\#\&\+]/) {
	&modestripper($newarg, $args);
	&dohooks("mode", $newarg, $args);
	&dostatus;
	&tell("*\cb+\cb* Mode change \"$args\" on channel $newarg by $who$puh2");
      } else {
	local($towho)=$newarg;
	&yetonearg;
	&umodechange($newarg), &dostatus if &eq($towho, $nick);
	&dohooks("mode", $towho, $newarg);
	&tell("*\cb+\cb* Mode change \"$newarg\" for user $towho by $who");
      }
    } elsif ($cmd eq 'KILL') {
      &yetonearg;
      local($n)=$newarg;
      $args || ($args=$who);
      &tell("*\cb<\cb* $n got killed by $who$puh1 ($args)");
      delete $awaytimes{$n};
      delete $awaymsgs{$n};
    } elsif ($cmd eq 'INVITE') {
      &yetonearg;
      &yetonearg;
      &dohooks("invite", $newarg);
      $invited=$newarg;
      &tell("*\cbI\cb* $who$puh1 invites you to channel $newarg");
    } elsif ($cmd eq 'TOPIC') {
      &yetonearg;
      &dohooks("topic", $newarg, $args);
      &tell("*\cbT\cb* $who$puh2 has changed the topic on channel $newarg to \"$args\"");
    } elsif ($cmd eq 'SILENCE') {
      &tell("*** Silence $args");
    } elsif ($cmd eq 'PONG') {
    } elsif ($cmd eq 'QUIT') {
      &dohooks("signoff", $args);
      &tell("*\cb<\cb* Signoff: $who$puh2 ($args)");
      &disappeared($who);
      delete $awaytimes{$who};
      delete $awaymsgs{$who};
    } elsif ($cmd eq 'WALLOPS') {
      &tell("!$who$puh2! ".$args);
    } elsif ($cmd eq 'RPONG') {
      local($n, $t, $ms, $ts)=split(/ +/, $args);
      $ts =~ s/^://;
      &tell("*** RPONG: $who - $t: $ms ms, ".time-$ts." sec");
    } else {
      &tell("*** The server says: $serverline");
    }
  }
}
