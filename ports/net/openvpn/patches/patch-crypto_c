$MirOS$

use arc4random if we can

--- crypto.c.orig	Tue Feb 21 18:18:07 2006
+++ crypto.c	Tue Feb 21 19:34:18 2006
@@ -1622,20 +1622,27 @@ void uninit_crypto_lib ()
 
 static uint8_t nonce_data [SHA_DIGEST_LENGTH + NONCE_SECRET_LEN]; /* GLOBAL */
 
+#if !HAVE_ARC4RANDOM
 void
 prng_init (void)
 {
   if (!RAND_bytes (nonce_data, sizeof(nonce_data)))
     msg (M_FATAL, "ERROR: Random number generator cannot obtain entropy for PRNG");
 }
+#endif
 
 void
 prng_bytes (uint8_t *output, int len)
 {
+#if !HAVE_ARC4RANDOM
   SHA_CTX ctx;
+#else
+  uint32_t rnd = 0;
+#endif
   mutex_lock_static (L_PRNG);
   while (len > 0)
     {
+#if !HAVE_ARC4RANDOM
       const int blen = min_int (len, SHA_DIGEST_LENGTH);
       SHA1_Init (&ctx);
       SHA1_Update (&ctx, nonce_data, sizeof (nonce_data));
@@ -1643,6 +1650,13 @@ prng_bytes (uint8_t *output, int len)
       memcpy (output, nonce_data, blen);
       output += blen;
       len -= blen;
+#else
+      if (!rnd)
+	rnd = arc4random();
+      *output++ = rnd & 0xFF;
+      rnd >>= 8;
+      --len;
+#endif
     }
   mutex_unlock_static (L_PRNG);
 }
@@ -1651,11 +1665,18 @@ prng_bytes (uint8_t *output, int len)
 long int
 get_random()
 {
+#if !HAVE_ARC4RANDOM
   long int l;
   prng_bytes ((unsigned char *)&l, sizeof(l));
   if (l < 0)
     l = -l;
   return l;
+#else
+  if (sizeof (long int) == 4)
+    return arc4random();
+  else
+    return (long int)(((uint64_t)arc4random()) << 32 | (uint64_t)arc4random());
+#endif
 }
 
 const char *
