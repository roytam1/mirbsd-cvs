--- centericq-4.21.0.orig/debian/patches/security_CAN_2005-2448.dpatch
+++ centericq-4.21.0/debian/patches/security_CAN_2005-2448.dpatch
@@ -0,0 +1,526 @@
+#! /bin/sh -e
+## Patch (backport from official release) by Julien Lemoine <speedblue@debian.org>
+##
+## DP: Fix endianess errors (may allow remote attackers to cause a denial of service), CAN-2005-2448
+## DP: Fix memory alignment errors (may allows remote attackers to cause a denial of service (bus error) on
+## DP:     certain architectures such as SPARC via an incoming message, CAN-2005-2370
+## DP: Fix Multiple integer signedness errors (may allow remote attackers to cause a denial of service 
+## DP:     or execute arbitrary code.), CAN-2005-2369
+
+[ -f debian/patches/00patch-opts ] && . debian/patches/00patch-opts
+patch_opts="${patch_opts:--f --no-backup-if-mismatch}"
+
+if [ $# -ne 1 ]; then
+    echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
+    exit 1
+fi
+case "$1" in
+       -patch) patch $patch_opts -p1 < $0;;
+       -unpatch) patch $patch_opts -p1 -R < $0;;
+        *)
+          echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
+          exit 1;;
+esac
+
+exit 0
+diff -bBdNrw -U5 centericq-4.20.0/libgadu-0.1/common.c centericq-4.20.0.modif/libgadu-0.1/common.c
+--- centericq-4.20.0/libgadu-0.1/common.c	2005-08-23 17:32:57.000000000 +0200
++++ centericq-4.20.0.modif/libgadu-0.1/common.c	2005-08-23 15:49:32.000000000 +0200
+@@ -282,10 +282,12 @@
+  */
+ char *gg_read_line(int sock, char *buf, int length)
+ {
+ 	int ret;
+ 
++	if (!buf || length < 0)
++		return NULL;
+ 	for (; length > 1; buf++, length--) {
+ 		do {
+ 			if ((ret = read(sock, buf, 1)) == -1 && errno != EINTR) {
+ 				gg_debug(GG_DEBUG_MISC, "// gg_read_line() error on read (errno=%d, %s)\n", errno, strerror(errno));
+ 				*buf = 0;
+@@ -338,11 +340,11 @@
+  */
+ char *gg_urlencode(const char *str)
+ {
+ 	char *q, *buf, hex[] = "0123456789abcdef";
+ 	const char *p;
+-	int size = 0;
++	unsigned int size = 0;
+ 
+ 	if (!str && !(str = strdup("")))
+ 		return NULL;
+ 
+ 	for (p = str; *p; p++, size++) {
+@@ -390,22 +392,22 @@
+ 	int b = -1;
+ 
+ 	va_start(ap, format);
+ 
+ 	for (j = 0; j < strlen(format); j++) {
+-		unsigned char *arg, buf[16];
++		char *arg, buf[16];
+ 
+ 		if (format[j] == 'u') {
+ 			snprintf(buf, sizeof(buf), "%d", va_arg(ap, uin_t));
+ 			arg = buf;
+ 		} else {
+-			if (!(arg = va_arg(ap, unsigned char*)))
++			if (!(arg = va_arg(ap, char*)))
+ 				arg = "";
+ 		}       
+ 
+ 		i = 0;
+-		while ((c = (int) arg[i++]) != 0) {
++		while ((c = (unsigned char) arg[i++]) != 0) {
+ 			a = (c ^ b) + (c << 8);
+ 			b = (a >> 24) | (a << 8);
+ 		}
+ 	}
+ 
+@@ -530,11 +532,11 @@
+  * zaalokowany bufor.
+  */
+ char *gg_base64_encode(const char *buf)
+ {
+ 	char *out, *res;
+-	int i = 0, j = 0, k = 0, len = strlen(buf);
++	unsigned int i = 0, j = 0, k = 0, len = strlen(buf);
+ 	
+ 	res = out = malloc((len / 3 + 1) * 4 + 2);
+ 
+ 	if (!res)
+ 		return NULL;
+@@ -588,11 +590,11 @@
+  */
+ char *gg_base64_decode(const char *buf)
+ {
+ 	char *res, *save, *foo, val;
+ 	const char *end;
+-	int index = 0;
++	unsigned int index = 0;
+ 
+ 	if (!buf)
+ 		return NULL;
+ 	
+ 	save = res = calloc(1, (strlen(buf) / 4 + 1) * 3 + 2);
+@@ -682,11 +684,11 @@
+  * gg_crc32_make_table()  // funkcja wewnêtrzna
+  */
+ static void gg_crc32_make_table()
+ {
+ 	uint32_t h = 0;
+-	int i, j;
++	unsigned int i, j;
+ 
+ 	memset(gg_crc32_table, 0, sizeof(gg_crc32_table));
+ 
+ 	for (i = 128; i; i >>= 1) {
+ 		h = (h >> 1) ^ ((h & 1) ? 0xedb88320L : 0);
+@@ -711,10 +713,12 @@
+  */
+ uint32_t gg_crc32(uint32_t crc, const unsigned char *buf, int len)
+ {
+ 	if (!gg_crc32_initialized)
+ 		gg_crc32_make_table();
++	if (!buf || len < 0)
++		return crc;
+ 
+ 	crc ^= 0xffffffffL;
+ 
+ 	while (len--)
+ 		crc = (crc >> 8) ^ gg_crc32_table[(crc ^ *buf++) & 0xff];
+diff -bBdNrw -U5 centericq-4.20.0/libgadu-0.1/dcc.c centericq-4.20.0.modif/libgadu-0.1/dcc.c
+--- centericq-4.20.0/libgadu-0.1/dcc.c	2005-08-23 17:32:57.000000000 +0200
++++ centericq-4.20.0.modif/libgadu-0.1/dcc.c	2005-08-23 15:50:08.000000000 +0200
+@@ -49,13 +49,13 @@
+  *  - prefix - prefiks zrzutu pakietu
+  *  - fd - deskryptor gniazda
+  *  - buf - bufor z danymi
+  *  - size - rozmiar danych
+  */
+-static void gg_dcc_debug_data(const char *prefix, int fd, const void *buf, int size)
++static void gg_dcc_debug_data(const char *prefix, int fd, const void *buf, unsigned int size)
+ {
+-	int i;
++	unsigned int i;
+ 	
+ 	gg_debug(GG_DEBUG_MISC, "++ gg_dcc %s (fd=%d,len=%d)", prefix, fd, size);
+ 	
+ 	for (i = 0; i < size; i++)
+ 		gg_debug(GG_DEBUG_MISC, " %.2x", ((unsigned char*) buf)[i]);
+diff -bBdNrw -U5 centericq-4.20.0/libgadu-0.1/events.c centericq-4.20.0.modif/libgadu-0.1/events.c
+--- centericq-4.20.0/libgadu-0.1/events.c	2005-08-23 17:32:58.000000000 +0200
++++ centericq-4.20.0.modif/libgadu-0.1/events.c	2005-08-23 17:34:05.000000000 +0200
+@@ -25,10 +25,11 @@
+ #include <sys/socket.h>
+ #include <netinet/in.h>
+ #include <arpa/inet.h>
+ 
+ #include "libgadu-config.h"
++#include "libgadu.h"
+ 
+ #include <errno.h>
+ #ifdef __GG_LIBGADU_HAVE_PTHREAD
+ #  include <pthread.h>
+ #endif
+@@ -151,11 +152,11 @@
+  * parsuje przychodz±cy pakiet z obrazkiem.
+  *
+  *  - e - opis zdarzenia
+  *  - 
+  */
+-static void gg_image_queue_parse(struct gg_event *e, char *p, int len, struct gg_session *sess, uin_t sender)
++static void gg_image_queue_parse(struct gg_event *e, char *p, unsigned int len, struct gg_session *sess, uin_t sender)
+ {
+ 	struct gg_msg_image_reply *i = (void*) p;
+ 	struct gg_image_queue *q, *qq;
+ 
+ 	if (!p || !sess || !e)
+@@ -283,40 +284,43 @@
+ 					goto malformed;
+ 				}
+ 
+ 				count = gg_fix32(m->count);
+ 
+-				if (p + count * sizeof(uin_t) > packet_end) {
++				if (p + count * sizeof(uin_t) > packet_end || p + count * sizeof(uin_t) < p || count > 0xffff) {
+ 					gg_debug(GG_DEBUG_MISC, "// gg_handle_recv_msg() packet out of bounds (1.5)\n");
+ 					goto malformed;
+ 				}
+ 			
+ 				if (!(e->event.msg.recipients = (void*) malloc(count * sizeof(uin_t)))) {
+ 					gg_debug(GG_DEBUG_MISC, "// gg_handle_recv_msg() not enough memory for recipients data\n");
+ 					errno = ENOMEM;
+ 					goto fail;
+ 				}
+ 			
+-				for (i = 0; i < count; i++, p += sizeof(uin_t))
+-					e->event.msg.recipients[i] = gg_fix32(*((uint32_t*) p));
++				for (i = 0; i < count; i++, p += sizeof(uint32_t)) {
++					uint32_t u;
++					memcpy(&u, p, sizeof(uint32_t));
++					e->event.msg.recipients[i] = gg_fix32(u);
++				}
+ 				
+ 				e->event.msg.recipients_count = count;
+ 				
+ 				break;
+ 			}
+ 
+ 			case 0x02:              /* richtext */
+ 			{
+-				unsigned short len;
++				uint16_t len;
+ 				char *buf;
+ 			
+ 				if (p + 3 > packet_end) {
+ 					gg_debug(GG_DEBUG_MISC, "// gg_handle_recv_msg() packet out of bounds (2)\n");
+ 					goto malformed;
+ 				}
+-
+-				len = gg_fix16(*((unsigned short*) (p + 1)));
++				memcpy(&len, p + 1, sizeof(uint16_t));
++				len = gg_fix16(len);
+ 
+ 				if (!(buf = malloc(len))) {
+ 					gg_debug(GG_DEBUG_MISC, "// gg_handle_recv_msg() not enough memory for richtext data\n");
+ 					errno = ENOMEM;
+ 					goto fail;
+@@ -359,16 +363,26 @@
+ 			}
+ 
+ 			case 0x05:              /* image_reply */
+ 			case 0x06:
+ 			{
+-				if (p + sizeof(struct gg_msg_image_reply) + 1 > packet_end) {
++				struct gg_msg_image_reply *rep = (void*)p;
++
++				if (p + sizeof(struct gg_msg_image_reply) == packet_end) {
++					e->type = GG_EVENT_IMAGE_REPLY;
++					e->event.image_reply.sender = gg_fix32(r->sender);
++					e->event.image_reply.size = 0;
++					e->event.image_reply.crc32 = gg_fix32(rep->crc32);
++					e->event.image_reply.filename = NULL;
++					e->event.image_reply.image = NULL;
++				} else if (p + sizeof(struct gg_msg_image_reply) + 1 > packet_end) {
+ 					gg_debug(GG_DEBUG_MISC, "// gg_handle_recv_msg() packet out of bounds (4)\n");
+ 					goto malformed;
+ 				}
+-
+-				gg_image_queue_parse(e, p, (int)(packet_end - p), sess, gg_fix32(r->sender));
++				rep->size = gg_fix32(rep->size);
++				rep->crc32 = gg_fix32(rep->crc32);
++				gg_image_queue_parse(e, p, (unsigned int)(packet_end - p), sess, gg_fix32(r->sender));
+ 
+ 				return 0;
+ 			}
+ 
+ 			default:
+@@ -441,22 +455,22 @@
+ 		}
+ 
+ 		case GG_NOTIFY_REPLY:
+ 		{
+ 			struct gg_notify_reply *n = (void*) p;
+-			int count, i;
++			unsigned int count, i;
+ 			char *tmp;
+ 
+ 			gg_debug(GG_DEBUG_MISC, "// gg_watch_fd_connected() received a notify reply\n");
+ 
+ 			if (h->length < sizeof(*n)) {
+ 				gg_debug(GG_DEBUG_MISC, "// gg_watch_fd_connected() incomplete packet\n");
+ 				errno = EINVAL;
+ 				goto fail;
+ 			}
+ 
+-			if (gg_fix32(n->status) == GG_STATUS_BUSY_DESCR || gg_fix32(n->status == GG_STATUS_NOT_AVAIL_DESCR) || gg_fix32(n->status) == GG_STATUS_AVAIL_DESCR) {
++			if (gg_fix32(n->status) == GG_STATUS_BUSY_DESCR || gg_fix32(n->status) == GG_STATUS_NOT_AVAIL_DESCR || gg_fix32(n->status) == GG_STATUS_AVAIL_DESCR) {
+ 				e->type = GG_EVENT_NOTIFY_DESCR;
+ 				
+ 				if (!(e->event.notify_descr.notify = (void*) malloc(sizeof(*n) * 2))) {
+ 					gg_debug(GG_DEBUG_MISC, "// gg_watch_fd_connected() not enough memory for notify data\n");
+ 					errno = ENOMEM;
+@@ -555,10 +569,12 @@
+ 				e->event.notify60[i].version = n->version;
+ 				e->event.notify60[i].image_size = n->image_size;
+ 				e->event.notify60[i].descr = NULL;
+ 				e->event.notify60[i].time = 0;
+ 
++				if (uin & 0x40000000)
++					e->event.notify60[i].version |= GG_HAS_AUDIO_MASK;
+ 				if (GG_S_D(n->status)) {
+ 					unsigned char descr_len = *((char*) n + sizeof(struct gg_notify_reply60));
+ 
+ 					if (descr_len < length) {
+ 						if (!(e->event.notify60[i].descr = malloc(descr_len + 1))) {
+@@ -626,12 +642,15 @@
+ 					buf[len] = 0;
+ 				}
+ 
+ 				e->event.status60.descr = buf;
+ 
+-				if (len > 4 && p[h->length - 5] == 0)
+-					e->event.status60.time = *((int*) (p + h->length - 4));
++				if (len > 4 && p[h->length - 5] == 0) {
++					uint32_t t;
++					memcpy(&t, p + h->length - 4, sizeof(uint32_t));
++					e->event.status60.time = gg_fix32(t);
++				}
+ 			}
+ 
+ 			break;
+ 		}
+ 
+@@ -693,11 +712,11 @@
+ 				p[0] = GG_USERLIST_PUT_REPLY;
+ 			}
+ 
+ 			if (h->length > 1) {
+ 				char *tmp;
+-				int len = (sess->userlist_reply) ? strlen(sess->userlist_reply) : 0;
++				unsigned int len = (sess->userlist_reply) ? strlen(sess->userlist_reply) : 0;
+ 				
+ 				gg_debug(GG_DEBUG_MISC, "userlist_reply=%p, len=%d\n", sess->userlist_reply, len);
+ 				
+ 				if (!(tmp = realloc(sess->userlist_reply, len + h->length))) {
+ 					gg_debug(GG_DEBUG_MISC, "// gg_watch_fd_connected() not enough memory for userlist reply\n");
+@@ -1334,11 +1353,15 @@
+ 			free(h);
+ 
+ 			free(sess->password);
+ 			sess->password = NULL;
+ 
+-			gg_debug(GG_DEBUG_MISC, "// gg_watch_fd() gg_dcc_ip = %s\n", inet_ntoa(*((struct in_addr*) &gg_dcc_ip)));
++			{
++				struct in_addr dcc_ip;
++				dcc_ip.s_addr = gg_dcc_ip;
++				gg_debug(GG_DEBUG_MISC, "// gg_watch_fd() gg_dcc_ip = %s\n", inet_ntoa(dcc_ip));
++			}
+ 			
+ 			if (gg_dcc_ip == (unsigned long) inet_addr("255.255.255.255")) {
+ 				struct sockaddr_in sin;
+ 				int sin_len = sizeof(sin);
+ 
+@@ -1361,11 +1384,11 @@
+ 			l.local_port = gg_fix16(gg_dcc_port);
+ 			l.image_size = sess->image_size;
+ 			
+ 			if (sess->external_addr && sess->external_port > 1023) {
+ 				l.external_ip = sess->external_addr;
+-				l.external_port = sess->external_port;
++				l.external_port = gg_fix16(sess->external_port);
+ 			}
+ 
+ 			gg_debug(GG_DEBUG_TRAFFIC, "// gg_watch_fd() sending GG_LOGIN60 packet\n");
+ 			ret = gg_send_packet(sess, GG_LOGIN60, &l, sizeof(l), sess->initial_descr, (sess->initial_descr) ? strlen(sess->initial_descr) : 0, NULL);
+ 
+diff -bBdNrw -U5 centericq-4.20.0/libgadu-0.1/http.c centericq-4.20.0.modif/libgadu-0.1/http.c
+--- centericq-4.20.0/libgadu-0.1/http.c	2005-08-23 17:32:57.000000000 +0200
++++ centericq-4.20.0.modif/libgadu-0.1/http.c	2005-08-23 16:19:58.000000000 +0200
+@@ -262,11 +262,11 @@
+ 
+ 		h->state = GG_STATE_SENDING_QUERY;
+ 	}
+ 
+ 	if (h->state == GG_STATE_SENDING_QUERY) {
+-		unsigned int res;
++		int res;
+ 
+ 		if ((res = write(h->fd, h->query, strlen(h->query))) < 1) {
+ 			gg_debug(GG_DEBUG_MISC, "=> http, write() failed (len=%d, res=%d, errno=%d)\n", strlen(h->query), res, errno);
+ 			gg_http_error(GG_ERROR_WRITING);
+ 		}
+@@ -291,11 +291,11 @@
+ 		return 0;
+ 	}
+ 
+ 	if (h->state == GG_STATE_READING_HEADER) {
+ 		char buf[1024], *tmp;
+-		unsigned int res;
++		int res;
+ 
+ 		if ((res = read(h->fd, buf, sizeof(buf))) == -1) {
+ 			gg_debug(GG_DEBUG_MISC, "=> http, reading header failed (errno=%d)\n", errno);
+ 			if (h->header) {
+ 				free(h->header);
+@@ -399,11 +399,11 @@
+ 		return 0;
+ 	}
+ 
+ 	if (h->state == GG_STATE_READING_DATA) {
+ 		char buf[1024];
+-		unsigned int res;
++		int res;
+ 
+ 		if ((res = read(h->fd, buf, sizeof(buf))) == -1) {
+ 			gg_debug(GG_DEBUG_MISC, "=> http, reading body failed (errno=%d)\n", errno);
+ 			if (h->body) {
+ 				free(h->body);
+diff -bBdNrw -U5 centericq-4.20.0/libgadu-0.1/libgadu.c centericq-4.20.0.modif/libgadu-0.1/libgadu.c
+--- centericq-4.20.0/libgadu-0.1/libgadu.c	2005-08-23 17:32:58.000000000 +0200
++++ centericq-4.20.0.modif/libgadu-0.1/libgadu.c	2005-08-23 17:04:56.000000000 +0200
+@@ -376,11 +376,11 @@
+  *
+  * takie same warto¶ci jak write().
+  */
+ int gg_write(struct gg_session *sess, const char *buf, int length)
+ {
+-	int res;
++	int res = 0;
+ 
+ #ifdef __GG_LIBGADU_HAVE_OPENSSL
+ 	if (sess->ssl) {
+ 		int err;
+ 
+@@ -413,11 +413,12 @@
+  */
+ void *gg_recv_packet(struct gg_session *sess)
+ {
+ 	struct gg_header h;
+ 	char *buf = NULL;
+-	int ret = 0, offset, size = 0;
++	int ret = 0;
++	unsigned int offset, size = 0;
+ 
+ 	gg_debug(GG_DEBUG_FUNCTION, "** gg_recv_packet(%p);\n", sess);
+ 	
+ 	if (!sess) {
+ 		errno = EFAULT;
+@@ -475,11 +476,11 @@
+ 		h.length = gg_fix32(h.length);
+ 	} else
+ 		memcpy(&h, sess->recv_buf, sizeof(h));
+ 	
+ 	/* jakie¶ sensowne limity na rozmiar pakietu */
+-	if (h.length < 0 || h.length > 65535) {
++	if (h.length > 65535) {
+ 		gg_debug(GG_DEBUG_MISC, "// gg_recv_packet() invalid packet length (%d)\n", h.length);
+ 		errno = ERANGE;
+ 		return NULL;
+ 	}
+ 
+@@ -501,15 +502,22 @@
+ 	}
+ 
+ 	while (size > 0) {
+ 		ret = gg_read(sess, buf + sizeof(h) + offset, size);
+ 		gg_debug(GG_DEBUG_MISC, "// gg_recv_packet() body recv(%d,%p,%d) = %d\n", sess->fd, buf + sizeof(h) + offset, size, ret);
++		if (!ret) {
++			gg_debug(GG_DEBUG_MISC, "// gg_recv_packet() failed: connection broken\n");
++			errno = ECONNRESET;
++			return NULL;
++		}
+ 		if (ret > -1 && ret <= size) {
+ 			offset += ret;
+ 			size -= ret;
+ 		} else if (ret == -1) { 
++			int errno2 = errno;
+ 			gg_debug(GG_DEBUG_MISC, "// gg_recv_packet() body recv() failed (errno=%d, %s)\n", errno, strerror(errno));
++			errno = errno2;
+ 			if (errno == EAGAIN) {
+ 				gg_debug(GG_DEBUG_MISC, "// gg_recv_packet() %d bytes received, %d left\n", offset, size);
+ 				sess->recv_buf = buf;
+ 				sess->recv_left = size;
+ 				sess->recv_done = offset;
+@@ -556,13 +564,13 @@
+  */
+ int gg_send_packet(struct gg_session *sess, int type, ...)
+ {
+ 	struct gg_header *h;
+ 	char *tmp;
+-	int tmp_length;
++	unsigned int tmp_length;
+ 	void *payload;
+-	int payload_length;
++	unsigned int payload_length;
+ 	va_list ap;
+ 	int res;
+ 
+ 	gg_debug(GG_DEBUG_FUNCTION, "** gg_send_packet(%p, 0x%.2x, ...)\n", sess, type);
+ 
+@@ -582,11 +590,13 @@
+ 	payload = va_arg(ap, void *);
+ 
+ 	while (payload) {
+ 		char *tmp2;
+ 
+-		payload_length = va_arg(ap, int);
++		if (payload_length < 0)
++			gg_debug(GG_DEBUG_MISC, "// gg_send_packet() invalid payload length (%d)\n", payload_length);
++		payload_length = va_arg(ap, unsigned int);
+ 
+ 		if (payload_length < 0)
+ 			gg_debug(GG_DEBUG_MISC, "// gg_send_packet() invalid payload length (%d)\n", payload_length);
+ 	
+ 		if (!(tmp2 = realloc(tmp, sizeof(struct gg_header) + tmp_length + payload_length))) {
+@@ -1148,11 +1158,11 @@
+ {
+ 	struct gg_msg_image_reply *r;
+ 	struct gg_send_msg s;
+ 	const char *tmp;
+ 	char buf[1910];
+-	int res;
++	int res = -1;
+ 
+ 	gg_debug(GG_DEBUG_FUNCTION, "** gg_image_reply(%p, %d, \"%s\", %p, %d);\n", sess, recipient, filename, image, size);
+ 
+ 	if (!sess || !filename || !image) {
+ 		errno = EFAULT;
+diff -bBdNrw -U5 centericq-4.20.0/libgadu-0.1/libgadu.h centericq-4.20.0.modif/libgadu-0.1/libgadu.h
+--- centericq-4.20.0/libgadu-0.1/libgadu.h	2005-08-23 17:32:58.000000000 +0200
++++ centericq-4.20.0.modif/libgadu-0.1/libgadu.h	2005-08-23 17:05:54.000000000 +0200
+@@ -349,11 +349,11 @@
+ 	uint32_t external_addr;         /* adres widziany na zewnatrz */
+ 	uint16_t external_port;         /* port widziany na zewnatrz */
+ 	int tls;                        /* czy ³±czymy po TLS? */
+ 	int image_size;                 /* maksymalny rozmiar obrazka w KiB */
+ 
+-	char dummy[7 * sizeof(int)];    /* miejsce na kolejnych 8 zmiennych,
++	char dummy[6 * sizeof(int)];    /* miejsce na kolejnych 8 zmiennych,
+ 					 * ¿eby z dodaniem parametru nie 
+ 					 * zmienia³ siê rozmiar struktury */
+ };
+ 
+ struct gg_session *gg_login(const struct gg_login_params *p);
