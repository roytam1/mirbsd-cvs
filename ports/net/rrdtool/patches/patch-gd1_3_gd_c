$MirOS$
--- gd1.3/gd.c.orig	Mon Nov 18 23:33:08 2002
+++ gd1.3/gd.c	Wed Nov 12 19:57:22 2008
@@ -8,6 +8,10 @@
 static void gdImageBrushApply(gdImagePtr im, int x, int y);
 static void gdImageTileApply(gdImagePtr im, int x, int y);
 
+int gdGetByte(int *result, FILE *in);
+int gdGetWord(int *result, FILE *in);
+void gdPutWord(int w, FILE *out);
+
 gdImagePtr gdImageCreate(int sx, int sy)
 {
 	int i;
@@ -170,19 +174,19 @@ static void gdImageBrushApply(gdImagePtr
 	int lx, ly;
 	int hy;
 	int hx;
-	int x1, y1, x2, y2;
+	int x1, ly1, x2, y2;
 	int srcx, srcy;
 	if (!im->brush) {
 		return;
 	}
 	hy = gdImageSY(im->brush)/2;
-	y1 = y - hy;
-	y2 = y1 + gdImageSY(im->brush);	
+	ly1 = y - hy;
+	y2 = ly1 + gdImageSY(im->brush);	
 	hx = gdImageSX(im->brush)/2;
 	x1 = x - hx;
 	x2 = x1 + gdImageSX(im->brush);
 	srcy = 0;
-	for (ly = y1; (ly < y2); ly++) {
+	for (ly = ly1; (ly < y2); ly++) {
 		srcx = 0;
 		for (lx = x1; (lx < x2); lx++) {
 			int p;
@@ -227,11 +231,11 @@ int gdImageGetPixel(gdImagePtr im, int x
 
 /* Bresenham as presented in Foley & Van Dam */
 
-void gdImageLine(gdImagePtr im, int x1, int y1, int x2, int y2, int color)
+void gdImageLine(gdImagePtr im, int x1, int ly1, int x2, int y2, int color)
 {
 	int dx, dy, incr1, incr2, d, x, y, xend, yend, xdirflag, ydirflag;
 	dx = abs(x2-x1);
-	dy = abs(y2-y1);
+	dy = abs(y2-ly1);
 	if (dy <= dx) {
 		d = 2*dy - dx;
 		incr1 = 2*dy;
@@ -243,12 +247,12 @@ void gdImageLine(gdImagePtr im, int x1, 
 			xend = x1;
 		} else {
 			x = x1;
-			y = y1;
+			y = ly1;
 			ydirflag = 1;
 			xend = x2;
 		}
 		gdImageSetPixel(im, x, y, color);
-		if (((y2 - y1) * ydirflag) > 0) {
+		if (((y2 - ly1) * ydirflag) > 0) {
 			while (x < xend) {
 				x++;
 				if (d <0) {
@@ -275,13 +279,13 @@ void gdImageLine(gdImagePtr im, int x1, 
 		d = 2*dx - dy;
 		incr1 = 2*dx;
 		incr2 = 2 * (dx - dy);
-		if (y1 > y2) {
+		if (ly1 > y2) {
 			y = y2;
 			x = x2;
-			yend = y1;
+			yend = ly1;
 			xdirflag = (-1);
 		} else {
-			y = y1;
+			y = ly1;
 			x = x1;
 			yend = y2;
 			xdirflag = 1;
@@ -316,13 +320,13 @@ void gdImageLine(gdImagePtr im, int x1, 
 static void dashedSet(gdImagePtr im, int x, int y, int color,
 	int *onP, int *dashStepP);
 
-void gdImageDashedLine(gdImagePtr im, int x1, int y1, int x2, int y2, int color)
+void gdImageDashedLine(gdImagePtr im, int x1, int ly1, int x2, int y2, int color)
 {
 	int dx, dy, incr1, incr2, d, x, y, xend, yend, xdirflag, ydirflag;
 	int dashStep = 0;
 	int on = 1;
 	dx = abs(x2-x1);
-	dy = abs(y2-y1);
+	dy = abs(y2-ly1);
 	if (dy <= dx) {
 		d = 2*dy - dx;
 		incr1 = 2*dy;
@@ -334,12 +338,12 @@ void gdImageDashedLine(gdImagePtr im, in
 			xend = x1;
 		} else {
 			x = x1;
-			y = y1;
+			y = ly1;
 			ydirflag = 1;
 			xend = x2;
 		}
 		dashedSet(im, x, y, color, &on, &dashStep);
-		if (((y2 - y1) * ydirflag) > 0) {
+		if (((y2 - ly1) * ydirflag) > 0) {
 			while (x < xend) {
 				x++;
 				if (d <0) {
@@ -366,13 +370,13 @@ void gdImageDashedLine(gdImagePtr im, in
 		d = 2*dx - dy;
 		incr1 = 2*dx;
 		incr2 = 2 * (dx - dy);
-		if (y1 > y2) {
+		if (ly1 > y2) {
 			y = y2;
 			x = x2;
-			yend = y1;
+			yend = ly1;
 			xdirflag = (-1);
 		} else {
-			y = y1;
+			y = ly1;
 			x = x1;
 			yend = y2;
 			xdirflag = 1;
@@ -481,7 +485,7 @@ void gdImageString(gdImagePtr im, gdFont
 {
 	int i;
 	int l;
-	l = strlen(s);
+	l = strlen((char *)s);
 	for (i=0; (i<l); i++) {
 		gdImageChar(im, f, x, y, s[i], color);
 		x += f->w;
@@ -493,7 +497,7 @@ void gdImageStringUp(gdImagePtr im, gdFo
 {
 	int i;
 	int l;
-	l = strlen(s);
+	l = strlen((char *)s);
 	for (i=0; (i<l); i++) {
 		gdImageCharUp(im, f, x, y, s[i], color);
 		y -= f->w;
@@ -1554,21 +1558,20 @@ static struct {
 } GifScreen;
 #endif
 
-static int ZeroDataBlock;
 
 
-void gdImageRectangle(gdImagePtr im, int x1, int y1, int x2, int y2, int color)
+void gdImageRectangle(gdImagePtr im, int x1, int ly1, int x2, int y2, int color)
 {
-	gdImageLine(im, x1, y1, x2, y1, color);		
+	gdImageLine(im, x1, ly1, x2, ly1, color);		
 	gdImageLine(im, x1, y2, x2, y2, color);		
-	gdImageLine(im, x1, y1, x1, y2, color);
-	gdImageLine(im, x2, y1, x2, y2, color);
+	gdImageLine(im, x1, ly1, x1, y2, color);
+	gdImageLine(im, x2, ly1, x2, y2, color);
 }
 
-void gdImageFilledRectangle(gdImagePtr im, int x1, int y1, int x2, int y2, int color)
+void gdImageFilledRectangle(gdImagePtr im, int x1, int ly1, int x2, int y2, int color)
 {
 	int x, y;
-	for (y=y1; (y<=y2); y++) {
+	for (y=ly1; (y<=y2); y++) {
 		for (x=x1; (x<=x2); x++) {
 			gdImageSetPixel(im, x, y, color);
 		}
@@ -1890,8 +1893,8 @@ gdImageCreateFromXbm(FILE *fd)
 	x = 0;
 	y = 0;
 	for (i=0; (i < bytes); i++) {
-		char h[3];
-		int b;
+		char lh[3];
+		unsigned int b;
 		/* Skip spaces, commas, CRs, 0x */
 		while(1) {
 			ch = getc(fd);
@@ -1907,14 +1910,14 @@ gdImageCreateFromXbm(FILE *fd)
 		if (ch == EOF) {
 			goto fail;
 		}
-		h[0] = ch;
+		lh[0] = ch;
 		ch = getc(fd);
 		if (ch == EOF) {
 			goto fail;
 		}
-		h[1] = ch;
-		h[2] = '\0';
-		sscanf(h, "%x", &b);		
+		lh[1] = ch;
+		lh[2] = '\0';
+		sscanf(lh, "%x", &b);		
 		for (bit = 1; (bit <= 128); (bit = bit << 1)) {
 			gdImageSetPixel(im, x++, y, (b & bit) ? 1 : 0);	
 			if (x == im->sx) {
@@ -1960,7 +1963,7 @@ void gdImageFilledPolygon(gdImagePtr im,
 {
 	int i;
 	int y;
-	int y1, y2;
+	int ly1, y2;
 	int ints;
 	if (!n) {
 		return;
@@ -1976,25 +1979,25 @@ void gdImageFilledPolygon(gdImagePtr im,
 		im->polyInts = (int *) realloc(im->polyInts,
 			sizeof(int) * im->polyAllocated);
 	}
-	y1 = p[0].y;
+	ly1 = p[0].y;
 	y2 = p[0].y;
 	for (i=1; (i < n); i++) {
-		if (p[i].y < y1) {
-			y1 = p[i].y;
+		if (p[i].y < ly1) {
+			ly1 = p[i].y;
 		}
 		if (p[i].y > y2) {
 			y2 = p[i].y;
 		}
 	}
 	/* Fix in 1.3: count a vertex only once */
-	for (y=y1; (y < y2); y++) {
+	for (y=ly1; (y < y2); y++) {
 		int interLast = 0;
 		int dirLast = 0;
 		int interFirst = 1;
 		ints = 0;
 		for (i=0; (i <= n); i++) {
 			int x1, x2;
-			int y1, y2;
+			int lly1, ly2;
 			int dir;
 			int ind1, ind2;
 			int lastInd1 = 0;
@@ -2005,31 +2008,31 @@ void gdImageFilledPolygon(gdImagePtr im,
 				ind1 = i-1;
 				ind2 = i;
 			}
-			y1 = p[ind1].y;
-			y2 = p[ind2].y;
-			if (y1 < y2) {
-				y1 = p[ind1].y;
-				y2 = p[ind2].y;
+			lly1 = p[ind1].y;
+			ly2 = p[ind2].y;
+			if (lly1 < ly2) {
+				lly1 = p[ind1].y;
+				ly2 = p[ind2].y;
 				x1 = p[ind1].x;
 				x2 = p[ind2].x;
 				dir = -1;
-			} else if (y1 > y2) {
-				y2 = p[ind1].y;
-				y1 = p[ind2].y;
+			} else if (lly1 > ly2) {
+				ly2 = p[ind1].y;
+				lly1 = p[ind2].y;
 				x2 = p[ind1].x;
 				x1 = p[ind2].x;
 				dir = 1;
 			} else {
 				/* Horizontal; just draw it */
 				gdImageLine(im, 
-					p[ind1].x, y1, 
-					p[ind2].x, y1,
+					p[ind1].x, lly1, 
+					p[ind2].x, lly1,
 					c);
 				continue;
 			}
-			if ((y >= y1) && (y <= y2)) {
+			if ((y >= lly1) && (y <= ly2)) {
 				int inter = 
-					(y-y1) * (x2-x1) / (y2-y1) + x1;
+					(y-lly1) * (x2-x1) / (ly2-lly1) + x1;
 				/* Only count intersections once
 					except at maxima and minima. Also, 
 					if two consecutive intersections are
@@ -2094,24 +2097,24 @@ void gdImageSetBrush(gdImagePtr im, gdIm
 	int i;
 	im->brush = brush;
 	for (i=0; (i < gdImageColorsTotal(brush)); i++) {
-		int index;
-		index = gdImageColorExact(im, 
+		int lindex;
+		lindex = gdImageColorExact(im, 
 			gdImageRed(brush, i),
 			gdImageGreen(brush, i),
 			gdImageBlue(brush, i));
-		if (index == (-1)) {
-			index = gdImageColorAllocate(im,
+		if (lindex == (-1)) {
+			lindex = gdImageColorAllocate(im,
 				gdImageRed(brush, i),
 				gdImageGreen(brush, i),
 				gdImageBlue(brush, i));
-			if (index == (-1)) {
-				index = gdImageColorClosest(im,
+			if (lindex == (-1)) {
+				lindex = gdImageColorClosest(im,
 					gdImageRed(brush, i),
 					gdImageGreen(brush, i),
 					gdImageBlue(brush, i));
 			}
 		}
-		im->brushColorMap[i] = index;
+		im->brushColorMap[i] = lindex;
 	}
 }
 	
@@ -2120,24 +2123,24 @@ void gdImageSetTile(gdImagePtr im, gdIma
 	int i;
 	im->tile = tile;
 	for (i=0; (i < gdImageColorsTotal(tile)); i++) {
-		int index;
-		index = gdImageColorExact(im, 
+		int lindex;
+		lindex = gdImageColorExact(im, 
 			gdImageRed(tile, i),
 			gdImageGreen(tile, i),
 			gdImageBlue(tile, i));
-		if (index == (-1)) {
-			index = gdImageColorAllocate(im,
+		if (lindex == (-1)) {
+			lindex = gdImageColorAllocate(im,
 				gdImageRed(tile, i),
 				gdImageGreen(tile, i),
 				gdImageBlue(tile, i));
-			if (index == (-1)) {
-				index = gdImageColorClosest(im,
+			if (lindex == (-1)) {
+				lindex = gdImageColorClosest(im,
 					gdImageRed(tile, i),
 					gdImageGreen(tile, i),
 					gdImageBlue(tile, i));
 			}
 		}
-		im->tileColorMap[i] = index;
+		im->tileColorMap[i] = lindex;
 	}
 }
 
