$MirOS: ports/net/djbdns/patches/patch-src_dnscache_c,v 1.2 2005/12/14 23:28:32 tg Exp $
--- src/dnscache.c.orig	Sun Feb 11 21:11:23 2001
+++ src/dnscache.c	Sat May 30 21:14:48 2009
@@ -5,6 +5,10 @@
 #include "strerr.h"
 #include "error.h"
 #include "ip4.h"
+#ifdef DJB_V6ONLY
+#include "ip6.h"
+#include <stdbool.h>
+#endif /* DJB_V6ONLY */
 #include "uint16.h"
 #include "uint64.h"
 #include "socket.h"
@@ -22,7 +26,14 @@
 #include "log.h"
 #include "okclient.h"
 #include "droproot.h"
+#include "openreadclose.h"
 
+#ifdef DJB_V6ONLY
+long interface;
+#endif /* DJB_V6ONLY */
+
+stralloc ignoreip = {0};
+
 static int packetquery(char *buf,unsigned int len,char **q,char qtype[2],char qclass[2],char id[2])
 {
   unsigned int pos;
@@ -46,8 +57,14 @@ static int packetquery(char *buf,unsigne
 }
 
 
+#ifndef DJB_V6ONLY
 static char myipoutgoing[4];
 static char myipincoming[4];
+#else
+static char myipoutgoing[16];
+static char myipincoming[16];
+bool udp53t;
+#endif /* DJB_V6ONLY */
 static char buf[1024];
 uint64 numqueries = 0;
 
@@ -60,9 +77,16 @@ static struct udpclient {
   struct taia start;
   uint64 active; /* query number, if active; otherwise 0 */
   iopause_fd *io;
+#ifndef DJB_V6ONLY
   char ip[4];
+#else
+  char ip[16];
+#endif /* DJB_V6ONLY */
   uint16 port;
   char id[2];
+#ifdef DJB_V6ONLY
+  uint32 scope_id;
+#endif /* DJB_V6ONLY */
 } u[MAXUDP];
 int uactive = 0;
 
@@ -78,7 +102,14 @@ void u_respond(int j)
   if (!u[j].active) return;
   response_id(u[j].id);
   if (response_len > 512) response_tc();
+#ifndef DJB_V6ONLY
   socket_send4(udp53,response,response_len,u[j].ip,u[j].port);
+#else
+  if (udp53t)
+    socket_send4(udp53,response,response_len,u[j].ip+12,u[j].port);
+  else
+    socket_send6(udp53,response,response_len,u[j].ip,u[j].port,u[j].scope_id);
+#endif /* DJB_V6ONLY */
   log_querydone(&u[j].active,response_len);
   u[j].active = 0; --uactive;
 }
@@ -109,7 +140,15 @@ void u_new(void)
   x = u + j;
   taia_now(&x->start);
 
+#ifndef DJB_V6ONLY
   len = socket_recv4(udp53,buf,sizeof buf,x->ip,&x->port);
+#else
+  if (udp53t) {
+    byte_copy(x->ip,12,(char *)V4mappedprefix);
+    len = socket_recv4(udp53,buf,sizeof buf,x->ip+12,&x->port);
+  } else
+    len = socket_recv6(udp53,buf,sizeof buf,x->ip,&x->port,&x->scope_id);
+#endif /* DJB_V6ONLY */
   if (len == -1) return;
   if (len >= sizeof buf) return;
   if (x->port < 1024) if (x->port != 53) return;
@@ -119,7 +158,11 @@ void u_new(void)
 
   x->active = ++numqueries; ++uactive;
   log_query(&x->active,x->ip,x->port,x->id,q,qtype);
+#ifndef DJB_V6ONLY
   switch(query_start(&x->q,q,qtype,qclass,myipoutgoing)) {
+#else
+  switch(query_start(&x->q,q,qtype,qclass,myipoutgoing,interface)) {
+#endif /* DJB_V6ONLY */
     case -1:
       u_drop(j);
       return;
@@ -138,7 +181,11 @@ struct tcpclient {
   struct taia timeout;
   uint64 active; /* query number or 1, if active; otherwise 0 */
   iopause_fd *io;
+#ifndef DJB_V6ONLY
   char ip[4]; /* send response to this address */
+#else
+  char ip[16]; /* send response to this address */
+#endif /* DJB_V6ONLY */
   uint16 port; /* send response to this port */
   char id[2];
   int tcp; /* open TCP socket, if active */
@@ -146,6 +193,9 @@ struct tcpclient {
   char *buf; /* 0, or dynamically allocated of length len */
   unsigned int len;
   unsigned int pos;
+#ifdef DJB_V6ONLY
+  uint32 scope_id;
+#endif /* DJB_V6ONLY */
 } t[MAXTCP];
 int tactive = 0;
 
@@ -254,7 +304,11 @@ void t_rw(int j)
 
   x->active = ++numqueries;
   log_query(&x->active,x->ip,x->port,x->id,q,qtype);
+#ifndef DJB_V6ONLY
   switch(query_start(&x->q,q,qtype,qclass,myipoutgoing)) {
+#else
+  switch(query_start(&x->q,q,qtype,qclass,myipoutgoing,interface)) {
+#endif /* DJB_V6ONLY */
     case -1:
       t_drop(j);
       return;
@@ -291,7 +345,14 @@ void t_new(void)
   x = t + j;
   taia_now(&x->start);
 
+#ifndef DJB_V6ONLY
   x->tcp = socket_accept4(tcp53,x->ip,&x->port);
+#else
+  if (udp53t)
+    x->tcp = socket_accept4(tcp53,x->ip+12,&x->port);
+  else
+    x->tcp = socket_accept6(tcp53,x->ip,&x->port,&x->scope_id);
+#endif /* DJB_V6ONLY */
   if (x->tcp == -1) return;
   if (x->port < 1024) if (x->port != 53) { close(x->tcp); return; }
   if (!okclient(x->ip)) { close(x->tcp); return; }
@@ -389,24 +450,63 @@ char seed[128];
 int main()
 {
   char *x;
+  unsigned int i, j, k;
   unsigned long cachesize;
+  static stralloc sa = {0};
 
+#ifdef DJB_V6ONLY
+  x = env_get("INTERFACE");
+  if (x) scan_ulong(x,&interface);
+#endif /* DJB_V6ONLY */
+
   x = env_get("IP");
   if (!x)
     strerr_die2x(111,FATAL,"$IP not set");
+#ifndef DJB_V6ONLY
   if (!ip4_scan(x,myipincoming))
+#else
+  if (!ip6_scan(x,myipincoming))
+#endif /* DJB_V6ONLY */
     strerr_die3x(111,FATAL,"unable to parse IP address ",x);
 
+#ifndef DJB_V6ONLY
   udp53 = socket_udp();
+#else
+#if 0
+  /* if if IP is a mapped-IPv4 address, disable IPv6 functionality */
+  /* this is actually a bad idea */
+  if (ip6_isv4mapped(myipincoming))
+    noipv6 = 1;
+#endif
+
+  udp53t = ip6_isv4mapped(myipincoming);
+  udp53 = udp53t ? socket_udp() : socket_udp6();
+#endif /* DJB_V6ONLY */
   if (udp53 == -1)
     strerr_die2sys(111,FATAL,"unable to create UDP socket: ");
+#ifndef DJB_V6ONLY
   if (socket_bind4_reuse(udp53,myipincoming,53) == -1)
+#else
+  if ((udp53t ?
+   socket_bind4_reuse(udp53,myipincoming+12,53) :
+   socket_bind6_reuse(udp53,myipincoming,53,interface)) == -1)
+#endif /* DJB_V6ONLY */
     strerr_die2sys(111,FATAL,"unable to bind UDP socket: ");
 
+#ifndef DJB_V6ONLY
   tcp53 = socket_tcp();
+#else
+  tcp53 = udp53t ? socket_tcp() : socket_tcp6();
+#endif /* DJB_V6ONLY */
   if (tcp53 == -1)
     strerr_die2sys(111,FATAL,"unable to create TCP socket: ");
+#ifndef DJB_V6ONLY
   if (socket_bind4_reuse(tcp53,myipincoming,53) == -1)
+#else
+  if ((udp53t ?
+   socket_bind4_reuse(tcp53,myipincoming+12,53) :
+   socket_bind6_reuse(tcp53,myipincoming,53,interface)) == -1)
+#endif /* DJB_V6ONLY */
     strerr_die2sys(111,FATAL,"unable to bind TCP socket: ");
 
   droproot(FATAL);
@@ -421,7 +521,11 @@ int main()
   x = env_get("IPSEND");
   if (!x)
     strerr_die2x(111,FATAL,"$IPSEND not set");
+#ifndef DJB_V6ONLY
   if (!ip4_scan(x,myipoutgoing))
+#else
+  if (!ip6_scan(x,myipoutgoing))
+#endif /* DJB_V6ONLY */
     strerr_die3x(111,FATAL,"unable to parse IP address ",x);
 
   x = env_get("CACHESIZE");
@@ -430,6 +534,32 @@ int main()
   scan_ulong(x,&cachesize);
   if (!cache_init(cachesize))
     strerr_die3x(111,FATAL,"not enough memory for cache of size ",x);
+
+  if (openreadclose("ignoreip",&sa,64) < 0) 
+    strerr_die2x(111,FATAL,"trouble reading ignoreip");
+  for(j = k = i = 0; i < sa.len; i++)
+    if (sa.s[i] == '\n')  {
+      sa.s[i] = '\0';
+#ifdef DJB_V6ONLY
+      if (!stralloc_readyplus(&ignoreip,16))
+#else
+      if (!stralloc_readyplus(&ignoreip,4))
+#endif /* DJB_V6ONLY */
+	strerr_die2x(111,FATAL,"out of memory parsing ignoreip");
+#ifdef DJB_V6ONLY
+      if (!ip6_scan(sa.s+k,ignoreip.s+j))
+#else
+      if (!ip4_scan(sa.s+k,ignoreip.s+j))
+#endif /* DJB_V6ONLY */
+        strerr_die3x(111,FATAL,"unable to parse address in ignoreip ",ignoreip.s+k);
+#ifdef DJB_V6ONLY
+      j += 16;
+#else
+      j += 4;
+#endif /* DJB_V6ONLY */
+      k = i + 1;
+    }
+  ignoreip.len = j;
 
   if (env_get("HIDETTL"))
     response_hidettl();
