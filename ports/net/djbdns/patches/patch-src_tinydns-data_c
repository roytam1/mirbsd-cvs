$MirOS: ports/net/djbdns/patches/patch-src_tinydns-data_c,v 1.4 2006/01/17 22:40:39 tg Exp $
--- src/tinydns-data.c.orig	Sun Feb 11 21:11:23 2001
+++ src/tinydns-data.c	Sat Mar 26 17:03:10 2016
@@ -8,6 +8,7 @@
 #include "byte.h"
 #include "fmt.h"
 #include "ip4.h"
+#include "ip6.h"
 #include "exit.h"
 #include "case.h"
 #include "scan.h"
@@ -25,29 +26,56 @@
 
 #define FATAL "tinydns-data: fatal: "
 
+void die_semantic2(const char * s1, const char * s2)
+{
+  strerr_die3x(111,FATAL,s1,s2);
+}
+void die_semantic4(const char * s1, const char * s2,const char * s3, const char * s4)
+{
+  strerr_die5x(111,FATAL,s1,s2,s3,s4);
+}
 void die_datatmp(void)
 {
-  strerr_die2sys(111,FATAL,"unable to create data.tmp: ");
+  strerr_die2sys(111,FATAL,"unable to create data.cdb.tmp: ");
 }
 void nomem(void)
 {
   strerr_die1sys(111,FATAL);
 }
 
+void ttlparse(stralloc *sa,unsigned long * ttl, unsigned long defttl, const char * ltype)
+{
+    int ttllen;
+
+    if (sa->len > 0) {
+	if (!stralloc_0(sa)) nomem();
+	ttllen = scan_ulong(sa->s,ttl);
+	if (ttllen + 1 != sa->len)
+	    die_semantic4("unparseable TTL in ",ltype," line: ", sa->s);
+    } else
+	*ttl = defttl;
+}
+
 void ttdparse(stralloc *sa,char ttd[8])
 {
   unsigned int i;
   char ch;
 
   byte_zero(ttd,8);
-  for (i = 0;(i < 16) && (i < sa->len);++i) {
+  for (i = 0;i < sa->len;++i) {
+    if (i >= 16) {
+      if (!stralloc_0(sa)) nomem();
+      die_semantic2("timestamp is too long: ", sa->s);
+    }
     ch = sa->s[i];
     if ((ch >= '0') && (ch <= '9'))
       ch -= '0';
     else if ((ch >= 'a') && (ch <= 'f'))
       ch -= 'a' - 10;
-    else
-      ch = 0;
+    else {
+      if (!stralloc_0(sa)) nomem();
+      die_semantic2("timestamp contains an invalid character: ", sa->s);
+    }
     if (!(i & 1)) ch <<= 4;
     ttd[i >> 1] |= ch;
   }
@@ -55,6 +83,10 @@ void ttdparse(stralloc *sa,char ttd[8])
 
 void locparse(stralloc *sa,char loc[2])
 {
+  if (sa->len > 2) {
+    if (!stralloc_0(sa)) nomem();
+    die_semantic2("location code longer than two characters: ", sa->s);
+  }
   loc[0] = (sa->len > 0) ? sa->s[0] : 0;
   loc[1] = (sa->len > 1) ? sa->s[1] : 0;
 }
@@ -65,16 +97,23 @@ void ipprefix_cat(stralloc *out,char *s)
   char ch;
   unsigned int j;
 
-  for (;;)
-    if (*s == '.')
-      ++s;
-    else {
-      j = scan_ulong(s,&u);
-      if (!j) return;
-      s += j;
-      ch = u;
-      if (!stralloc_catb(out,&ch,1)) nomem();
-    }
+  if (*s=='s') {
+    ++s;
+    if (!stralloc_catb(out,"s",1) || !stralloc_cats(out,s)) nomem();
+  } else {
+    if (*s=='f') ++s;
+    if (!stralloc_catb(out,"f",1)) nomem();
+    for (;;)
+      if (*s == '.')
+	++s;
+      else {
+	j = scan_ulong(s,&u);
+	if (!j) return;
+	s += j;
+	ch = u;
+	if (!stralloc_catb(out,&ch,1)) nomem();
+      }
+  }
 }
 
 void txtparse(stralloc *sa)
@@ -172,6 +211,7 @@ static stralloc f[NUMFIELDS];
 static char *d1;
 static char *d2;
 char dptr[DNS_NAME4_DOMAIN];
+char d6ptr[DNS_NAME6_DOMAIN];
 
 char strnum[FMT_ULONG];
 
@@ -187,15 +227,18 @@ int main()
   int i;
   int j;
   int k;
+  int iplen;
   char ch;
   unsigned long ttl;
   char ttd[8];
   char loc[2];
-  unsigned long u;
+  uint32 u;
   char ip[4];
+  char ip6[16];
   char type[2];
   char soa[20];
   char buf[4];
+  char srv[6];
 
   umask(022);
 
@@ -206,7 +249,7 @@ int main()
 
   buffer_init(&b,buffer_unixread,fddata,bspace,sizeof bspace);
 
-  fdcdb = open_trunc("data.tmp");
+  fdcdb = open_trunc("data.cdb.tmp");
   if (fdcdb == -1) die_datatmp();
   if (cdb_make_start(&cdb,fdcdb) == -1) die_datatmp();
 
@@ -251,23 +294,22 @@ int main()
 	if (!dns_domain_fromdot(&d1,f[0].s,f[0].len)) nomem();
 
 	if (!stralloc_0(&f[3])) nomem();
-	if (!scan_ulong(f[3].s,&u)) uint32_unpack_big(defaultsoa,&u);
+	if (!scan_uint32(f[3].s,&u)) uint32_unpack_big(defaultsoa,&u);
 	uint32_pack_big(soa,u);
 	if (!stralloc_0(&f[4])) nomem();
-	if (!scan_ulong(f[4].s,&u)) uint32_unpack_big(defaultsoa + 4,&u);
+	if (!scan_uint32(f[4].s,&u)) uint32_unpack_big(defaultsoa + 4,&u);
 	uint32_pack_big(soa + 4,u);
 	if (!stralloc_0(&f[5])) nomem();
-	if (!scan_ulong(f[5].s,&u)) uint32_unpack_big(defaultsoa + 8,&u);
+	if (!scan_uint32(f[5].s,&u)) uint32_unpack_big(defaultsoa + 8,&u);
 	uint32_pack_big(soa + 8,u);
 	if (!stralloc_0(&f[6])) nomem();
-	if (!scan_ulong(f[6].s,&u)) uint32_unpack_big(defaultsoa + 12,&u);
+	if (!scan_uint32(f[6].s,&u)) uint32_unpack_big(defaultsoa + 12,&u);
 	uint32_pack_big(soa + 12,u);
 	if (!stralloc_0(&f[7])) nomem();
-	if (!scan_ulong(f[7].s,&u)) uint32_unpack_big(defaultsoa + 16,&u);
+	if (!scan_uint32(f[7].s,&u)) uint32_unpack_big(defaultsoa + 16,&u);
 	uint32_pack_big(soa + 16,u);
 
-	if (!stralloc_0(&f[8])) nomem();
-	if (!scan_ulong(f[8].s,&ttl)) ttl = TTL_NEGATIVE;
+	ttlparse(&f[8],&ttl,TTL_NEGATIVE,"Z");
 	ttdparse(&f[9],ttd);
 	locparse(&f[10],loc);
 
@@ -282,8 +324,7 @@ int main()
 
       case '.': case '&':
 	if (!dns_domain_fromdot(&d1,f[0].s,f[0].len)) nomem();
-	if (!stralloc_0(&f[3])) nomem();
-	if (!scan_ulong(f[3].s,&ttl)) ttl = TTL_NS;
+	ttlparse(&f[3],&ttl,TTL_NS,". or &");
 	ttdparse(&f[4],ttd);
 	locparse(&f[5],loc);
 
@@ -308,24 +349,26 @@ int main()
 	rr_addname(d2);
 	rr_finish(d1);
 
-	if (ip4_scan(f[1].s,ip)) {
+	iplen = ip4_scan(f[1].s,ip);
+	if (iplen != 0 && iplen + 1 == f[1].len) {
 	  rr_start(DNS_T_A,ttl,ttd,loc);
 	  rr_add(ip,4);
 	  rr_finish(d2);
-	}
+	} else if (f[1].len > 1)
+	  die_semantic4("unparseable IP address in ","& or ."," line: ", f[1].s);
 
 	break;
 
       case '+': case '=':
 	if (!dns_domain_fromdot(&d1,f[0].s,f[0].len)) nomem();
-	if (!stralloc_0(&f[2])) nomem();
-	if (!scan_ulong(f[2].s,&ttl)) ttl = TTL_POSITIVE;
+	ttlparse(&f[2],&ttl,TTL_POSITIVE,"+ or =");
 	ttdparse(&f[3],ttd);
 	locparse(&f[4],loc);
 
 	if (!stralloc_0(&f[1])) nomem();
 
-	if (ip4_scan(f[1].s,ip)) {
+	iplen = ip4_scan(f[1].s,ip);
+	if (iplen != 0 && iplen + 1 == f[1].len) {
 	  rr_start(DNS_T_A,ttl,ttd,loc);
 	  rr_add(ip,4);
 	  rr_finish(d1);
@@ -336,13 +379,40 @@ int main()
 	    rr_addname(d1);
 	    rr_finish(dptr);
 	  }
-	}
+	} else if (f[1].len > 1)
+	  die_semantic4("unparseable IP address in ","+ or ="," line: ", f[1].s);
+	else
+	  die_semantic4("missing IP address in ","+ or ="," line: ", f[1].s);
 	break;
 
+      case '6': case '3':
+	if (!dns_domain_fromdot(&d1,f[0].s,f[0].len)) nomem();
+	ttlparse(&f[2],&ttl,TTL_POSITIVE,"6 or 3");
+	ttdparse(&f[3],ttd);
+	locparse(&f[4],loc);
+
+	if (!stralloc_0(&f[1])) nomem();
+	iplen = ip6_scan_flat(f[1].s,ip6);
+	if (iplen != 0 && iplen + 1 == f[1].len) {
+	  rr_start(DNS_T_AAAA,ttl,ttd,loc);
+	  rr_add(ip6,16);
+	  rr_finish(d1);
+
+	  if (line.s[0] == '6') {	/* emit .ip6.arpa */
+	    dns_name6_domain(d6ptr,ip6);
+	    rr_start(DNS_T_PTR,ttl,ttd,loc);
+	    rr_addname(d1);
+	    rr_finish(d6ptr);
+	  }
+	} else if (f[1].len > 1)
+	  die_semantic4("unparseable IP address in ","6 or 3"," line: ", f[1].s);
+	else
+	  die_semantic4("missing IP address in ","6 or 3"," line: ", f[1].s);
+	break;
+
       case '@':
 	if (!dns_domain_fromdot(&d1,f[0].s,f[0].len)) nomem();
-	if (!stralloc_0(&f[4])) nomem();
-	if (!scan_ulong(f[4].s,&ttl)) ttl = TTL_POSITIVE;
+	ttlparse(&f[4],&ttl,TTL_POSITIVE,"@");
 	ttdparse(&f[5],ttd);
 	locparse(&f[6],loc);
 
@@ -355,7 +425,7 @@ int main()
 	if (!dns_domain_fromdot(&d2,f[2].s,f[2].len)) nomem();
 
 	if (!stralloc_0(&f[3])) nomem();
-	if (!scan_ulong(f[3].s,&u)) u = 0;
+	if (!scan_uint32(f[3].s,&u)) u = 0;
 
 	rr_start(DNS_T_MX,ttl,ttd,loc);
 	uint16_pack_big(buf,u);
@@ -363,18 +433,58 @@ int main()
 	rr_addname(d2);
 	rr_finish(d1);
 
-	if (ip4_scan(f[1].s,ip)) {
+	iplen = ip4_scan(f[1].s,ip);
+	if (iplen != 0 && iplen + 1 == f[1].len) {
 	  rr_start(DNS_T_A,ttl,ttd,loc);
 	  rr_add(ip,4);
 	  rr_finish(d2);
+	} else if (f[1].len > 1)
+	  die_semantic4("unparseable IP address in ","@"," line: ", f[1].s);
+	break;
+	
+      case 'S':
+	if (!dns_domain_fromdot(&d1,f[0].s,f[0].len)) nomem();
+	if (!stralloc_0(&f[6])) nomem();
+	if (!scan_ulong(f[6].s,&ttl)) ttl = TTL_POSITIVE;
+	ttdparse(&f[7],ttd);
+	locparse(&f[8],loc);
+
+	if (!stralloc_0(&f[1])) nomem();
+
+	if (byte_chr(f[2].s,f[2].len,'.') >= f[2].len) {
+	  if (!stralloc_cats(&f[2],".srv.")) nomem();
+	  if (!stralloc_catb(&f[2],f[0].s,f[0].len)) nomem();
 	}
+	if (!dns_domain_fromdot(&d2,f[2].s,f[2].len)) nomem();
+
+	if (!stralloc_0(&f[4])) nomem();
+	if (!scan_uint32(f[4].s,&u)) u = 0;
+	uint16_pack_big(srv,u);
+	if (!stralloc_0(&f[5])) nomem();
+	if (!scan_uint32(f[5].s,&u)) u = 0;
+	uint16_pack_big(srv + 2,u);
+	if (!stralloc_0(&f[3])) nomem();
+	if (!scan_uint32(f[3].s,&u)) nomem();
+	uint16_pack_big(srv + 4,u);
+
+	rr_start(DNS_T_SRV,ttl,ttd,loc);
+	rr_add(srv,6);
+	rr_addname(d2);
+	rr_finish(d1);
+
+	iplen = ip4_scan(f[1].s,ip);
+	if (iplen != 0 && iplen + 1 == f[1].len) {
+	  rr_start(DNS_T_A,ttl,ttd,loc);
+	  rr_add(ip,4);
+	  rr_finish(d2);
+	} else if (f[1].len > 1)
+	  die_semantic4("unparseable IP address in ","S"," line: ", f[1].s);
 	break;
 
       case '^': case 'C':
 	if (!dns_domain_fromdot(&d1,f[0].s,f[0].len)) nomem();
 	if (!dns_domain_fromdot(&d2,f[1].s,f[1].len)) nomem();
-	if (!stralloc_0(&f[2])) nomem();
-	if (!scan_ulong(f[2].s,&ttl)) ttl = TTL_POSITIVE;
+	ttlparse(&f[2],&ttl,TTL_POSITIVE,"^ or C");
 	ttdparse(&f[3],ttd);
 	locparse(&f[4],loc);
 
@@ -388,8 +498,7 @@ int main()
 
       case '\'':
 	if (!dns_domain_fromdot(&d1,f[0].s,f[0].len)) nomem();
-	if (!stralloc_0(&f[2])) nomem();
-	if (!scan_ulong(f[2].s,&ttl)) ttl = TTL_POSITIVE;
+	ttlparse(&f[2],&ttl,TTL_POSITIVE,"\'");
 	ttdparse(&f[3],ttd);
 	locparse(&f[4],loc);
 
@@ -411,13 +520,12 @@ int main()
 
       case ':':
 	if (!dns_domain_fromdot(&d1,f[0].s,f[0].len)) nomem();
-	if (!stralloc_0(&f[3])) nomem();
-	if (!scan_ulong(f[3].s,&ttl)) ttl = TTL_POSITIVE;
+	ttlparse(&f[3],&ttl,TTL_POSITIVE,":");
 	ttdparse(&f[4],ttd);
 	locparse(&f[5],loc);
 
 	if (!stralloc_0(&f[1])) nomem();
-	scan_ulong(f[1].s,&u);
+	scan_uint32(f[1].s,&u);
 	uint16_pack_big(type,u);
 	if (byte_equal(type,2,DNS_T_AXFR))
 	  syntaxerror(": type AXFR prohibited");
@@ -449,8 +557,8 @@ int main()
   if (cdb_make_finish(&cdb) == -1) die_datatmp();
   if (fsync(fdcdb) == -1) die_datatmp();
   if (close(fdcdb) == -1) die_datatmp(); /* NFS stupidity */
-  if (rename("data.tmp","data.cdb") == -1)
-    strerr_die2sys(111,FATAL,"unable to move data.tmp to data.cdb: ");
+  if (rename("data.cdb.tmp","data.cdb") == -1)
+    strerr_die2sys(111,FATAL,"unable to move data.cdb.tmp to data.cdb: ");
 
   _exit(0);
 }
