$MirOS: ports/net/djbdns/patches/patch-src_server_c,v 1.2 2005/12/14 23:28:39 tg Exp $
--- src/server.c.orig	Sun Feb 11 21:11:23 2001
+++ src/server.c	Thu Jun 15 01:16:06 2006
@@ -4,6 +4,9 @@
 #include "buffer.h"
 #include "strerr.h"
 #include "ip4.h"
+#ifdef DJB_V6ONLY
+#include "ip6.h"
+#endif /* DJB_V6ONLY */
 #include "uint16.h"
 #include "ndelay.h"
 #include "socket.h"
@@ -11,13 +14,23 @@
 #include "qlog.h"
 #include "response.h"
 #include "dns.h"
+#ifdef DJB_V6ONLY
+#include "alloc.h"
+#include "iopause.h"
+#include "str.h"
+#include <stdbool.h>
+#endif /* DJB_V6ONLY */
 
 extern char *fatal;
 extern char *starting;
 extern int respond(char *,char *,char *);
 extern void initialize(void);
 
+#ifndef DJB_V6ONLY
 static char ip[4];
+#else
+static char ip[16];
+#endif /* DJB_V6ONLY */
 static uint16 port;
 
 static char buf[513];
@@ -25,6 +38,13 @@ static int len;
 
 static char *q;
 
+#ifdef DJB_V6ONLY
+void nomem()
+{
+  strerr_die2x(111,fatal,"out of memory");
+}
+
+#endif /* DJB_V6ONLY */
 static int doit(void)
 {
   unsigned int pos;
@@ -82,11 +102,20 @@ static int doit(void)
 int main()
 {
   char *x;
+#ifndef DJB_V6ONLY
   int udp53;
+#else
+  int *udp53;
+  bool *udp53t;
+  unsigned int off;
+  unsigned int cnt;
+  iopause_fd *iop;
+#endif /* DJB_V6ONLY */
 
   x = env_get("IP");
   if (!x)
     strerr_die2x(111,fatal,"$IP not set");
+#ifndef DJB_V6ONLY
   if (!ip4_scan(x,ip))
     strerr_die3x(111,fatal,"unable to parse IP address ",x);
 
@@ -96,21 +125,102 @@ int main()
   if (socket_bind4_reuse(udp53,ip,53) == -1)
     strerr_die2sys(111,fatal,"unable to bind UDP socket: ");
 
+  ndelay_off(udp53);
+  socket_tryreservein(udp53,65536);
+
+#else
+  off=cnt=0;
+  while (x[off]) {
+    unsigned int l;
+    char dummy[16];
+    l=ip6_scan(x+off,dummy);
+    if (!l)
+      strerr_die3x(111,fatal,"unable to parse IP address ",x+off);
+    cnt++;
+    if (!x[off+l]) break;
+    if (x[off+l]=='%')
+      while (x[off+l] && x[off+l]!=',') ++l;
+    if (x[off+l]!=',')
+      strerr_die3x(111,fatal,"unable to parse IP address ",x+off);
+    off+=l+1;
+  }
+  udp53=(int *) alloc(sizeof(int) *cnt);
+  if (!udp53) nomem();
+  udp53t=(bool *) alloc(sizeof(bool) *cnt);
+  if (!udp53t) nomem();
+  iop=(iopause_fd *) alloc(sizeof(*iop) * cnt);
+  if (!iop) nomem();
+
+  off=cnt=0;
+  while (x[off]) {
+    unsigned int l;
+    uint32 ifid=0;
+    l=ip6_scan(x+off,ip);
+    udp53t[cnt] = ip6_isv4mapped(ip);
+    udp53[cnt] = ip6_isv4mapped(ip) ? socket_udp() : socket_udp6();
+    if (udp53[cnt] == -1)
+      strerr_die2sys(111,fatal,"unable to create UDP socket: ");
+    if (x[off+l]=='%') {
+      char* interface=x+off+l+1;
+      int Len=str_chr(interface,',');
+      if (interface[Len]) {
+	interface[Len]=0;
+	ifid=socket_getifidx(interface);
+	interface[Len]=',';
+      } else
+	ifid=socket_getifidx(interface);
+      l+=Len;
+    }
+    if ((udp53t[cnt] ? socket_bind4_reuse(udp53[cnt],ip+12,53) :
+     socket_bind6_reuse(udp53[cnt],ip,53,ifid)) == -1)
+      strerr_die2sys(111,fatal,"unable to bind UDP socket: ");
+    ndelay_off(udp53[cnt]);
+    socket_tryreservein(udp53[cnt],65536);
+    iop[cnt].fd=udp53[cnt];
+    iop[cnt].events=IOPAUSE_READ;
+    cnt++;
+    if (!x[off+l]) break;
+    off+=l+1;
+  }
+#endif /* DJB_V6ONLY */
   droproot(fatal);
 
   initialize();
   
-  ndelay_off(udp53);
-  socket_tryreservein(udp53,65536);
-
   buffer_putsflush(buffer_2,starting);
 
   for (;;) {
+#ifndef DJB_V6ONLY
     len = socket_recv4(udp53,buf,sizeof buf,ip,&port);
     if (len < 0) continue;
     if (!doit()) continue;
     if (response_len > 512) response_tc();
     socket_send4(udp53,response,response_len,ip,port);
     /* may block for buffer space; if it fails, too bad */
+#else
+    struct taia stamp;
+    struct taia deadline;
+    unsigned int i;
+    uint32 ifid;
+    taia_now(&stamp);
+    taia_uint(&deadline,300);
+    taia_add(&deadline,&deadline,&stamp);
+    iopause(iop,cnt,&deadline,&stamp);
+    for (i=0;i<cnt;i++)
+      if (iop[i].revents) {
+	if (udp53t[i]) {
+	  byte_copy(ip,12,(char *)V4mappedprefix);
+	  len = socket_recv4(udp53[i],buf,sizeof buf,ip+12,&port);
+	} else len = socket_recv6(udp53[i],buf,sizeof buf,ip,&port,&ifid);
+	if (len < 0) continue;
+	if (!doit()) continue;
+	if (response_len > 512) response_tc();
+	if (udp53t[i])
+	  socket_send4(udp53[i],response,response_len,ip+12,port);
+	else
+	  socket_send6(udp53[i],response,response_len,ip,port,ifid);
+	/* may block for buffer space; if it fails, too bad */
+      }
+#endif /* DJB_V6ONLY */
   }
 }
