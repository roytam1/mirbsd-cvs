$MirOS$
--- src/parseinfo.c.orig	Tue Sep  6 04:40:15 2005
+++ src/parseinfo.c	Wed Sep 15 19:36:15 2010
@@ -15,6 +15,8 @@
 #include "getline.h"
 #include "history.h"
 
+__RCSID("$MirOS: ports/devel/cvs/patches/patch-src_parseinfo_c,v 1.2 2007/03/10 23:53:50 tg Exp $");
+
 /*
  * Parse the INFOFILE file for the specified REPOSITORY.  Invoke CALLPROC for
  * the first line in the file that matches the REPOSITORY, or if ALL != 0, any
@@ -230,7 +232,7 @@ readSizeT (const char *infopath, const c
 	return true;
     }
 
-    /* Record the factor character (kilo, mega, giga, tera).  */
+    /* Record the factor character (kibi, mebi, gibi, tebi).  */
     if (!isdigit (p[strlen(p) - 1]))
     {
 	switch (p[strlen(p) - 1])
@@ -241,7 +243,7 @@ readSizeT (const char *infopath, const c
 		factor = xtimes (factor, 1024);
 	    case 'M':
 		factor = xtimes (factor, 1024);
-	    case 'k':
+	    case 'K':
 		factor = xtimes (factor, 1024);
 		break;
 	    default:
@@ -250,7 +252,7 @@ readSizeT (const char *infopath, const c
 		       infopath, option, p[strlen(p)]);
 		return false;
 	}
-	TRACE (TRACE_DATA, "readSizeT(): Found factor %u for %s",
+	TRACE (TRACE_DATA, "readSizeT(): Found factor %zu for %s",
 	       factor, option);
     }
 
@@ -274,9 +276,9 @@ readSizeT (const char *infopath, const c
 	/* Don't return an error, just max out.  */
 	num = SIZE_MAX;
 
-    TRACE (TRACE_DATA, "readSizeT(): read number %u for %s", num, option);
+    TRACE (TRACE_DATA, "readSizeT(): read number %zu for %s", num, option);
     *val = xtimes (strtoul (p, NULL, 10), factor);
-    TRACE (TRACE_DATA, "readSizeT(): returnning %u for %s", *val, option);
+    TRACE (TRACE_DATA, "readSizeT(): returnning %zu for %s", *val, option);
     return true;
 }
 
@@ -298,7 +300,7 @@ new_config (void)
     new->MaxCompressionLevel = 9;
 #endif /* SERVER_SUPPORT */
 #ifdef PROXY_SUPPORT
-    new->MaxProxyBufferSize = (size_t)(8 * 1024 * 1024); /* 8 megabytes,
+    new->MaxProxyBufferSize = (size_t)(8 * 1024 * 1024); /* 8 mebibytes,
                                                           * by default.
                                                           */
 #endif /* PROXY_SUPPORT */
@@ -392,6 +394,9 @@ parse_config (const char *cvsroot, const
      */
     bool processing = true;
     bool processed = true;
+#ifdef SERVER_SUPPORT
+    size_t dummy_sizet;
+#endif
 
     TRACE (TRACE_FUNCTION, "parse_config (%s)", cvsroot);
 
@@ -689,13 +694,29 @@ parse_config (const char *cvsroot, const
 	    readBool (infopath, "UseArchiveCommentLeader", p,
 		      &retval->UseArchiveCommentLeader);
 #ifdef SERVER_SUPPORT
-	else if (!strcmp (line, "MinCompressionLevel"))
-	    readSizeT (infopath, "MinCompressionLevel", p,
-		       &retval->MinCompressionLevel);
-	else if (!strcmp (line, "MaxCompressionLevel"))
-	    readSizeT (infopath, "MaxCompressionLevel", p,
-		       &retval->MaxCompressionLevel);
+	else if (!strcmp (line, "MinCompressionLevel")) {
+	    readSizeT (infopath, "MinCompressionLevel", p, &dummy_sizet);
+	    retval->MinCompressionLevel = dummy_sizet;
+	}
+	else if (!strcmp (line, "MaxCompressionLevel")) {
+	    readSizeT (infopath, "MaxCompressionLevel", p, &dummy_sizet);
+	    retval->MaxCompressionLevel = dummy_sizet;
+	}
 #endif /* SERVER_SUPPORT */
+#if !defined(LOCK_COMPATIBILITY) || !defined(SUPPORT_OLD_INFO_FMT_STRINGS)
+	else if ((!strcmp (line, "tag")) || (!strcmp (line, "umask"))
+	  || (!strcmp (line, "DisableXProg")) || (!strcmp (line, "dlimit"))
+	  || (!strcmp (line, "forceReadOnlyFS"))) {
+	    /* We are dealing with keywords removed between cvs 1.11.1p1
+	       and cvs 1.12.10; odds are we are not being able to handle
+	       access or concurrent access with 1.11 cvs correctly */
+	    error (0, 0, "%s: found keyword '%s' in repository",
+		   infopath, line);
+	    error (readonlyfs ? 0 : 1, 0, readonlyfs
+		? "Danger: Granting read access to incompatible repository!"
+		: "Do not try to access a cvs 1.11 repository!");
+	}
+#endif
 	else
 	    /* We may be dealing with a keyword which was added in a
 	       subsequent version of CVS.  In that case it is a good idea
