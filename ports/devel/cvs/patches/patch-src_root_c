$MirOS: ports/devel/cvs/patches/patch-src_root_c,v 1.3 2010/09/15 20:57:02 tg Exp $
--- src/root.c.orig	Sun Sep 25 00:38:07 2005
+++ src/root.c	Sat Jun 11 03:06:20 2011
@@ -18,6 +18,8 @@
 #include <assert.h>
 #include "getline.h"
 
+__RCSID("$MirOS: ports/devel/cvs/patches/patch-src_root_c,v 1.3 2010/09/15 20:57:02 tg Exp $");
+
 /* Printable names for things in the current_parsed_root->method enum variable.
    Watch out if the enum is changed in cvs.h! */
 
@@ -293,6 +295,12 @@ root_allow_free (void)
     dellist (&root_allow);
 }
 
+int
+root_allow_used (void)
+{
+    return (root_allow != NULL);
+}
+
 bool
 root_allow_ok (const char *arg)
 {
@@ -535,6 +543,12 @@ parse_cvsroot (const char *root_in)
 	    method = "";
 #endif /* defined (CLIENT_SUPPORT) || defined (SERVER_SUPPORT) */
 
+    if (NULL == method)
+	{
+	    error (0, 0, "Missing method in CVSROOT.");
+	    goto error_exit;
+	}
+
 	/* Now we have an access method -- see if it's valid. */
 
 	if (!strcasecmp (method, "local"))
@@ -547,6 +561,16 @@ parse_cvsroot (const char *root_in)
 	    newroot->method = gserver_method;
 	else if (!strcasecmp (method, "server"))
 	    newroot->method = server_method;
+	else if (strncmp (method, "ext=", 4) == 0)
+	{
+	    newroot->cvs_rsh = xstrdup(method + 4);
+	    newroot->method = ext_method;
+	}
+	else if (!strcasecmp (method, "extssh"))
+	{
+	    newroot->cvs_rsh = xstrdup("ssh");
+	    newroot->method = extssh_method;
+	}
 	else if (!strcasecmp (method, "ext"))
 	    newroot->method = ext_method;
 	else if (!strcasecmp (method, "fork"))
@@ -597,13 +621,15 @@ parse_cvsroot (const char *root_in)
 	    else if (!strcasecmp (p, "CVS_RSH"))
 	    {
 		/* override CVS_RSH environment variable */
-		if (newroot->method == ext_method)
-		    newroot->cvs_rsh = xstrdup (q);
+		if (newroot->method == ext_method
+		    || newroot->method == extssh_method)
+		newroot->cvs_rsh = xstrdup (q);
 	    }
 	    else if (!strcasecmp (p, "CVS_SERVER"))
 	    {
 		/* override CVS_SERVER environment variable */
 		if (newroot->method == ext_method
+		    || newroot->method == extssh_method
 		    || newroot->method == fork_method)
 		    newroot->cvs_server = xstrdup (q);
 	    }
@@ -635,7 +661,8 @@ parse_cvsroot (const char *root_in)
     newroot->isremote = (newroot->method != local_method);
 
 #if defined (CLIENT_SUPPORT) || defined (SERVER_SUPPORT)
-    if (readonlyfs && newroot->isremote)
+    if (readonlyfs && newroot->isremote && (newroot->method != ext_method)
+	&& (newroot->method != extssh_method))
 	error (1, 0,
 "Read-only repository feature unavailable with remote roots (cvsroot = %s)",
 	       cvsroot_copy);
@@ -828,6 +855,7 @@ parse_cvsroot (const char *root_in)
     case server_method:
     case ext_method:
 	no_port = 1;
+    case extssh_method:
 	/* no_password already set */
 	check_hostname = 1;
 	break;
@@ -871,8 +899,8 @@ parse_cvsroot (const char *root_in)
     if (no_port && newroot->port)
     {
         error (0, 0,
-"CVSROOT port specification is only valid for gserver, kserver,");
-        error (0, 0, "and pserver connection methods.");
+"CVSROOT port specification is only valid for extssh,");
+        error (0, 0, "gserver, kserver and pserver connection methods.");
         goto error_exit;
     }
 #endif /* defined(CLIENT_SUPPORT) || defined (SERVER_SUPPORT) */
