$MirOS$
--- src/main.c.orig	Sun Oct  2 15:16:59 2005
+++ src/main.c	Mon Oct  2 04:40:37 2006
@@ -676,6 +676,7 @@ main (int argc, char **argv)
 		(void) fputs ("\
 Copyright (C) 2005 Free Software Foundation, Inc.\n\
 \n\
+Portions contributed by Thorsten Glaser for the MirOS Project.\n\
 Senior active maintainers include Larry Jones, Derek R. Price,\n\
 and Mark D. Baushke.  Please see the AUTHORS and README files from the CVS\n\
 distribution kit for a complete list of contributors and copyrights.\n",
@@ -764,57 +765,12 @@ distribution kit for a complete list of 
     if (argc < 1)
 	usage (usg);
 
-    if (readonlyfs && !really_quiet) {
-	error (0, 0,
-	       "WARNING: Read-only repository access mode selected via `cvs -R'.\n\
-Using this option to access a repository which some users write to may\n\
-cause intermittent sandbox corruption.");
-    }
-
     /* Calculate the cvs global session ID */
 
-    {
-	char buf[COMMITID_RAW_SIZE] = { 0, };
-	char out[COMMITID_RAW_SIZE * 2];
-	ssize_t len = 0;
-	time_t rightnow = time (NULL);
-	char *startrand = buf + sizeof (time_t);
-	unsigned char *p = (unsigned char *) startrand;
-	size_t randbytes = RANDOM_BYTES;
-	int flags = O_RDONLY;
-	int fd;
-#ifdef O_NOCTTY
-	flags |= O_NOCTTY;
-#endif
-	if (rightnow != (time_t)-1)
-		while (rightnow > 0) {
-		    *--p = rightnow % (UCHAR_MAX + 1);
-		    rightnow /= UCHAR_MAX + 1;
-		}
-	else {
-	    /* try to use more random data */
-	    randbytes = COMMITID_RAW_SIZE;
-	    startrand = buf;
-	}
-	fd = open ("/dev/urandom", flags);
-	if (fd >= 0) {
-	    len = read (fd, startrand, randbytes);
-	    close (fd);
-	}
-	if (len <= 0) {
-	    /* no random data was available so use pid */
-	    long int pid = (long int)getpid ();
-	    p = (unsigned char *) (startrand + sizeof (pid));
-	    while (pid > 0) {
-		*--p = pid % (UCHAR_MAX + 1);
-		pid /= UCHAR_MAX + 1;
-	    }
-	}
-	convert(buf, out);
-	global_session_id = strdup (out);
-    }
+    global_session_id = Xasprintf ("1%010llX%04X%04X", (uint64_t)time (NULL),
+				   (int)getpid() & 0xFFFF,
+				   (int)arc4random() & 0xFFFF);
 
-
     TRACE (TRACE_FUNCTION, "main: Session ID is %s", global_session_id);
 
     /* Look up the command name. */
@@ -1285,7 +1241,7 @@ date_from_time_t (time_t unixtime)
 	ftm = localtime (&unixtime);
 
     (void) sprintf (date, DATEFORM,
-		    ftm->tm_year + (ftm->tm_year < 100 ? 0 : 1900),
+		    (int)ftm->tm_year + (ftm->tm_year < 100 ? 0 : 1900),
 		    ftm->tm_mon + 1, ftm->tm_mday, ftm->tm_hour,
 		    ftm->tm_min, ftm->tm_sec);
     ret = xstrdup (date);
@@ -1315,8 +1271,9 @@ date_to_internet (char *dest, const char
 void
 date_to_tm (struct tm *dest, const char *source)
 {
+    int y;
     if (sscanf (source, SDATEFORM,
-		&dest->tm_year, &dest->tm_mon, &dest->tm_mday,
+		&y, &dest->tm_mon, &dest->tm_mday,
 		&dest->tm_hour, &dest->tm_min, &dest->tm_sec)
 	    != 6)
 	/* Is there a better way to handle errors here?  I made this
@@ -1324,9 +1281,7 @@ date_to_tm (struct tm *dest, const char 
 	   deal with fatal errors.  */
 	error (0, 0, "internal error: bad date %s", source);
 
-    if (dest->tm_year > 100)
-	dest->tm_year -= 1900;
-
+    dest->tm_year = y - ((y > 100) ? 1900 : 0);
     dest->tm_mon -= 1;
 }
 
@@ -1351,7 +1306,7 @@ tm_to_internet (char *dest, const struct
     sprintf (dest, "%d %s %d %02d:%02d:%02d -0000", source->tm_mday,
 	     source->tm_mon < 0 || source->tm_mon > 11
                ? "???" : month_names[source->tm_mon],
-	     source->tm_year + 1900, source->tm_hour, source->tm_min,
+	     (int)source->tm_year + 1900, source->tm_hour, source->tm_min,
              source->tm_sec);
 }
 
