$MirOS$
--- src/rcs.c.orig	Wed Sep 28 15:25:37 2005
+++ src/rcs.c	Wed Sep 15 19:51:42 2010
@@ -33,6 +33,8 @@
 # endif
 #endif
 
+__RCSID("$MirOS: ports/devel/cvs/patches/patch-src_rcs_c,v 1.5 2009/09/06 11:51:01 tg Exp $");
+
 /* The RCS -k options, and a set of enums that must match the array.
    These come first so that we can use enum kflag in function
    prototypes.  */
@@ -103,6 +105,7 @@ static char *RCS_addbranch (RCSNode *, c
 static char *truncate_revnum_in_place (char *);
 static char *truncate_revnum (const char *);
 static char *printable_date (const char *);
+static char *mdoc_date (const char *);
 static char *escape_keyword_value (const char *, int *);
 static void expand_keywords (RCSNode *, RCSVers *, const char *,
                              const char *, size_t, enum kflag, char *,
@@ -2166,6 +2169,8 @@ RCS_getversion (RCSNode *rcs, const char
 
 	if (! RCS_nodeisbranch (rcs, tag))
 	{
+	    if (! strcmp (date, "BASE"))
+		return RCS_gettag (rcs, tag, force_tag_match, simple_tag);
 	    /* We can't get a particular date if the tag is not a
                branch.  */
 	    return NULL;
@@ -2177,6 +2182,15 @@ RCS_getversion (RCSNode *rcs, const char
 	else
 	    branch = xstrdup (tag);
 
+	if (! strcmp (date, "BASE"))
+	{
+	    /* Cut off the branch suffix and return.  */
+	    rev = strrchr (branch, '.');
+	    if (rev)
+		*rev = '\0';
+	    return branch;
+	}
+
 	/* Fetch the revision of branch as of date.  */
 	rev = RCS_getdatebranch (rcs, date, branch);
 	free (branch);
@@ -3120,6 +3134,7 @@ RCS_getrevtime (RCSNode *rcs, const char
     struct timespec revdate;
     Node *p;
     RCSVers *vers;
+    int y;
 
     /* make sure we have something to look at... */
     assert (rcs != NULL);
@@ -3134,7 +3149,7 @@ RCS_getrevtime (RCSNode *rcs, const char
     vers = p->data;
 
     /* split up the date */
-    if (sscanf (vers->date, SDATEFORM, &xtm.tm_year, &xtm.tm_mon,
+    if (sscanf (vers->date, SDATEFORM, &y, &xtm.tm_mon,
 		&xtm.tm_mday, &xtm.tm_hour, &xtm.tm_min, &xtm.tm_sec) != 6)
 	error (1, 0, "%s: invalid date for revision %s (%s)", rcs->print_path,
 	       rev, vers->date);
@@ -3144,15 +3159,14 @@ RCS_getrevtime (RCSNode *rcs, const char
        2000+, RCS files contain all four digits and we subtract 1900,
        because the tm_year field should contain years since 1900.  */
 
-    if (xtm.tm_year >= 100 && xtm.tm_year < 2000)
+    if (y >= 100 && y < 2000)
 	error (0, 0, "%s: non-standard date format for revision %s (%s)",
 	       rcs->print_path, rev, vers->date);
-    if (xtm.tm_year >= 1900)
-	xtm.tm_year -= 1900;
+    xtm.tm_year = y - ((y >= 1900) ? 1900 : 0);
 
     /* put the date in a form getdate can grok */
-    tdate = Xasprintf ("%d-%d-%d %d:%d:%d -0000",
-		       xtm.tm_year + 1900, xtm.tm_mon, xtm.tm_mday,
+    tdate = Xasprintf ("%ld-%d-%d %d:%d:%d -0000",
+		       (long)xtm.tm_year + 1900, xtm.tm_mon, xtm.tm_mday,
 		       xtm.tm_hour, xtm.tm_min, xtm.tm_sec);
 
     /* Turn it into seconds since the epoch.
@@ -3173,7 +3187,7 @@ RCS_getrevtime (RCSNode *rcs, const char
 	/* Put an appropriate string into `date', if we were given one. */
 	ftm = gmtime (&revdate.tv_sec);
 	(void) sprintf (date, DATEFORM,
-			ftm->tm_year + (ftm->tm_year < 100 ? 0 : 1900),
+			(long)ftm->tm_year + (ftm->tm_year < 100 ? 0L : 1900L),
 			ftm->tm_mon + 1, ftm->tm_mday, ftm->tm_hour,
 			ftm->tm_min, ftm->tm_sec);
     }
@@ -3475,6 +3489,7 @@ enum keyword
     KEYWORD_REVISION,
     KEYWORD_SOURCE,
     KEYWORD_STATE,
+    KEYWORD_MDOCDATE,
     KEYWORD_LOCALID
 };
 struct rcs_keyword
@@ -3511,6 +3526,7 @@ new_keywords (void)
     KEYWORD_INIT (new, KEYWORD_REVISION, "Revision");
     KEYWORD_INIT (new, KEYWORD_SOURCE, "Source");
     KEYWORD_INIT (new, KEYWORD_STATE, "State");
+    KEYWORD_INIT (new, KEYWORD_MDOCDATE, "Mdocdate");
 
     return new;
 }
@@ -3544,6 +3560,30 @@ printable_date (const char *rcs_date)
 
 
 
+/* Convert an RCS date string into an mdoc string.  This is like
+   the RCS date2str function, but for manual pages.  */
+static char *
+mdoc_date (const char *rcs_date)
+{
+    int year, mon, mday, hour, min, sec;
+    char buf[100];
+    const char *months[] = { "January", "February", "March", "April",
+	"May", "June", "July", "August",
+	"September", "October", "November", "December",
+	"corrupt" };
+
+    (void) sscanf (rcs_date, SDATEFORM, &year, &mon, &mday, &hour, &min,
+		   &sec);
+    if (mon < 1 || mon > 12)
+	mon = 13;
+    if (year < 1900)
+	year += 1900;
+    sprintf (buf, "%s %d %04d", months[mon - 1], mday, year);
+    return xstrdup (buf);
+}
+
+
+
 /* Escape the characters in a string so that it can be included in an
    RCS value.  */
 static char *
@@ -3680,13 +3720,13 @@ expand_keywords (RCSNode *rcs, RCSVers *
 	srch_len -= (srch_next + 1) - srch;
 	srch = srch_next + 1;
 
-	/* Look for the first non alphabetic character after the '$'.  */
+	/* Look for the first non alphanumeric character after the '$'.  */
 	send = srch + srch_len;
 	for (s = srch; s < send; s++)
-	    if (! isalpha ((unsigned char) *s))
+	    if (! isalnum ((unsigned char) *s))
 		break;
 
-	/* If the first non alphabetic character is not '$' or ':',
+	/* If the first non alphanumeric character is not '$' or ':',
            then this is not an RCS keyword.  */
 	if (s == send || (*s != '$' && *s != ':'))
 	    continue;
@@ -3741,6 +3781,11 @@ expand_keywords (RCSNode *rcs, RCSVers *
 		free_value = 1;
 		break;
 
+	    case KEYWORD_MDOCDATE:
+		value = mdoc_date (ver->date);
+		free_value = 1;
+		break;
+
 	    case KEYWORD_CVSHEADER:
 	    case KEYWORD_HEADER:
 	    case KEYWORD_ID:
@@ -5081,7 +5126,7 @@ RCS_checkin (RCSNode *rcs, const char *u
 	(void) time (&modtime);
     ftm = gmtime (&modtime);
     delta->date = Xasprintf (DATEFORM,
-			     ftm->tm_year + (ftm->tm_year < 100 ? 0 : 1900),
+			     (long)ftm->tm_year + (ftm->tm_year < 100 ? 0L : 1900L),
 			     ftm->tm_mon + 1, ftm->tm_mday, ftm->tm_hour,
 			     ftm->tm_min, ftm->tm_sec);
     if (flags & RCS_FLAGS_DEAD)
