$MirOS: ports/devel/cvs/patches/patch-src_rcs_c,v 1.7 2010/09/18 23:14:07 tg Exp $
--- src/rcs.c.orig	Wed Sep 28 15:25:37 2005
+++ src/rcs.c	Sun Sep 19 00:03:32 2010
@@ -33,6 +33,8 @@
 # endif
 #endif
 
+__RCSID("$MirOS: ports/devel/cvs/patches/patch-src_rcs_c,v 1.7 2010/09/18 23:14:07 tg Exp $");
+
 /* The RCS -k options, and a set of enums that must match the array.
    These come first so that we can use enum kflag in function
    prototypes.  */
@@ -103,6 +105,7 @@ static char *RCS_addbranch (RCSNode *, c
 static char *truncate_revnum_in_place (char *);
 static char *truncate_revnum (const char *);
 static char *printable_date (const char *);
+static char *mdoc_date (const char *);
 static char *escape_keyword_value (const char *, int *);
 static void expand_keywords (RCSNode *, RCSVers *, const char *,
                              const char *, size_t, enum kflag, char *,
@@ -2166,6 +2169,8 @@ RCS_getversion (RCSNode *rcs, const char
 
 	if (! RCS_nodeisbranch (rcs, tag))
 	{
+	    if (! strcmp (date, "BASE"))
+		return RCS_gettag (rcs, tag, force_tag_match, simple_tag);
 	    /* We can't get a particular date if the tag is not a
                branch.  */
 	    return NULL;
@@ -2177,6 +2182,15 @@ RCS_getversion (RCSNode *rcs, const char
 	else
 	    branch = xstrdup (tag);
 
+	if (! strcmp (date, "BASE"))
+	{
+	    /* Cut off the branch suffix and return.  */
+	    rev = strrchr (branch, '.');
+	    if (rev)
+		*rev = '\0';
+	    return branch;
+	}
+
 	/* Fetch the revision of branch as of date.  */
 	rev = RCS_getdatebranch (rcs, date, branch);
 	free (branch);
@@ -3120,6 +3134,7 @@ RCS_getrevtime (RCSNode *rcs, const char
     struct timespec revdate;
     Node *p;
     RCSVers *vers;
+    int y;
 
     /* make sure we have something to look at... */
     assert (rcs != NULL);
@@ -3134,7 +3149,7 @@ RCS_getrevtime (RCSNode *rcs, const char
     vers = p->data;
 
     /* split up the date */
-    if (sscanf (vers->date, SDATEFORM, &xtm.tm_year, &xtm.tm_mon,
+    if (sscanf (vers->date, SDATEFORM, &y, &xtm.tm_mon,
 		&xtm.tm_mday, &xtm.tm_hour, &xtm.tm_min, &xtm.tm_sec) != 6)
 	error (1, 0, "%s: invalid date for revision %s (%s)", rcs->print_path,
 	       rev, vers->date);
@@ -3144,15 +3159,14 @@ RCS_getrevtime (RCSNode *rcs, const char
        2000+, RCS files contain all four digits and we subtract 1900,
        because the tm_year field should contain years since 1900.  */
 
-    if (xtm.tm_year >= 100 && xtm.tm_year < 2000)
+    if (y >= 100 && y < 2000)
 	error (0, 0, "%s: non-standard date format for revision %s (%s)",
 	       rcs->print_path, rev, vers->date);
-    if (xtm.tm_year >= 1900)
-	xtm.tm_year -= 1900;
+    xtm.tm_year = y - ((y >= 1900) ? 1900 : 0);
 
     /* put the date in a form getdate can grok */
-    tdate = Xasprintf ("%d-%d-%d %d:%d:%d -0000",
-		       xtm.tm_year + 1900, xtm.tm_mon, xtm.tm_mday,
+    tdate = Xasprintf ("%ld-%d-%d %d:%d:%d -0000",
+		       (long)xtm.tm_year + 1900, xtm.tm_mon, xtm.tm_mday,
 		       xtm.tm_hour, xtm.tm_min, xtm.tm_sec);
 
     /* Turn it into seconds since the epoch.
@@ -3173,7 +3187,7 @@ RCS_getrevtime (RCSNode *rcs, const char
 	/* Put an appropriate string into `date', if we were given one. */
 	ftm = gmtime (&revdate.tv_sec);
 	(void) sprintf (date, DATEFORM,
-			ftm->tm_year + (ftm->tm_year < 100 ? 0 : 1900),
+			(long)ftm->tm_year + (ftm->tm_year < 100 ? 0L : 1900L),
 			ftm->tm_mon + 1, ftm->tm_mday, ftm->tm_hour,
 			ftm->tm_min, ftm->tm_sec);
     }
@@ -3475,6 +3489,7 @@ enum keyword
     KEYWORD_REVISION,
     KEYWORD_SOURCE,
     KEYWORD_STATE,
+    KEYWORD_MDOCDATE,
     KEYWORD_LOCALID
 };
 struct rcs_keyword
@@ -3511,6 +3526,7 @@ new_keywords (void)
     KEYWORD_INIT (new, KEYWORD_REVISION, "Revision");
     KEYWORD_INIT (new, KEYWORD_SOURCE, "Source");
     KEYWORD_INIT (new, KEYWORD_STATE, "State");
+    KEYWORD_INIT (new, KEYWORD_MDOCDATE, "Mdocdate");
 
     return new;
 }
@@ -3544,6 +3560,30 @@ printable_date (const char *rcs_date)
 
 
 
+/* Convert an RCS date string into an mdoc string.  This is like
+   the RCS date2str function, but for manual pages.  */
+static char *
+mdoc_date (const char *rcs_date)
+{
+    int year, mon, mday, hour, min, sec;
+    char buf[100];
+    const char *months[] = { "January", "February", "March", "April",
+	"May", "June", "July", "August",
+	"September", "October", "November", "December",
+	"corrupt" };
+
+    (void) sscanf (rcs_date, SDATEFORM, &year, &mon, &mday, &hour, &min,
+		   &sec);
+    if (mon < 1 || mon > 12)
+	mon = 13;
+    if (year < 1900)
+	year += 1900;
+    sprintf (buf, "%s %d %04d", months[mon - 1], mday, year);
+    return xstrdup (buf);
+}
+
+
+
 /* Escape the characters in a string so that it can be included in an
    RCS value.  */
 static char *
@@ -3680,13 +3720,13 @@ expand_keywords (RCSNode *rcs, RCSVers *
 	srch_len -= (srch_next + 1) - srch;
 	srch = srch_next + 1;
 
-	/* Look for the first non alphabetic character after the '$'.  */
+	/* Look for the first non alphanumeric character after the '$'.  */
 	send = srch + srch_len;
 	for (s = srch; s < send; s++)
-	    if (! isalpha ((unsigned char) *s))
+	    if (! isalnum ((unsigned char) *s))
 		break;
 
-	/* If the first non alphabetic character is not '$' or ':',
+	/* If the first non alphanumeric character is not '$' or ':',
            then this is not an RCS keyword.  */
 	if (s == send || (*s != '$' && *s != ':'))
 	    continue;
@@ -3741,6 +3781,11 @@ expand_keywords (RCSNode *rcs, RCSVers *
 		free_value = 1;
 		break;
 
+	    case KEYWORD_MDOCDATE:
+		value = mdoc_date (ver->date);
+		free_value = 1;
+		break;
+
 	    case KEYWORD_CVSHEADER:
 	    case KEYWORD_HEADER:
 	    case KEYWORD_ID:
@@ -5081,7 +5126,7 @@ RCS_checkin (RCSNode *rcs, const char *u
 	(void) time (&modtime);
     ftm = gmtime (&modtime);
     delta->date = Xasprintf (DATEFORM,
-			     ftm->tm_year + (ftm->tm_year < 100 ? 0 : 1900),
+			     (long)ftm->tm_year + (ftm->tm_year < 100 ? 0L : 1900L),
 			     ftm->tm_mon + 1, ftm->tm_mday, ftm->tm_hour,
 			     ftm->tm_min, ftm->tm_sec);
     if (flags & RCS_FLAGS_DEAD)
@@ -7235,6 +7280,7 @@ rcs_change_text (const char *name, char 
 /* Walk the deltas in RCS to get to revision VERSION.
 
    If OP is RCS_ANNOTATE, then write annotations using cvs_output.
+   If OP is RCS_ANNOTATE_BACKWARDS, do the same backwards.
 
    If OP is RCS_FETCH, then put the contents of VERSION into a
    newly-malloc'd array and put a pointer to it in *TEXT.  Each line
@@ -7263,6 +7309,7 @@ RCS_deltas (RCSNode *rcs, FILE *fp, stru
     RCSVers *vers;
     RCSVers *prev_vers;
     RCSVers *trunk_vers;
+    RCSVers *top_vers;
     char *next;
     int ishead, isnext, isversion, onbranch;
     Node *node;
@@ -7285,6 +7332,7 @@ RCS_deltas (RCSNode *rcs, FILE *fp, stru
     vers = NULL;
     prev_vers = NULL;
     trunk_vers = NULL;
+    top_vers = NULL;
     next = NULL;
     onbranch = 0;
     foundhead = 0;
@@ -7332,12 +7380,31 @@ RCS_deltas (RCSNode *rcs, FILE *fp, stru
 	    vers = node->data;
 	    next = vers->next;
 
+	    /* The top version is either HEAD or
+	       the last version on the branch.  */
+	    if (top_vers == NULL ||
+		(onbranch && (op == RCS_ANNOTATE_BACKWARDS)))
+		top_vers = vers;
+
 	    /* Compare key and trunkversion now, because key points to
 	       storage controlled by rcsbuf_getkey.  */
 	    if (STREQ (branchversion, key))
 	        isversion = 1;
 	    else
 	        isversion = 0;
+
+	    if ((op == RCS_ANNOTATE_BACKWARDS) && STREQ (version, key)) {
+		if (onbranch) {
+		    unsigned int ln;
+
+		    for (ln = 0; ln < curlines.nlines; ++ln)
+			curlines.vector[ln]->vers = NULL;
+		} else {
+		    foundhead = 1;
+		    linevector_copy (&headlines, &curlines);
+		    break;
+		}
+	    }
 	}
 
 	while (1)
@@ -7365,17 +7432,27 @@ RCS_deltas (RCSNode *rcs, FILE *fp, stru
 		rcsbuf_valpolish (rcsbuf, value, 0, &vallen);
 		if (ishead)
 		{
-		    if (! linevector_add (&curlines, value, vallen, NULL, 0))
+		    if (! linevector_add (&curlines, value, vallen,
+			   (op == RCS_ANNOTATE_BACKWARDS) ? vers : NULL, 0))
 			error (1, 0, "invalid rcs file %s", rcs->print_path);
 
 		    ishead = 0;
 		}
 		else if (isnext)
 		{
+		    RCSVers *addv, *delv;
+
+		    if (op == RCS_ANNOTATE_BACKWARDS) {
+			addv = onbranch ? NULL : prev_vers;
+			delv = onbranch ? vers : NULL;
+		    } else {
+			addv = onbranch ? vers : NULL;
+			delv = onbranch ? NULL : prev_vers;
+		    }
+
 		    if (! apply_rcs_changes (&curlines, value, vallen,
 					     rcs->path,
-					     onbranch ? vers : NULL,
-					     onbranch ? NULL : prev_vers))
+					     addv, delv))
 			error (1, 0, "invalid change text in %s", rcs->print_path);
 		}
 		break;
@@ -7391,7 +7468,9 @@ RCS_deltas (RCSNode *rcs, FILE *fp, stru
 	        /* This is the version we want.  */
 		linevector_copy (&headlines, &curlines);
 		foundhead = 1;
-		if (onbranch)
+		/* If we are annotating backwards, we have to
+		   continue tracking when we're tracking a branch.  */
+		if (onbranch && !(op == RCS_ANNOTATE_BACKWARDS))
 		{
 		    /* We have found this version by tracking up a
                        branch.  Restore back to the lines we saved
@@ -7480,6 +7559,7 @@ RCS_deltas (RCSNode *rcs, FILE *fp, stru
     switch (op)
     {
 	case RCS_ANNOTATE:
+	case RCS_ANNOTATE_BACKWARDS:
 	    {
 		unsigned int ln;
 
