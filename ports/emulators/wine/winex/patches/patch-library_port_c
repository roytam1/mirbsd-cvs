$MirOS$
--- library/port.c.orig	2003-12-17 20:50:56.000000000 +0000
+++ library/port.c	2004-02-26 18:03:58.000000000 +0000
@@ -433,8 +433,13 @@ int getrlimit (int resource, struct rlim
 }
 #endif /* HAVE_GETRLIMIT */
 
+#ifndef	ASSUME_BSDSAFE_VFORK
+#if defined(__OpenBSD__) && !defined(__MirBSD__)
+#define	ASSUME_BSDSAFE_VFORK
+#endif
+#endif
 
-#if defined(__svr4__) || defined(__NetBSD__)
+#if defined(__svr4__) || defined(__NetBSD__) || defined(__OpenBSD__)
 /***********************************************************************
  *             try_mmap_fixed
  *
@@ -457,7 +462,9 @@ static int try_mmap_fixed (void *addr, s
 {
     char * volatile result = NULL;
     int pagesize = getpagesize();
+#ifndef	ASSUME_BSDSAFE_VFORK
     pid_t pid;
+#endif
 
     /* We only try to map to a fixed address if
        addr is non-NULL and properly aligned,
@@ -470,6 +477,16 @@ static int try_mmap_fixed (void *addr, s
     if ( flags & MAP_FIXED )
         return 0;
 
+#ifndef	ASSUME_BSDSAFE_VFORK
+	/*
+	 * vfork on OpenBSD has the semantics of fork, except for
+	 * having the parent sleep. ("safe" vfork)
+	 * Thus, the changes in result, even if it's volatile,
+	 * are not reflected back in the parent.
+	 * This is not a problem in recent MirOS with the kernel
+	 * option VFORK_SHM set however.
+	 */
+
     /* We use vfork() to freeze all threads of the
        current process.  This allows us to check without
        race condition whether the desired memory range is
@@ -483,6 +500,7 @@ static int try_mmap_fixed (void *addr, s
         exit(1);
     }
     if ( pid == 0 ) /* Child process */
+#endif
     {
         int i;
         char vec;
@@ -492,11 +510,18 @@ static int try_mmap_fixed (void *addr, s
            mapped and we must fail. */
         for ( i = 0; i < len; i += pagesize )
             if ( mincore( (caddr_t)addr + i, pagesize, &vec ) != -1 )
+#ifdef	ASSUME_BSDSAFE_VFORK
+		return 0;
+#else
                _exit(1);
+#endif
 
         /* Perform the mapping with MAP_FIXED set.  This is safe
            now, as none of the pages is currently in use. */
         result = mmap( addr, len, prot, flags | MAP_FIXED, fildes, off );
+#ifdef	ASSUME_BSDSAFE_VFORK
+    }
+#else
         if ( result == addr )
             _exit(0);
 
@@ -509,6 +534,7 @@ static int try_mmap_fixed (void *addr, s
     /* vfork() lets the parent continue only after the child
        has exited.  Furthermore, Wine sets SIGCHLD to SIG_IGN,
        so we don't need to wait for the child. */
+#endif
 
     return result == addr;
 }
@@ -545,7 +571,7 @@ void *wine_anon_mmap( void *start, size_
     flags |= MAP_PRIVATE;
 #endif
 
-#if defined(__svr4__) || defined(__NetBSD__)
+#if defined(__svr4__) || defined(__NetBSD__) || defined(__OpenBSD__)
     if ( try_mmap_fixed( start, size, prot, flags, fdzero, 0 ) )
         return start;
 #endif
@@ -574,7 +600,7 @@ void *wine_dlopen( const char *filename,
     char *s;
     dlerror(); dlerror();
     ret = dlopen( filename, flag );
-    s = dlerror();
+    s = (char *)dlerror();
     if (error)
     {
 	strncpy( error, s ? s : "", errorsize );
@@ -602,7 +628,7 @@ void *wine_dlsym( void *handle, const ch
     char *s;
     dlerror(); dlerror();
     ret = dlsym( handle, symbol );
-    s = dlerror();
+    s = (char *)dlerror();
     if (error)
     {
 	strncpy( error, s ? s : "", errorsize );
@@ -630,7 +656,7 @@ int wine_dlclose( void *handle, char *er
     char *s;
     dlerror(); dlerror();
     ret = dlclose( handle );
-    s = dlerror();
+    s = (char *)dlerror();
     if (error)
     {
 	strncpy( error, s ? s : "", errorsize );
