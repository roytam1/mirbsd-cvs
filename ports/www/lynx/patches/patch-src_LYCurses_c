$MirOS$

	Fix spelling; suggested for upstream inclusion.

--- src/LYCurses.c.orig	Mon Feb 13 02:45:53 2012
+++ src/LYCurses.c	Sat Mar  3 18:20:22 2012
@@ -626,7 +626,7 @@ static int get_color_pair(int n)
 /*
  * Lynx "knows" about 16 colors.  ANSI colors (and most color terminal
  * emulators) only go to 8, though some curses implementations (ncurses and
- * PDCurses) handle 16.  If lynx's configuration calls for a color past the
+ * PDCurses) handle 16.  If lynx' configuration calls for a color past the
  * number of colors that the terminal handles (COLORS), map the extra value
  * to bold.
  */
@@ -1598,7 +1598,7 @@ void lynx_enable_mouse(int state)
  * simulates the OCRNL setting.  Normally that is not a problem.  However, when
  * spawning a subprocess (e.g., xli), the subprocess may write to the screen.
  * Fine so far - curses resets the terminal I/O to the normal state on exit.
- * But the subprocess's messages can still be coming to the screen when lynx
+ * But the subprocess' messages can still be coming to the screen when lynx
  * returns to the screen mode.  This function delays restoring OCRNL until
  * after the first getch() call.
  *
@@ -1670,7 +1670,7 @@ void stop_curses(void)
     _eth_release();
 #endif /* __DJGPP__ */
 
-/* ifdef's for non-Unix curses or slang */
+/* ifdefs for non-Unix curses or slang */
 #if defined(__MINGW32__)
     chtype bb;
 
@@ -1715,7 +1715,7 @@ void stop_curses(void)
     }
 
     fflush(stdout);
-#endif /* ifdef's for non-Unix curses or slang */
+#endif /* ifdefs for non-Unix curses or slang */
     fflush(stderr);
 
     LYCursesON = FALSE;
@@ -1963,7 +1963,7 @@ void LYpaddstr(WINDOW * the_window, int 
 }
 
 /*
- * Work around limitation of curses's order-of-refresh by setting a pointer to
+ * Work around limitation of curses' order-of-refresh by setting a pointer to
  * the topmost window that should be displayed.
  *
  * FIXME: the associated call on 'keypad()' is not needed for Unix, but
@@ -2129,7 +2129,7 @@ void LYwaddnstr(WINDOW * w GCC_UNUSED,
      * Link-highlighting uses wrapping.  You can see this by viewing the
      * options screen in a terminal which is narrower than 80 columns.
      *
-     * Check for that case, and use curses's wrapping in a derived window to
+     * Check for that case, and use curses' wrapping in a derived window to
      * simplify things, e.g., in case the string contains multibyte or
      * multicolumn characters.
      */
@@ -2607,7 +2607,7 @@ int typeahead(void)
  *		Call VMSsignal(SIGINT, SIG_IGN) before system() calls to
  *		 enable Ctrl-C and Ctrl-Y in the subprocess, and then call
  *		 VMSsignal(SIG_INT, cleanup_sig) on return from the subprocess.
- *		For func's which set flags and do not invoke an exit from
+ *		For funcs which set flags and do not invoke an exit from
  *		 LYNX, the func should reassert itself.
  *		The VMS signal() calls do not fully emulate the Unix calls,
  *		 and VMSsignal() is just a "helper", also not a full emulation.
@@ -2854,7 +2854,7 @@ void LYrefresh(void)
 	 * and has a subject line that is wider than the screen.  The
 	 * wnoutrefresh() call resets newscr's position to match stdscr's,
 	 * which happens to be the window's origin because we were not updating
-	 * that, and other stray wmove's in lynx fail because the coordinate
+	 * that, and other stray wmoves in lynx fail because the coordinate
 	 * is on/after the right margin.  Force things to look ok here.
 	 */
 	int y, x;
@@ -3088,7 +3088,7 @@ void LYSetDisplayLines(void)
 /*
  * If LYShowCursor is ON, move the cursor to the left of the current option, so
  * that blind users, who are most likely to have LYShowCursor ON, will have
- * it's string spoken or passed to the braille interface as each option is made
+ * its string spoken or passed to the braille interface as each option is made
  * current.  Otherwise, move it to the bottom, right column of the screen, to
  * "hide" the cursor as for the main document, and let sighted users rely on
  * the current option's highlighting or color without the distraction of a
