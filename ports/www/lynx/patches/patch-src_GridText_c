$MirOS$

	Fix spelling; suggested for upstream inclusion.

--- src/GridText.c.orig	Mon Feb 13 02:45:53 2012
+++ src/GridText.c	Sat Mar  3 18:20:22 2012
@@ -4170,7 +4170,7 @@ void HText_appendCharacter(HText *text, 
 
     /*
      * I'm going to cheat here in a BIG way.  Since I know that all
-     * \r's will be trapped by HTML_put_character I'm going to use
+     * \rs will be trapped by HTML_put_character I'm going to use
      * \r to mean go down a line but don't start a new paragraph.
      * i.e., use the second line indenting.
      */
@@ -6112,8 +6112,8 @@ HTChildAnchor *HText_childNextNumber(int
     if (number == 1 || !a)
 	a = HTMainText->first_anchor;
 
-    /* a strange thing:  positive a->number's are sorted,
-     * and between them several a->number's may be 0 -- skip them
+    /* a strange thing:  positive a->numbers are sorted,
+     * and between them several a->numbers may be 0 -- skip them
      */
     for (; a && a->number != number; a = a->next) ;
 
@@ -7941,7 +7941,7 @@ static unsigned countHTLines(void)
 /*
  * The TextAnchor list is not organized to allow efficient dumping of a page.
  * Make an array with one item per line of the page, and store (by byte-offset)
- * pointers to the TextAnchor's we want to use.
+ * pointers to the TextAnchors we want to use.
  */
 static AnchorIndex **allocAnchorIndex(unsigned *size)
 {
@@ -8104,7 +8104,7 @@ void print_wwwfile_to_fd(FILE *fp,
 
     /*
      * Build an index of anchors for each line, so we can override the
-     * static text which is stored in the list of HTLine's.
+     * static text which is stored in the list of HTLines.
      */
     inx = allocAnchorIndex(&inx_size);
 
@@ -12073,7 +12073,7 @@ static void free_all_texts(void)
 
 /*
  *  stub_HTAnchor_address is like HTAnchor_address, but it returns the
- *  parent address for child links.  This is only useful for traversal's
+ *  parent address for child links.  This is only useful for traversals
  *  where one does not want to index a text file N times, once for each
  *  of N internal links.  Since the parent link has already been taken,
  *  it won't go again, hence the (incorrect) links won't cause problems.
@@ -12621,7 +12621,7 @@ static int increment_tagged_htline(HTLin
 }
 
 /*
- * Creates a new anchor and associated struct's appropriate for a form
+ * Creates a new anchor and associated structs appropriate for a form
  * TEXTAREA, and links them into the lists following the current anchor
  * position (as specified by arg1).
  *
@@ -12661,7 +12661,7 @@ static void insert_new_textarea_anchor(T
     }
 
     /*
-     * Clone and initialize the struct's needed to add a new TEXTAREA
+     * Clone and initialize the structs needed to add a new TEXTAREA
      * anchor.
      */
     allocHTLine(l, MAX_LINE);
@@ -12710,7 +12710,7 @@ static void insert_new_textarea_anchor(T
     l->offset = htline->offset;
     l->size = htline->size;
 #if defined(USE_COLOR_STYLE)
-    /* dup styles[] if needed [no need in TEXTAREA (?); leave 0's] */
+    /* dup styles[] if needed [no need in TEXTAREA (?); leave 0s] */
     l->numstyles = htline->numstyles;
     /*we fork the pointers! */
     l->styles = htline->styles;
@@ -12777,7 +12777,7 @@ static void update_subsequent_anchors(in
     int hang = 0;		/* for HANG detection of a nasty intermittent */
     int hang_detect = 100000;	/* ditto */
 
-    CTRACE((tfp, "GridText: adjusting struct's to add %d new line(s)\n", newlines));
+    CTRACE((tfp, "GridText: adjusting structs to add %d new line(s)\n", newlines));
 
     /*
      * Update numeric fields of the rest of the anchors.
@@ -12843,7 +12843,7 @@ static void update_subsequent_anchors(in
 		/*** failed at different times, which indicates some  */
 		/*** sort of content/html dependency, or some kind of */
 		/*** a "race" condition, but I'll be damned if I can  */
-		/*** find it after tons of CTRACE's, printf()'s, gdb  */
+		/*** find it after tons of CTRACEs, printf()s, gdb    */
 		/*** breakpoints and watchpoints, etc.                */
 		/***                                                  */
 		/*** I have added a hang detector (with error msg and */
@@ -12885,7 +12885,7 @@ static void update_subsequent_anchors(in
 
     more_text = HText_canScrollDown();
 
-    CTRACE((tfp, "GridText: TextAnchor and HTLine struct's adjusted\n"));
+    CTRACE((tfp, "GridText: TextAnchor and HTLine structs adjusted\n"));
 
     return;
 
@@ -12901,7 +12901,7 @@ static void update_subsequent_anchors(in
  * KED's note -
  * [Finding the TEXTAREA we're actually *in* with these attributes isn't
  * foolproof.  The form number isn't unique to a given TEXTAREA, and there
- * *could* be TEXTAREA's with the same "name".  If that should ever be true,
+ * *could* be TEXTAREAs with the same "name".  If that should ever be true,
  * we'll actually get the data from the *1st* TEXTAREA in the page that
  * matches.  We should probably assign a unique id to each TEXTAREA in a page,
  * and match on that, to avoid this (potential) problem.
@@ -13172,7 +13172,7 @@ static int finish_ExtEditForm(LinkInfo *
 	line_cnt++;
     }
 
-    CTRACE((tfp, "GridText: edited text inserted into lynx struct's\n"));
+    CTRACE((tfp, "GridText: edited text inserted into lynx structs\n"));
 
     /*
      * If we've added any new lines/anchors, we need to adjust various
@@ -13632,7 +13632,7 @@ int HText_InsertFile(LinkInfo * form_lin
     l->offset = htline->offset;
     l->size = htline->size;
 #if defined(USE_COLOR_STYLE)
-    /* dup styles[] if needed [no need in TEXTAREA (?); leave 0's] */
+    /* dup styles[] if needed [no need in TEXTAREA (?); leave 0s] */
     l->numstyles = htline->numstyles;
     /*we fork the pointers! */
     l->styles = htline->styles;
@@ -13737,7 +13737,7 @@ int HText_InsertFile(LinkInfo * form_lin
 	anchor_ptr = anchor_ptr->next;
     }
 
-    CTRACE((tfp, "GridText: file inserted into lynx struct's\n"));
+    CTRACE((tfp, "GridText: file inserted into lynx structs\n"));
 
     /*
      * Now adjust various things in all anchor-bearing lines following the
@@ -14472,7 +14472,7 @@ static void move_to_glyph(int YP,
  * and starting to draw when a UTF-8 encoded non-ASCII character
  * is encountered before the link (with some protection against
  * overwriting form fields).  This refreshing of preceding data is
- * necessary for preventing curses's or slang's display logic from
+ * necessary for preventing curses' or slang's display logic from
  * getting too clever; their logic counts character positions wrong
  * since they don't know about multi-byte characters that take up
  * only one screen position.  So we have to make them forget their
