#!/usr/bin/perl -W
# $MirOS: ports/infrastructure/scripts/unlibtoolise,v 1.3 2005/07/23 17:39:29 bsiegert Exp $
#-
# Copyright (c) 2005,
#	Benny Siegert <bsiegert@gmx.de>
#
# Licensee is hereby permitted to deal in this work without restric-
# tion, including unlimited rights to use, publically perform, modi-
# fy, merge, distribute, sell, give away or sublicence, provided the
# above copyright notices, these terms and the disclaimer are retai-
# ned in all redistributions, or reproduced in accompanying documen-
# tation or other materials provided with binary redistributions.
#
# Licensor hereby provides this work "AS IS" and WITHOUT WARRANTY of
# any kind, expressed or implied, to the maximum extent permitted by
# applicable law, but with the warranty of being written without ma-
# licious intent or gross negligence; in no event shall licensor, an
# author or contributor be held liable for any damage, direct, indi-
# rect or other, however caused, arising in any way out of the usage
# of covered work, even if advised of the possibility of such damage.
#-
# This script is the reverse of the libtoolise routine in make-plist.
# It uses the same routine to re-add the files referenced by a .la
# (libtool library info file) into the PLIST. It is called from
# within bsd.port.mk in the w-pkgname/fake-arch/usr/local directory.
# It is called as a filter with the list on stdin and the LOCALBASE
# environment variable set to something like /usr/local.

use strict;
use File::Spec;

# Given the name of a .la file, return a list of files referenced by it.
sub libtoolise_plist
{
	my $file = shift;
	my $prefix;
	my @libnames;
	local $_;

	open(FILE, '<', $file) || die "Cannot open $file";
	while (<FILE>) {
		chomp;
		next unless m/^([^=]+)='(.*)'$/;
		if ($1 eq 'libdir') {
			$prefix = File::Spec->abs2rel($2, $ENV{LOCALBASE});
		} elsif (	  ($1 eq 'dlname')
				||($1 eq 'library_names')
				||($1 eq 'old_library')) {
			push(@libnames, split(/ /, $2));
		}
	}
	close(FILE);

	foreach (@libnames) {
		$_ = File::Spec->catfile($prefix, $_);
	}
	# remove duplicates
	return %{{ map { $_ => 1 } File::Spec->no_upwards(@libnames) }};
}

sub print_lib
{
	my $libs = shift;
	
	foreach my $name (keys %$libs) {
		if ($name =~ m/lib.*\.so\.\d+\.\d+/) {
			print "\@lib $name\n";
		} else {
			print $name . "\n";
		}
	}
}

my %ltlibs = ();
my @plist = <>;

# for all .la files, create a hash of hashes with dependent files
foreach my $entry (@plist) {
	chomp $entry;
	$ltlibs{$entry} = \%{{ libtoolise_plist($entry) }}
		if ($entry =~ m/^[^@].*\.la$/);
}

# now kill those files that are already in the plist
foreach (@plist) {
	my $entry;
	if (m/^\@lib /) {
		$entry = $';
	} else {
		$entry = $_;
	}
	foreach my $key (keys %ltlibs) {
		delete $ltlibs{$key}->{$entry}
			if defined $ltlibs{$key}->{$entry};
	}
}

# and now print the whole thing
foreach (@plist) {
	print_lib($ltlibs{$_}) if (m/\.la$/ && defined $ltlibs{$_});
	print $_ . "\n";
}
