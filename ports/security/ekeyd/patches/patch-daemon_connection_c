$MirOS$
--- daemon/connection.c.orig	Tue Nov 17 11:57:46 2009
+++ daemon/connection.c	Sun Nov 22 19:22:22 2009
@@ -220,14 +220,11 @@ keyreq_pkt_handler(econ_state_t *state, 
     
     if (!fill_nonce(state->nonce + sizeof(uint32_t), 
                     state->nonce_len - sizeof(uint32_t))) {
-        char serialnumber[32];
-        
-        if (econ_getsnum(state, serialnumber))
-            serialnumber[12] = 0;
-        else
-            strcpy(serialnumber, "UnknownKey");
-    
+        char *serialnumber;
+
+        serialnumber = econ_getsnum(state);
         syslog(LOG_ERR, "%s: Unable to prepare nonce for keying.  Key no longer trusted.", serialnumber);
+        free(serialnumber);
         return ESTATE_UNTRUSTED;
     }
     *(uint32_t *)state->nonce = state->con_nonces;
@@ -259,20 +256,17 @@ keyreq_pkt_handler(econ_state_t *state, 
 static ekey_state_t
 keyreq_count_pkt_handler(econ_state_t *state, uint8_t *buf, size_t count)
 {
-    char serialnumber[32];
-    
-    if (econ_getsnum(state, serialnumber))
-        serialnumber[12] = 0;
-    else
-        strcpy(serialnumber, "UnknownKey");
-    
+    char *serialnumber;
+
+    serialnumber = econ_getsnum(state);
     if (state->keyreq_counter++ < MAX_PACKETS_BEFORE_RESET) {
         syslog(LOG_WARNING, "%s: Repeated key request (ignored)", serialnumber);
+        free(serialnumber);
         return ESTATE_SESSION_SENT;
     }
     
     syslog(LOG_WARNING, "%s: Too many key requests in a row. Resetting state machine and device.", serialnumber);
-    
+    free(serialnumber);
     return reset_pkt_handler(state, buf, count);
 }
 
@@ -595,14 +589,20 @@ econ_setsnum(econ_state_t *state, const 
  * @param snum The serial number to set.
  * @return True if the seral number buffer was updated.
  */
-bool
-econ_getsnum(econ_state_t *state, char *snum)
+char *
+econ_getsnum(econ_state_t *state)
 {
+    char *snum;
+    size_t snumlen;
+
     if (state->snum == NULL)
-        return false;
+        return (strdup("UnknownKey"));
 
+    snumlen = ((state->snum_len + 2) / 3) * 4;
+    snum = malloc(snumlen + 1);
     pem64_encode_bytes(state->snum, state->snum_len, snum);
-    return true;
+    snum[snumlen] = '\0';
+    return (snum);
 }
 
 /** Shutdown a connection and free its context. 
