$MirOS: ports/security/ekeyd/patches/patch-daemon_ekey-setkey_c,v 1.1 2009/11/14 21:45:30 tg Exp $
--- daemon/ekey-setkey.c.orig	Fri Nov  6 12:33:09 2009
+++ daemon/ekey-setkey.c	Sat Nov 14 23:20:48 2009
@@ -40,6 +40,12 @@
 /** Exit code returned when utility is unable to write updated keyring */
 #define EXIT_CODE_WRITEKEYRING 6
 
+#define DEVEKEY "/dev/entropykey/"
+
+#if defined(EKEY_OS_OPENBSD) || defined(EKEY_OS_MIRBSD)
+#define ARC4RANDOM_NONCE
+#endif
+
 /** Conenction state. */
 struct econ_state_s {
     uint8_t *mkey; /**< Master key. */
@@ -194,7 +200,9 @@ main(int argc, char **argv)
     int res;
     uint8_t data[128];
     uint8_t nonce[12];
+#ifndef ARC4RANDOM_NONCE
     int randfd;
+#endif
     uint8_t *mac;
     EKeySkein rekeying_state;
     uint8_t session_key[32];
@@ -247,8 +255,8 @@ main(int argc, char **argv)
             fprintf(stderr, usage, argv[0]);
             return EXIT_CODE_CMDLINE;
         } else {
-            key_path = calloc(1, 17 + strlen("/dev/entropykey/"));
-            sprintf(key_path, "/dev/entropykey/");
+            key_path = calloc(1, 17 + strlen(DEVEKEY));
+            memcpy(key_path, DEVEKEY, 1 + strlen(DEVEKEY));
             pem64_encode_bytes(snum, 12, key_path + 16);
         }
     } else {
@@ -351,6 +359,10 @@ main(int argc, char **argv)
     epkt_setsessionkey(epkt, snum, default_session_key);
 
     /* Prepare a nonce */
+#ifdef ARC4RANDOM_NONCE
+    /* XXX we can use MUCH more than 12 here, it's VERY cheap */
+    arc4random_buf(nonce, 12);
+#else
     randfd = open("/dev/urandom", O_RDONLY);
     if (randfd == -1) {
         perror("open(/dev/urandom)");
@@ -359,6 +371,7 @@ main(int argc, char **argv)
     if (read(randfd, nonce, 12) != 12)
         perror("read");
     close(randfd);
+#endif
 
     /* send nonce MAC */
     mac = calc_mac(snum, mkey, nonce, 12);
