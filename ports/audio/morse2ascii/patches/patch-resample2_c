$MirOS$
--- resample2.c.orig	Tue Oct  2 18:21:51 2012
+++ resample2.c	Thu Oct 17 19:23:35 2013
@@ -36,7 +36,6 @@
 #define FFSIGN(a) ((a) > 0 ? 1 : -1)
 #define FFMAX(a,b) ((a) > (b) ? (a) : (b))
 #define FFMIN(a,b) ((a) > (b) ? (b) : (a))
-#define av_mallocz  malloc
 #define av_freep    free
 
 #ifndef CONFIG_RESAMPLE_HP
@@ -81,6 +80,12 @@ typedef struct AVResampleContext{
     int linear;
 }AVResampleContext;
 
+void av_build_filter(FELEM *filter, double factor, int tap_count, int phase_count, int scale, int type);
+AVResampleContext *av_resample_init(int out_rate, int in_rate, int filter_size, int phase_shift, int linear, double cutoff);
+void av_resample_close(AVResampleContext *c);
+void av_resample_compensate(AVResampleContext *c, int sample_delta, int compensation_distance);
+int av_resample(AVResampleContext *c, short *dst, short *src, int *consumed, int src_size, int dst_size, int update_ctx);
+
 /**
  * 0th order modified bessel function of the first kind.
  */
@@ -198,7 +203,7 @@ void av_build_filter(FELEM *filter, doub
  * Note, if either rate is not an integer then simply scale both rates up so they are.
  */
 AVResampleContext *av_resample_init(int out_rate, int in_rate, int filter_size, int phase_shift, int linear, double cutoff){
-    AVResampleContext *c= av_mallocz(sizeof(AVResampleContext));
+    AVResampleContext *c= calloc(sizeof(AVResampleContext), 1);
     double factor= FFMIN(out_rate * cutoff / in_rate, 1.0);
     int phase_count= 1<<phase_shift;
 
@@ -206,8 +211,9 @@ AVResampleContext *av_resample_init(int 
     c->phase_mask= phase_count-1;
     c->linear= linear;
 
-    c->filter_length= FFMAX((int)ceil(filter_size/factor), 1);
-    c->filter_bank= av_mallocz(c->filter_length*(phase_count+1)*sizeof(FELEM));
+    c->filter_length = ceil(filter_size / factor);
+    c->filter_length = FFMAX(c->filter_length, 1);
+    c->filter_bank= calloc(c->filter_length*(phase_count+1), sizeof(FELEM));
     av_build_filter(c->filter_bank, factor, c->filter_length, phase_count, 1<<FILTER_SHIFT, WINDOW_TYPE);
     memcpy(&c->filter_bank[c->filter_length*phase_count+1], c->filter_bank, (c->filter_length-1)*sizeof(FELEM));
     c->filter_bank[c->filter_length*phase_count]= c->filter_bank[c->filter_length - 1];
@@ -255,29 +261,29 @@ void av_resample_compensate(AVResampleCo
  */
 int av_resample(AVResampleContext *c, short *dst, short *src, int *consumed, int src_size, int dst_size, int update_ctx){
     int dst_index, i;
-    int index= c->index;
+    int indexv= c->index;
     int frac= c->frac;
     int dst_incr_frac= c->dst_incr % c->src_incr;
     int dst_incr=      c->dst_incr / c->src_incr;
     int compensation_distance= c->compensation_distance;
 
   if(compensation_distance == 0 && c->filter_length == 1 && c->phase_shift==0){
-        int64_t index2= ((int64_t)index)<<32;
+        int64_t index2= ((int64_t)indexv)<<32;
         int64_t incr= (1LL<<32) * c->dst_incr / c->src_incr;
-        dst_size= FFMIN(dst_size, (src_size-1-index) * (int64_t)c->src_incr / c->dst_incr);
+        dst_size= FFMIN(dst_size, (src_size-1-indexv) * (int64_t)c->src_incr / c->dst_incr);
 
         for(dst_index=0; dst_index < dst_size; dst_index++){
             dst[dst_index] = src[index2>>32];
             index2 += incr;
         }
         frac += dst_index * dst_incr_frac;
-        index += dst_index * dst_incr;
-        index += frac / c->src_incr;
+        indexv += dst_index * dst_incr;
+        indexv += frac / c->src_incr;
         frac %= c->src_incr;
   }else{
     for(dst_index=0; dst_index < dst_size; dst_index++){
-        FELEM *filter= c->filter_bank + c->filter_length*(index & c->phase_mask);
-        int sample_index= index >> c->phase_shift;
+        FELEM *filter= c->filter_bank + c->filter_length*(indexv & c->phase_mask);
+        int sample_index= indexv >> c->phase_shift;
         FELEM2 val=0;
 
         if(sample_index < 0){
@@ -306,10 +312,10 @@ int av_resample(AVResampleContext *c, sh
 #endif
 
         frac += dst_incr_frac;
-        index += dst_incr;
+        indexv += dst_incr;
         if(frac >= c->src_incr){
             frac -= c->src_incr;
-            index++;
+            indexv++;
         }
 
         if(dst_index + 1 == compensation_distance){
@@ -319,8 +325,8 @@ int av_resample(AVResampleContext *c, sh
         }
     }
   }
-    *consumed= FFMAX(index, 0) >> c->phase_shift;
-    if(index>=0) index &= c->phase_mask;
+    *consumed= FFMAX(indexv, 0) >> c->phase_shift;
+    if(indexv>=0) indexv &= c->phase_mask;
 
     if(compensation_distance){
         compensation_distance -= dst_index;
@@ -328,7 +334,7 @@ int av_resample(AVResampleContext *c, sh
     }
     if(update_ctx){
         c->frac= frac;
-        c->index= index;
+        c->index= indexv;
         c->dst_incr= dst_incr_frac + c->src_incr*dst_incr;
         c->compensation_distance= compensation_distance;
     }
