$MirOS$
--- xmms/bmp.c.orig	2002-02-12 00:15:56.000000000 +0100
+++ xmms/bmp.c	2007-04-22 22:45:59.000000000 +0200
@@ -19,6 +19,12 @@
  */
 #include "xmms.h"
 
+#if HAVE_STDINT_H
+#include <stdint.h>
+#elif !defined(UINT32_MAX)
+#define UINT32_MAX 0xffffffffU
+#endif
+
 typedef struct tagRGBQUAD
 {
 	guchar rgbBlue;
@@ -184,7 +190,7 @@ GdkPixmap *read_bmp(gchar * filename)
 	}
 	else if (bitcount != 24 && bitcount != 16 && bitcount != 32)
 	{
-		gint ncols, i;
+		guint32 ncols, i;
 
 		ncols = offset - headSize - 14;
 		if (headSize == 12)
@@ -200,10 +206,17 @@ GdkPixmap *read_bmp(gchar * filename)
 		}
 	}
 	fseek(file, offset, SEEK_SET);
+	/* verify buffer size */
+	if (!h || !w ||
+	    w > (((UINT32_MAX - 3) / 3) / h) ||
+	    h > (((UINT32_MAX - 3) / 3) / w)) {
+		g_warning("read_bmp(): width(%u)*height(%u) too large", w, h);
+		goto failure;
+	}
+	data = g_malloc0((w * 3 * h) + 3);	/* +3 is just for safety */
 	buffer = g_malloc(imgsize);
 	fread(buffer, imgsize, 1, file);
 	fclose(file);
-	data = g_malloc0((w * 3 * h) + 3);	/* +3 is just for safety */
 
 	if (bitcount == 1)
 		read_1b_rgb(buffer, imgsize, data, w, h, rgb_quads);
@@ -244,6 +257,7 @@ GdkPixmap *read_bmp(gchar * filename)
 	g_free(data);
 	g_free(buffer);
 
+failure:
 	return ret;
 }
 
