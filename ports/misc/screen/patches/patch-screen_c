$MirOS: ports/misc/screen/patches/patch-screen_c,v 1.2 2007/02/11 01:33:46 tg Exp $
--- screen.c.orig	Mon Sep  8 14:26:19 2003
+++ screen.c	Sun Feb 11 01:15:30 2007
@@ -152,6 +152,9 @@ static char *pad_expand __P((char *, cha
 #ifdef DEBUG
 static void  fds __P((void));
 #endif
+#if defined(ENCODINGS) && defined(UTF8) && defined(POSIX)
+static int   scan_for_encoding __P((int));
+#endif
 
 int nversion;	/* numerical version, used for secondary DA */
 
@@ -1223,6 +1226,10 @@ char **av;
       if (MakeDisplay(LoginName, attach_tty, attach_term, n, getppid(), &attach_Mode) == 0)
 	Panic(0, "Could not alloc display");
 #ifdef ENCODINGS
+#if defined(UTF8) && defined(POSIX)
+      D_encoding = scan_for_encoding(n);
+      if (D_encoding < 0)
+#endif
       D_encoding = nwin_options.encoding > 0 ? nwin_options.encoding : 0;
       debug1("D_encoding = %d\n", D_encoding);
 #endif
@@ -2428,10 +2435,10 @@ int rec;
 #endif
 	      break;
 	    case 'y':
-	      sprintf(p, "%02d", tm->tm_year % 100);
+	      sprintf(p, "%02d", (int)(tm->tm_year % 100));
 	      break;
 	    case 'Y':
-	      sprintf(p, "%04d", tm->tm_year + 1900);
+	      sprintf(p, "%04ld", (long)(tm->tm_year + 1900));
 	      break;
 	    case 'a':
 	      sprintf(p, tm->tm_hour >= 12 ? "pm" : "am");
@@ -3174,3 +3181,51 @@ char *p;
   return 0;
 }
 
+/* Copyright (c) 2007 Thorsten Glaser <tg@mirbsd.de> */
+
+#if defined(ENCODINGS) && defined(UTF8) && defined(POSIX)
+static const char sfe_qs[] = "\030\032\r\xE2\x82\xAC.\033[6n";
+__RCSID("$miros: src/usr.sbin/wsconfig/wsconfig.c,v 1.10 2007/02/11 00:59:00 tg Exp $");
+__RCSID("$MirOS: ports/misc/screen/patches/patch-screen_c,v 1.2 2007/02/11 01:33:46 tg Exp $");
+
+static int
+scan_for_encoding(fd)
+int fd;
+{
+	struct termios tio, otio;
+	char sbuf[64];
+	int i, j = -1;
+
+	if (tcgetattr(fd, &otio))
+		return (-1);
+	tio = otio;
+	cfmakeraw(&tio);
+	tcflush(fd, TCIOFLUSH);
+	if (tcsetattr(fd, TCSANOW, &tio))
+		goto out;
+	if ((size_t)write(fd, sfe_qs, strlen(sfe_qs)) != strlen(sfe_qs))
+		goto out;
+	i = read(fd, sbuf, sizeof (sbuf));
+	if (i > 5 && sbuf[0] == 033 && sbuf[1] == '[') {
+		j = 2;
+		while (j < (i - 2))
+			if (sbuf[j++] == ';')
+				break;
+		if (sbuf[j - 1] == ';')
+			debug2("scan_for_encoding: at column %c%c\n",
+			    sbuf[j], sbuf[j + 1]);
+		else
+			debug("scan_for_encoding: invalid response\n");
+		if (sbuf[j - 1] == ';' &&
+		    (sbuf[j] == '3' || sbuf[j] == '4') &&
+		    (sbuf[j + 1] < '0' || sbuf[j + 1] > '9'))
+			j = sbuf[j] == '4' ? 0 : UTF8;
+		else
+			j = -1;
+	}
+	write(fd, "\r      \r", 8);
+ out:
+	tcsetattr(fd, TCSAFLUSH, &otio);
+	return (j);
+}
+#endif
