$MirOS: ports/misc/screen/patches/patch-screen_c,v 1.14 2008/10/13 20:58:16 tg Exp $
$OpenBSD: shmpatch-screen_c,v 1.1 2003/11/22 00:56:58 espie Exp $
--- screen.c.orig	Mon Sep  8 14:26:19 2003
+++ screen.c	Sat Jan  9 18:20:54 2010
@@ -27,6 +27,19 @@
  * Free Software Foundation, Inc.,
  * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
  *
+ * Modified by:
+ * Copyright (c) 2006, 2007, 2008, 2010
+ *	Thorsten Glaser <tg@mirbsd.de>
+ *
+ * This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
+ * the utmost extent permitted by applicable law, neither express nor
+ * implied; without malicious intent or gross negligence. In no event
+ * may a licensor, author or contributor be held liable for indirect,
+ * direct, other damage, loss, or other issues arising in any way out
+ * of dealing in the work, even if advised of the possibility of such
+ * damage or existence of a defect, except proven that it results out
+ * of said person's immediate fault when using the work as intended.
+ *
  ****************************************************************
  */
 
@@ -44,9 +57,7 @@
 # include <sys/ioctl.h>
 #endif
 
-#ifndef SIGINT
 # include <signal.h>
-#endif
 
 #include "config.h"
 
@@ -71,6 +82,12 @@
 #if (defined(AUX) || defined(_AUX_SOURCE)) && defined(POSIX)
 # include <compat.h>
 #endif
+
+#ifdef IPC_EXPORT_IMAGE
+# include <sys/ipc.h>
+# include <sys/shm.h>
+#endif
+
 #if defined(USE_LOCALE) || defined(ENCODINGS)
 # include <locale.h>
 #endif
@@ -152,6 +169,9 @@ static char *pad_expand __P((char *, cha
 #ifdef DEBUG
 static void  fds __P((void));
 #endif
+#if defined(ENCODINGS) && defined(UTF8) && defined(POSIX)
+int          scan_for_encoding __P((int));
+#endif
 
 int nversion;	/* numerical version, used for secondary DA */
 
@@ -233,6 +253,9 @@ struct win *windows;
 struct win *console_window;
 
 
+#ifdef IPC_EXPORT_IMAGE
+char *shm;		/* pointer to shared memory segment */
+#endif
 
 /*
  * Do this last
@@ -377,8 +400,11 @@ char **av;
 #ifdef DEBUG
   opendebug(1, 0);
 #endif
+#ifndef PORT_VERSION
+#define PORT_VERSION ""
+#endif
   sprintf(version, "%d.%.2d.%.2d%s (%s) %s", REV, VERS,
-	  PATCHLEVEL, STATE, ORIGIN, DATE);
+	  PATCHLEVEL, STATE PORT_VERSION, ORIGIN, DATE);
   nversion = REV * 10000 + VERS * 100 + PATCHLEVEL;
   debug2("-- screen debug started %s (%s)\n", *av, version);
 #ifdef POSIX
@@ -461,6 +487,35 @@ char **av;
   zmodem_recvcmd = SaveStr("!!! rz -vv -b -E");
 #endif
 
+#ifdef IPC_EXPORT_IMAGE
+  {
+    key_t key = 0xBACD072F;	/* random static IPC key */
+    int shmid;
+
+    /* Allocation of shared mem for 18000 bytes (screen text and attributes
+     * + few coord.).  We supose no screen will be wider than 132x66.
+     * 0x1C0 = [rwx------].
+     */
+    shmid = shmget(key, 18000, IPC_CREAT | 0x1C0);
+    if (shmid < 0) {
+      Panic(errno, "shmget");
+      /* NOTRECHED */
+    }
+    shm = shmat(shmid, NULL, 0);
+    if (shm == (void*)-1) {
+      Panic(errno, "shmat");
+      /* NOTRECHED */
+    }
+    /* minimal initialisation just to have valid data */
+    shm[0] = 80;	/* scrdim x */
+    shm[1] = 1;		/* scrdim y */
+    shm[2] = 0;		/* csrpos x */
+    shm[3] = 0;		/* csrpos y */
+    memset(shm + 4, ' ', 160);
+    memcpy(shm + 4, "screen is initializing...", 25);
+  }
+#endif
+
 #ifdef COPY_PASTE
   CompileKeys((char *)0, 0, mark_key_tab);
 #endif
@@ -1223,6 +1278,10 @@ char **av;
       if (MakeDisplay(LoginName, attach_tty, attach_term, n, getppid(), &attach_Mode) == 0)
 	Panic(0, "Could not alloc display");
 #ifdef ENCODINGS
+#if defined(UTF8) && defined(POSIX)
+      D_encoding = scan_for_encoding(n);
+      if (D_encoding < 0)
+#endif
       D_encoding = nwin_options.encoding > 0 ? nwin_options.encoding : 0;
       debug1("D_encoding = %d\n", D_encoding);
 #endif
@@ -2428,10 +2487,10 @@ int rec;
 #endif
 	      break;
 	    case 'y':
-	      sprintf(p, "%02d", tm->tm_year % 100);
+	      sprintf(p, "%02d", (int)(tm->tm_year % 100));
 	      break;
 	    case 'Y':
-	      sprintf(p, "%04d", tm->tm_year + 1900);
+	      sprintf(p, "%04d", (int)(tm->tm_year + 1900));
 	      break;
 	    case 'a':
 	      sprintf(p, tm->tm_hour >= 12 ? "pm" : "am");
@@ -2501,15 +2560,15 @@ int rec;
 	      int oldnumrend = winmsg_numrend;
 
 	      *p = 0;
-	      strcpy(savebuf, winmsg_buf);
+	      strlcpy(savebuf, winmsg_buf, sizeof(savebuf));
 	      winmsg_numrend = -winmsg_numrend;
 	      MakeWinMsgEv(*s == 'h' ? win->w_hstatus : runbacktick(bt, &oldtick, now.tv_sec), win, '\005', 0, (struct event *)0, rec + 1);
 	      debug2("oldtick=%d tick=%d\n", oldtick, tick);
 	      if (!tick || oldtick < tick)
 		tick = oldtick;
 	      if ((int)strlen(winmsg_buf) < l)
-		strcat(savebuf, winmsg_buf);
-	      strcpy(winmsg_buf, savebuf);
+		strlcat(savebuf, winmsg_buf, sizeof(savebuf));
+	      strlcpy(winmsg_buf, savebuf, sizeof(winmsg_buf));
 	      while (oldnumrend < winmsg_numrend)
 		winmsg_rendpos[oldnumrend++] += p - winmsg_buf;
 	      if (*p)
@@ -3174,3 +3233,83 @@ char *p;
   return 0;
 }
 
+#if defined(ENCODINGS) && defined(UTF8) && defined(POSIX)
+__RCSID("$miros: src/usr.sbin/wsconfig/wsconfig.c,v 1.16 2007/05/10 13:02:21 tg Exp $");
+__RCSID("$miros: ports/sysutils/chkuterm/dist/chkuterm.c,v 1.11 2007/05/10 13:02:22 tg Exp $");
+__RCSID("$MirOS: ports/misc/screen/patches/patch-screen_c,v 1.14 2008/10/13 20:58:16 tg Exp $");
+static const char sfe_qs[] = "\030\032\r\xE2\x82\xAC.\033[6n";
+
+int
+scan_for_encoding(fd)
+int fd;
+{
+	struct termios tio, otio;
+	char ch;
+	int nr, rv = -1;
+	fd_set fds;
+	struct timeval tv;
+	FILE *wsf;
+
+	wsf = fdopen(nr = dup(fd), "rb+");
+	if (wsf == NULL)
+		close(nr);
+	if (tcgetattr(fd, &otio))
+		return (-1);
+	tio = otio;
+	cfmakeraw(&tio);
+	tcflush(fd, TCIOFLUSH);
+	if (tcsetattr(fd, TCSANOW, &tio))
+		goto out;
+	tv.tv_sec = 0;
+	tv.tv_usec = 75;
+	select(0, NULL, NULL, NULL, &tv);	/* sleep 75 msec */
+	if ((size_t)write(fd, sfe_qs, strlen(sfe_qs)) != strlen(sfe_qs))
+		goto noin;
+	select(0, NULL, NULL, NULL, &tv);	/* sleep 75 msec */
+	FD_ZERO(&fds);
+	FD_SET(fd, &fds);
+	tv.tv_sec = 2;
+	tv.tv_usec = 0;
+	if (select(fd + 1, &fds, NULL, NULL, &tv) <= 0)
+		goto noin;
+	nr = read(fd, &ch, 1);
+	if (wsf != NULL && nr == 1 && ch == 033) {
+		unsigned zeile, spalte;
+
+		if (fscanf(wsf, "[%u;%u", &zeile, &spalte) == 2) {
+			debug2("scan_for_encoding: at line %u column %u\n",
+			    zeile, spalte);
+			switch (spalte) {
+			case 1:	/* EUC-JP, EUC-KR kterm */
+				debug("scan_for_encoding: EUC-JP, EUC-KR\n");
+				if (0)
+			case 5:	/* Shift-JIS kterm */
+				debug("scan_for_encoding: Shift-JIS\n");
+				debug("scan_for_encoding: Japanese -> nochg\n");
+				break;
+			case 3:	/* UTF-8 xterm, screen */
+				debug("scan_for_encoding: UTF-8\n");
+				rv = UTF8;
+				break;
+			case 4:	/* ISO-8859-1 xterm, screen */
+				debug("scan_for_encoding: ISO-8859-1\n");
+				rv = 0;
+				break;
+			default:
+				debug1("scan_for_encoding: unknown @%u -> -1\n",
+				    spalte);
+				break;
+			}
+		} else
+			debug("scan_for_encoding: invalid response\n");
+	}
+ noin:
+	write(fd, "\r      \r", 8);
+ out:
+	tcflush(fd, TCIOFLUSH);
+	tcsetattr(fd, TCSANOW, &otio);
+	if (wsf != NULL)
+		fclose(wsf);
+	return (rv);
+}
+#endif
