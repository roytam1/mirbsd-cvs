$MirOS: ports/misc/screen/patches/patch-screen_c,v 1.14 2008/10/13 20:58:16 tg Exp $
$OpenBSD: shmpatch-screen_c,v 1.1 2003/11/22 00:56:58 espie Exp $
--- screen.c.orig	Sun Nov  2 19:11:06 2008
+++ screen.c	Thu Oct 15 17:38:24 2009
@@ -27,6 +27,19 @@
  * http://www.gnu.org/licenses/, or contact Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA  02111-1301  USA
  *
+ * Modified by:
+ * Copyright (c) 2006, 2007, 2008
+ *	Thorsten Glaser <tg@mirbsd.de>
+ *
+ * This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
+ * the utmost extent permitted by applicable law, neither express nor
+ * implied; without malicious intent or gross negligence. In no event
+ * may a licensor, author or contributor be held liable for indirect,
+ * direct, other damage, loss, or other issues arising in any way out
+ * of dealing in the work, even if advised of the possibility of such
+ * damage or existence of a defect, except proven that it results out
+ * of said person's immediate fault when using the work as intended.
+ *
  ****************************************************************
  */
 
@@ -44,9 +57,7 @@
 # include <sys/ioctl.h>
 #endif
 
-#ifndef SIGINT
 # include <signal.h>
-#endif
 
 #include "config.h"
 
@@ -71,6 +82,12 @@
 #if (defined(AUX) || defined(_AUX_SOURCE)) && defined(POSIX)
 # include <compat.h>
 #endif
+
+#ifdef IPC_EXPORT_IMAGE
+# include <sys/ipc.h>
+# include <sys/shm.h>
+#endif
+
 #if defined(USE_LOCALE) || defined(ENCODINGS)
 # include <locale.h>
 #endif
@@ -78,6 +95,11 @@
 # include <langinfo.h>
 #endif
 
+#ifdef IPC_EXPORT_IMAGE
+# include <sys/ipc.h>
+# include <sys/shm.h>
+#endif
+
 #include "screen.h"
 #ifdef HAVE_BRAILLE
 # include "braille.h"
@@ -154,6 +176,9 @@ static void  showCompiledConfig();
 #ifdef DEBUG
 static void  fds __P((void));
 #endif
+#if defined(ENCODINGS) && defined(UTF8) && defined(POSIX)
+int          scan_for_encoding __P((int));
+#endif
 
 int nversion;	/* numerical version, used for secondary DA */
 
@@ -238,6 +263,10 @@ struct win *console_window;
 
 
 
+#ifdef IPC_EXPORT_IMAGE
+char *shm;              /* pointer to shared memory segment */
+#endif
+
 /*
  * Do this last
  */
@@ -397,8 +426,11 @@ char **av;
 #ifdef DEBUG
   opendebug(1, 0);
 #endif
+#ifndef PORT_VERSION
+#define PORT_VERSION ""
+#endif
   sprintf(version, "%d.%.2d.%.2d%s (%s) %s", REV, VERS,
-	  PATCHLEVEL, STATE, ORIGIN, DATE);
+	  PATCHLEVEL, STATE PORT_VERSION, ORIGIN, DATE);
   nversion = REV * 10000 + VERS * 100 + PATCHLEVEL;
   debug2("-- screen debug started %s (%s)\n", *av, version);
 #ifdef POSIX
@@ -478,6 +510,37 @@ char **av;
   zmodem_recvcmd = SaveStr("!!! rz -vv -b -E");
 #endif
 
+#ifdef IPC_EXPORT_IMAGE
+  {
+    key_t key = 0xBACD072F;     /* random static IPC key */
+    int shmid;
+
+    /* Allocation of shared mem for 18000 bytes (screen text and attributes
+     * + few coord.).  We supose no screen will be wider than 132x66.
+     * 0x1C0 = [rwx------].
+     */
+    shmid = shmget( key, 18000, IPC_CREAT | 0x1C0 );
+    if( shmid < 0 )
+      {
+        Panic( errno, "shmget" );
+        /* NOTRECHED */
+      }
+    shm = shmat( shmid, 0, 0);
+    if ( shm == (void*)-1 )
+      {
+        Panic( errno, "shmat" );
+        /* NOTRECHED */
+      }
+    /* minimal initialisation just to have valid data */
+    shm[0] = 80;   /* scrdim x */
+    shm[1] = 1;    /* scrdim y */
+    shm[2] = 0;    /* csrpos x */
+    shm[3] = 0;    /* csrpos y */
+    strcpy( shm+4, "screen is initializing..." );
+    memset( shm+4+strlen(shm+4), ' ', 80);
+  }
+#endif
+
 #ifdef COPY_PASTE
   CompileKeys((char *)0, 0, mark_key_tab);
 #endif
@@ -1293,6 +1356,10 @@ char **av;
 	Panic(0, "Could not alloc display");
       PanicPid = 0;
 #ifdef ENCODINGS
+#if defined(UTF8) && defined(POSIX)
+      D_encoding = scan_for_encoding(n);
+      if (D_encoding < 0)
+#endif
       D_encoding = nwin_options.encoding > 0 ? nwin_options.encoding : 0;
       debug1("D_encoding = %d\n", D_encoding);
 #endif
@@ -2563,10 +2630,10 @@ int rec;
 #endif
 	      break;
 	    case 'y':
-	      sprintf(p, "%02d", tm->tm_year % 100);
+	      sprintf(p, "%02d", (int)(tm->tm_year % 100));
 	      break;
 	    case 'Y':
-	      sprintf(p, "%04d", tm->tm_year + 1900);
+	      sprintf(p, "%04d", (int)(tm->tm_year + 1900));
 	      break;
 	    case 'a':
 	      sprintf(p, tm->tm_hour >= 12 ? "pm" : "am");
@@ -3346,6 +3413,86 @@ char *p;
   return 0;
 }
 
+#if defined(ENCODINGS) && defined(UTF8) && defined(POSIX)
+__RCSID("$miros: src/usr.sbin/wsconfig/wsconfig.c,v 1.16 2007/05/10 13:02:21 tg Exp $");
+__RCSID("$miros: ports/sysutils/chkuterm/dist/chkuterm.c,v 1.11 2007/05/10 13:02:22 tg Exp $");
+__RCSID("$MirOS: ports/misc/screen/patches/patch-screen_c,v 1.14 2008/10/13 20:58:16 tg Exp $");
+static const char sfe_qs[] = "\030\032\r\xE2\x82\xAC.\033[6n";
+
+int
+scan_for_encoding(fd)
+int fd;
+{
+	struct termios tio, otio;
+	char ch;
+	int nr, rv = -1;
+	fd_set fds;
+	struct timeval tv;
+	FILE *wsf;
+
+	wsf = fdopen(nr = dup(fd), "rb+");
+	if (wsf == NULL)
+		close(nr);
+	if (tcgetattr(fd, &otio))
+		return (-1);
+	tio = otio;
+	cfmakeraw(&tio);
+	tcflush(fd, TCIOFLUSH);
+	if (tcsetattr(fd, TCSANOW, &tio))
+		goto out;
+	tv.tv_sec = 0;
+	tv.tv_usec = 75;
+	select(0, NULL, NULL, NULL, &tv);	/* sleep 75 msec */
+	if ((size_t)write(fd, sfe_qs, strlen(sfe_qs)) != strlen(sfe_qs))
+		goto noin;
+	select(0, NULL, NULL, NULL, &tv);	/* sleep 75 msec */
+	FD_ZERO(&fds);
+	FD_SET(fd, &fds);
+	tv.tv_sec = 2;
+	tv.tv_usec = 0;
+	if (select(fd + 1, &fds, NULL, NULL, &tv) <= 0)
+		goto noin;
+	nr = read(fd, &ch, 1);
+	if (wsf != NULL && nr == 1 && ch == 033) {
+		unsigned zeile, spalte;
+
+		if (fscanf(wsf, "[%u;%u", &zeile, &spalte) == 2) {
+			debug2("scan_for_encoding: at line %u column %u\n",
+			    zeile, spalte);
+			switch (spalte) {
+			case 1:	/* EUC-JP, EUC-KR kterm */
+				debug("scan_for_encoding: EUC-JP, EUC-KR\n");
+				if (0)
+			case 5:	/* Shift-JIS kterm */
+				debug("scan_for_encoding: Shift-JIS\n");
+				debug("scan_for_encoding: Japanese -> nochg\n");
+				break;
+			case 3:	/* UTF-8 xterm, screen */
+				debug("scan_for_encoding: UTF-8\n");
+				rv = UTF8;
+				break;
+			case 4:	/* ISO-8859-1 xterm, screen */
+				debug("scan_for_encoding: ISO-8859-1\n");
+				rv = 0;
+				break;
+			default:
+				debug1("scan_for_encoding: unknown @%u -> -1\n",
+				    spalte);
+				break;
+			}
+		} else
+			debug("scan_for_encoding: invalid response\n");
+	}
+ noin:
+	write(fd, "\r      \r", 8);
+ out:
+	tcflush(fd, TCIOFLUSH);
+	tcsetattr(fd, TCSANOW, &otio);
+	if (wsf != NULL)
+		fclose(wsf);
+	return (rv);
+}
+#endif
 
 
 static void
