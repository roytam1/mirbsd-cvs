#!/usr/bin/perl
# $MirOS$

# Tool to repair MBX mailbox files as used by
# UW imapd, c-client, Pine etc.
# Andrew Daviel TRIUMF Oct 2001  <advax@triumf.ca>
# (licence=http://mirbsd.de/MirOS-Licence)

# Copyright (c) 2001,2005
#	Andrew Daviel <advax@triumf.ca>
#
# Licensee is hereby permitted to deal in this work without restric-
# tion, including unlimited rights to use, publicly perform, modify,
# merge, distribute, sell, give away or sublicence, provided all co-
# pyright notices above, these terms and the disclaimer are retained
# in all redistributions or reproduced in accompanying documentation
# or other materials provided with binary redistributions.
#
# Licensor hereby provides this work "AS IS" and WITHOUT WARRANTY of
# any kind, expressed or implied, to the maximum extent permitted by
# applicable law, but with the warranty of being written without ma-
# licious intent or gross negligence; in no event shall licensor, an
# author or contributor be held liable for any damage, direct, indi-
# rect or other, however caused, arising in any way out of the usage
# of this work, even if advised of the possibility of such damage.


if ($ARGV[0] eq '-v') {
  $debug ++ ;
  shift(@ARGV) ;
}
if ($ARGV[0] eq '-v') {
  $debug ++ ;
  shift(@ARGV) ;
}
if ($ARGV[0] eq '-v') {
  $debug ++ ;
  shift(@ARGV) ;
}

unless ($ARGV[0]) {
  print STDERR "Usage: $0 [-v] <infile> [<outfile>]\n" ;
  print STDERR "Repair MBX format mailbox. If output file not present, check errors then die\n" ;
  print STDERR "Options: -v verbose, use more than once for more\n" ;
  exit ;
}
open (IN,$ARGV[0]) or die "Cannot open input file $ARGV[0]\n" ;;
$h = <IN> ; unless ($h eq "*mbx*\r\n") { die "Not a valid MBX file\n" ;; }
<IN> =~ /([\w]{8})([\w]{8})/ ;
$val = hex($1) ; $luid = hex($2) ;
$lval = localtime($val) ; if ($debug) { print "Created $lval last UID $luid\n" ; }
for ($i=0;$i<30;$i++) {
  $l = <IN> ;
  push (@uflag,$l) ;
}
$_ = <IN> ; $last = $_ ;
tr/\000//d ; # remove NULs from first header
/(.[\d]-[\w]{3}-[\d]{4} [\d][\d]:[\d][\d]:[\d][\d].*),([\d]*);(0000000[\w]*)-([\w]*)/ ;
$date = $1 ; $j = $2 ; $flags = hex($3) ; $uid = hex($4) ; $nuid = $uid+1 ; $nm = 1 ;
$aflag = '' ;
unless ($flags & 1) { $aflag .= 'new ' ; }
if ($flags & 2) { $aflag .= 'deleted ' ; }
if ($flags & 4) { $aflag .= 'flagged ' ; }
if ($flags & 8) { $aflag .= 'answered ' ; }
if ($flags & 16) { $aflag .= 'old ' ; }
if ($flags & 32) { $aflag .= 'draft ' ; }
if ($debug) { print "$date length $j UID $uid $aflag\n" ; }
while (<IN>) {
  if ( /(.[\d]-[\w]{3}-[\d]{4} [\d][\d]:[\d][\d]:[\d][\d].*),([\d]*);([\w]*)-([\w]*)/) {
    $j0 = $j ; $nm++ ; $date0 = $date ; $uid0 = $uid ;
    $date = $1 ; $j = $2 ; $flags = hex($3) ; $uid = hex($4) ;
    $aflag = '' ;
    if ($flags & 1) { $aflag .= 'seen ' ; }
    if ($flags & 2) { $aflag .= 'deleted ' ; }
    if ($flags & 4) { $aflag .= 'flagged ' ; }
    if ($flags & 8) { $aflag .= 'answered ' ; }
    if ($flags & 16) { $aflag .= 'old ' ; }
    if ($flags & 32) { $aflag .= 'draft ' ; }
    $pl = length($body) ;
    if ($uid>$maxuid) { $maxuid = $uid ; }
    if ($pl != $j0) {
      print "* $date0  uid $uid0 length mismatch $j0 repair $pl\n" ;
      $repair{$nm-1} = $pl ; $nr++ ;
    }
    if ($uid{$uid}) {
      print "* $date length $j duplicate UID $uid\n" ;
      $fixuid++ ;
    }
    $uid{$uid} ++ ;
#    if ($nuid != $uid) {
#      print "* $date length $j UID $uid expected $nuid\n" ;
#      $fixuid++ ;
#    }
    if ($uid > $luid) {
      print "* $date UID $uid exceeds $luid\n" ;
    }
    $last = $_ ; $nuid = $uid + 1 ;

    if ($debug) { print "$date length $j UID $uid $aflag\n" ; }
    $body = '' ;
    next ;
  }
#  rest of message
  if ($debug > 1 && /^Subject: /) { print "  $_" ; }
  if ($debug > 1 && /^From: /) { print "  $_" ; }
  if ($debug > 2 && /^Date: /) { print "  $_" ; }
  if ($debug > 2 && /^Message-Id: /i) { print "  $_" ; }
  if ($debug > 2 && /^To: /) { print "  $_" ; }

  $body .= $_ ;
}
$j0 = $j ;
$pl = length($body) ;
if ($pl != $j0) {
  print "* $date0  uid $uid0  mismatch $j0 repair $pl\n" ;
  $repair{$nm-1} = $pl ; $nr++ ;
}
if ($luid != $maxuid) {
  print "* Largest UID $maxuid != $luid in header\n" ;
}
close(IN) ;

if ($fixuid) { $maxuid = $nm ; }

#while (($repair,$len) = each (%repair)) {
#  $nr++ ;
#  print "repair $repair with $len\n" ;
#}
unless ($nr || $fixuid) { exit ; }
print "$nr length repairs\n$fixuid UID repairs\n" ;

$fixuid = 0 ;

open (IN,$ARGV[0]) or die "Cannot open input file\n" ;
open (OUT,">$ARGV[1]") or die "Cannot create output file \"$ARGV[1]\"\n" ;

$h = <IN> ; unless ($h eq "*mbx*\r\n") { die "Not a valid MBX file\n"  ; }
print OUT $h ;
$l = <IN> ; # print OUT $l ;
$l =~ /([\w]{8})([\w]{8})/ ;
$val = hex($1) ; $luid = hex($2) ;
$lval = localtime($val) ;
printf OUT ("%8.8x%8.8x\r\n",time(),$maxuid) ;
for ($i=0;$i<30;$i++) {
  $l = <IN> ; print OUT $l ;
  push (@uflag,$l) ;
}
$_ = <IN> ;
/(.*[\d]-[\w]{3}-[\d]{4} [\d][\d]:[\d][\d]:[\d][\d].*),([\d]*);(0000000[\w]*)-([\w]*)/ ;
$date = $1 ; $j = $2 ; $flags = $3 ; $uid = $4 ; $nm =  1 ;
if ($fixuid) {
  $nuid = sprintf("%8.8x",$nm) ;
  s/-$uid/-$nuid/ ;
 }
if ($repair{$nm}) {
  print "repair $_ with $repair{$nm}\n" ;
#  $j = $repair{$nm} ;
  s/,$j;/,$repair{$nm};/;
}
print OUT $_ ;
#print OUT "$date,$j;$flags-$uid\r\n" ;
while (<IN>) {
  if ( /(.[\d]-[\w]{3}-[\d]{4} [\d][\d]:[\d][\d]:[\d][\d].*),([\d]*);([\w]*)-([\w]*)/) {
    $date = $1 ; $j = $2 ; $flags = $3 ; $uid = $4 ; $nm++ ;
    if ($fixuid) { $uid = sprintf("%8.8x",$nm) ; }
    if ($repair{$nm}) {
      print "repair $_ with $repair{$nm}\n" ;
      $j = $repair{$nm} ;
    }
    print OUT "$date,$j;$flags-$uid\r\n" ;
    if ($debug) { print "$date,$j;$flags-$uid\n" ; }
    next ;
  }
  print OUT $_ ;
}
